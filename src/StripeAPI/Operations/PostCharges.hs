{-# LANGUAGE ExplicitForAll #-}
{-# LANGUAGE MultiWayIf #-}
-- CHANGE WITH CAUTION: This is a generated code file generated by https://github.com/Haskell-OpenAPI-Code-Generator/Haskell-OpenAPI-Client-Code-Generator.
{-# LANGUAGE OverloadedStrings #-}

-- | Contains the different functions to run the operation postCharges
module StripeAPI.Operations.PostCharges where

import qualified Control.Monad.Fail
import qualified Control.Monad.Trans.Reader
import qualified Data.Aeson
import qualified Data.Aeson as Data.Aeson.Encoding.Internal
import qualified Data.Aeson as Data.Aeson.Types
import qualified Data.Aeson as Data.Aeson.Types.FromJSON
import qualified Data.Aeson as Data.Aeson.Types.Internal
import qualified Data.Aeson as Data.Aeson.Types.ToJSON
import qualified Data.ByteString.Char8
import qualified Data.ByteString.Char8 as Data.ByteString.Internal
import qualified Data.Either
import qualified Data.Functor
import qualified Data.Scientific
import qualified Data.Text
import qualified Data.Text.Internal
import qualified Data.Time.Calendar as Data.Time.Calendar.Days
import qualified Data.Time.LocalTime as Data.Time.LocalTime.Internal.ZonedTime
import qualified Data.Vector
import qualified GHC.Base
import qualified GHC.Classes
import qualified GHC.Int
import qualified GHC.Show
import qualified GHC.Types
import qualified Network.HTTP.Client
import qualified Network.HTTP.Client as Network.HTTP.Client.Request
import qualified Network.HTTP.Client as Network.HTTP.Client.Types
import qualified Network.HTTP.Simple
import qualified Network.HTTP.Types
import qualified Network.HTTP.Types as Network.HTTP.Types.Status
import qualified Network.HTTP.Types as Network.HTTP.Types.URI
import qualified StripeAPI.Common
import StripeAPI.Types
import qualified Prelude as GHC.Integer.Type
import qualified Prelude as GHC.Maybe

-- | > POST /v1/charges
--
-- \<p>To charge a credit card or other payment source, you create a \<code>Charge\<\/code> object. If your API key is in test mode, the supplied payment source (e.g., card) won’t actually be charged, although everything else will occur as if in live mode. (Stripe assumes that the charge would have completed successfully).\<\/p>
postCharges ::
  forall m.
  StripeAPI.Common.MonadHTTP m =>
  -- | The request body to send
  GHC.Maybe.Maybe PostChargesRequestBody ->
  -- | Monadic computation which returns the result of the operation
  StripeAPI.Common.ClientT m (Network.HTTP.Client.Types.Response PostChargesResponse)
postCharges body =
  GHC.Base.fmap
    ( \response_0 ->
        GHC.Base.fmap
          ( Data.Either.either PostChargesResponseError GHC.Base.id
              GHC.Base.. ( \response body ->
                             if
                                 | (\status_1 -> Network.HTTP.Types.Status.statusCode status_1 GHC.Classes.== 200) (Network.HTTP.Client.Types.responseStatus response) ->
                                   PostChargesResponse200
                                     Data.Functor.<$> ( Data.Aeson.eitherDecodeStrict body ::
                                                          Data.Either.Either
                                                            GHC.Base.String
                                                            Charge
                                                      )
                                 | GHC.Base.const GHC.Types.True (Network.HTTP.Client.Types.responseStatus response) ->
                                   PostChargesResponseDefault
                                     Data.Functor.<$> ( Data.Aeson.eitherDecodeStrict body ::
                                                          Data.Either.Either
                                                            GHC.Base.String
                                                            Error
                                                      )
                                 | GHC.Base.otherwise -> Data.Either.Left "Missing default response type"
                         )
                response_0
          )
          response_0
    )
    (StripeAPI.Common.doBodyCallWithConfigurationM (Data.Text.toUpper GHC.Base.$ Data.Text.pack "POST") (Data.Text.pack "/v1/charges") GHC.Base.mempty body StripeAPI.Common.RequestBodyEncodingFormData)

-- | Defines the object schema located at @paths.\/v1\/charges.POST.requestBody.content.application\/x-www-form-urlencoded.schema@ in the specification.
data PostChargesRequestBody = PostChargesRequestBody
  { -- | amount: Amount intended to be collected by this payment. A positive integer representing how much to charge in the [smallest currency unit](https:\/\/stripe.com\/docs\/currencies\#zero-decimal) (e.g., 100 cents to charge \$1.00 or 100 to charge ¥100, a zero-decimal currency). The minimum amount is \$0.50 US or [equivalent in charge currency](https:\/\/stripe.com\/docs\/currencies\#minimum-and-maximum-charge-amounts). The amount value supports up to eight digits (e.g., a value of 99999999 for a USD charge of \$999,999.99).
    postChargesRequestBodyAmount :: (GHC.Maybe.Maybe GHC.Types.Int),
    -- | application_fee
    postChargesRequestBodyApplicationFee :: (GHC.Maybe.Maybe GHC.Types.Int),
    -- | application_fee_amount: A fee in %s that will be applied to the charge and transferred to the application owner\'s Stripe account. The request must be made with an OAuth key or the \`Stripe-Account\` header in order to take an application fee. For more information, see the application fees [documentation](https:\/\/stripe.com\/docs\/connect\/direct-charges\#collecting-fees).
    postChargesRequestBodyApplicationFeeAmount :: (GHC.Maybe.Maybe GHC.Types.Int),
    -- | capture: Whether to immediately capture the charge. Defaults to \`true\`. When \`false\`, the charge issues an authorization (or pre-authorization), and will need to be [captured](https:\/\/stripe.com\/docs\/api\#capture_charge) later. Uncaptured charges expire in _seven days_. For more information, see the [authorizing charges and settling later](https:\/\/stripe.com\/docs\/charges\/placing-a-hold) documentation.
    postChargesRequestBodyCapture :: (GHC.Maybe.Maybe GHC.Types.Bool),
    -- | card: A token, like the ones returned by [Stripe.js](https:\/\/stripe.com\/docs\/stripe.js).
    postChargesRequestBodyCard :: (GHC.Maybe.Maybe PostChargesRequestBodyCard'Variants),
    -- | currency: Three-letter [ISO currency code](https:\/\/www.iso.org\/iso-4217-currency-codes.html), in lowercase. Must be a [supported currency](https:\/\/stripe.com\/docs\/currencies).
    postChargesRequestBodyCurrency :: (GHC.Maybe.Maybe Data.Text.Internal.Text),
    -- | customer: The ID of an existing customer that will be charged in this request.
    --
    -- Constraints:
    --
    -- * Maximum length of 500
    postChargesRequestBodyCustomer :: (GHC.Maybe.Maybe Data.Text.Internal.Text),
    -- | description: An arbitrary string which you can attach to a \`Charge\` object. It is displayed when in the web interface alongside the charge. Note that if you use Stripe to send automatic email receipts to your customers, your receipt emails will include the \`description\` of the charge(s) that they are describing.
    --
    -- Constraints:
    --
    -- * Maximum length of 40000
    postChargesRequestBodyDescription :: (GHC.Maybe.Maybe Data.Text.Internal.Text),
    -- | destination
    postChargesRequestBodyDestination :: (GHC.Maybe.Maybe PostChargesRequestBodyDestination'Variants),
    -- | expand: Specifies which fields in the response should be expanded.
    postChargesRequestBodyExpand :: (GHC.Maybe.Maybe ([Data.Text.Internal.Text])),
    -- | metadata: Set of [key-value pairs](https:\/\/stripe.com\/docs\/api\/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to \`metadata\`.
    postChargesRequestBodyMetadata :: (GHC.Maybe.Maybe PostChargesRequestBodyMetadata'Variants),
    -- | on_behalf_of: The Stripe account ID for which these funds are intended. Automatically set if you use the \`destination\` parameter. For details, see [Creating Separate Charges and Transfers](https:\/\/stripe.com\/docs\/connect\/charges-transfers\#on-behalf-of).
    --
    -- Constraints:
    --
    -- * Maximum length of 5000
    postChargesRequestBodyOnBehalfOf :: (GHC.Maybe.Maybe Data.Text.Internal.Text),
    -- | receipt_email: The email address to which this charge\'s [receipt](https:\/\/stripe.com\/docs\/dashboard\/receipts) will be sent. The receipt will not be sent until the charge is paid, and no receipts will be sent for test mode charges. If this charge is for a [Customer](https:\/\/stripe.com\/docs\/api\/customers\/object), the email address specified here will override the customer\'s email address. If \`receipt_email\` is specified for a charge in live mode, a receipt will be sent regardless of your [email settings](https:\/\/dashboard.stripe.com\/account\/emails).
    postChargesRequestBodyReceiptEmail :: (GHC.Maybe.Maybe Data.Text.Internal.Text),
    -- | shipping: Shipping information for the charge. Helps prevent fraud on charges for physical goods.
    postChargesRequestBodyShipping :: (GHC.Maybe.Maybe PostChargesRequestBodyShipping'),
    -- | source: A payment source to be charged. This can be the ID of a [card](https:\/\/stripe.com\/docs\/api\#cards) (i.e., credit or debit card), a [bank account](https:\/\/stripe.com\/docs\/api\#bank_accounts), a [source](https:\/\/stripe.com\/docs\/api\#sources), a [token](https:\/\/stripe.com\/docs\/api\#tokens), or a [connected account](https:\/\/stripe.com\/docs\/connect\/account-debits\#charging-a-connected-account). For certain sources---namely, [cards](https:\/\/stripe.com\/docs\/api\#cards), [bank accounts](https:\/\/stripe.com\/docs\/api\#bank_accounts), and attached [sources](https:\/\/stripe.com\/docs\/api\#sources)---you must also pass the ID of the associated customer.
    --
    -- Constraints:
    --
    -- * Maximum length of 5000
    postChargesRequestBodySource :: (GHC.Maybe.Maybe Data.Text.Internal.Text),
    -- | statement_descriptor: For card charges, use \`statement_descriptor_suffix\` instead. Otherwise, you can use this value as the complete description of a charge on your customers’ statements. Must contain at least one letter, maximum 22 characters.
    --
    -- Constraints:
    --
    -- * Maximum length of 22
    postChargesRequestBodyStatementDescriptor :: (GHC.Maybe.Maybe Data.Text.Internal.Text),
    -- | statement_descriptor_suffix: Provides information about the charge that customers see on their statements. Concatenated with the prefix (shortened descriptor) or statement descriptor that’s set on the account to form the complete statement descriptor. Maximum 22 characters for the concatenated descriptor.
    --
    -- Constraints:
    --
    -- * Maximum length of 22
    postChargesRequestBodyStatementDescriptorSuffix :: (GHC.Maybe.Maybe Data.Text.Internal.Text),
    -- | transfer_data: An optional dictionary including the account to automatically transfer to as part of a destination charge. [See the Connect documentation](https:\/\/stripe.com\/docs\/connect\/destination-charges) for details.
    postChargesRequestBodyTransferData :: (GHC.Maybe.Maybe PostChargesRequestBodyTransferData'),
    -- | transfer_group: A string that identifies this transaction as part of a group. For details, see [Grouping transactions](https:\/\/stripe.com\/docs\/connect\/charges-transfers\#transfer-options).
    postChargesRequestBodyTransferGroup :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  }
  deriving
    ( GHC.Show.Show,
      GHC.Classes.Eq
    )

instance Data.Aeson.Types.ToJSON.ToJSON PostChargesRequestBody where
  toJSON obj = Data.Aeson.Types.Internal.object ("amount" Data.Aeson.Types.ToJSON..= postChargesRequestBodyAmount obj : "application_fee" Data.Aeson.Types.ToJSON..= postChargesRequestBodyApplicationFee obj : "application_fee_amount" Data.Aeson.Types.ToJSON..= postChargesRequestBodyApplicationFeeAmount obj : "capture" Data.Aeson.Types.ToJSON..= postChargesRequestBodyCapture obj : "card" Data.Aeson.Types.ToJSON..= postChargesRequestBodyCard obj : "currency" Data.Aeson.Types.ToJSON..= postChargesRequestBodyCurrency obj : "customer" Data.Aeson.Types.ToJSON..= postChargesRequestBodyCustomer obj : "description" Data.Aeson.Types.ToJSON..= postChargesRequestBodyDescription obj : "destination" Data.Aeson.Types.ToJSON..= postChargesRequestBodyDestination obj : "expand" Data.Aeson.Types.ToJSON..= postChargesRequestBodyExpand obj : "metadata" Data.Aeson.Types.ToJSON..= postChargesRequestBodyMetadata obj : "on_behalf_of" Data.Aeson.Types.ToJSON..= postChargesRequestBodyOnBehalfOf obj : "receipt_email" Data.Aeson.Types.ToJSON..= postChargesRequestBodyReceiptEmail obj : "shipping" Data.Aeson.Types.ToJSON..= postChargesRequestBodyShipping obj : "source" Data.Aeson.Types.ToJSON..= postChargesRequestBodySource obj : "statement_descriptor" Data.Aeson.Types.ToJSON..= postChargesRequestBodyStatementDescriptor obj : "statement_descriptor_suffix" Data.Aeson.Types.ToJSON..= postChargesRequestBodyStatementDescriptorSuffix obj : "transfer_data" Data.Aeson.Types.ToJSON..= postChargesRequestBodyTransferData obj : "transfer_group" Data.Aeson.Types.ToJSON..= postChargesRequestBodyTransferGroup obj : GHC.Base.mempty)
  toEncoding obj = Data.Aeson.Encoding.Internal.pairs (("amount" Data.Aeson.Types.ToJSON..= postChargesRequestBodyAmount obj) GHC.Base.<> (("application_fee" Data.Aeson.Types.ToJSON..= postChargesRequestBodyApplicationFee obj) GHC.Base.<> (("application_fee_amount" Data.Aeson.Types.ToJSON..= postChargesRequestBodyApplicationFeeAmount obj) GHC.Base.<> (("capture" Data.Aeson.Types.ToJSON..= postChargesRequestBodyCapture obj) GHC.Base.<> (("card" Data.Aeson.Types.ToJSON..= postChargesRequestBodyCard obj) GHC.Base.<> (("currency" Data.Aeson.Types.ToJSON..= postChargesRequestBodyCurrency obj) GHC.Base.<> (("customer" Data.Aeson.Types.ToJSON..= postChargesRequestBodyCustomer obj) GHC.Base.<> (("description" Data.Aeson.Types.ToJSON..= postChargesRequestBodyDescription obj) GHC.Base.<> (("destination" Data.Aeson.Types.ToJSON..= postChargesRequestBodyDestination obj) GHC.Base.<> (("expand" Data.Aeson.Types.ToJSON..= postChargesRequestBodyExpand obj) GHC.Base.<> (("metadata" Data.Aeson.Types.ToJSON..= postChargesRequestBodyMetadata obj) GHC.Base.<> (("on_behalf_of" Data.Aeson.Types.ToJSON..= postChargesRequestBodyOnBehalfOf obj) GHC.Base.<> (("receipt_email" Data.Aeson.Types.ToJSON..= postChargesRequestBodyReceiptEmail obj) GHC.Base.<> (("shipping" Data.Aeson.Types.ToJSON..= postChargesRequestBodyShipping obj) GHC.Base.<> (("source" Data.Aeson.Types.ToJSON..= postChargesRequestBodySource obj) GHC.Base.<> (("statement_descriptor" Data.Aeson.Types.ToJSON..= postChargesRequestBodyStatementDescriptor obj) GHC.Base.<> (("statement_descriptor_suffix" Data.Aeson.Types.ToJSON..= postChargesRequestBodyStatementDescriptorSuffix obj) GHC.Base.<> (("transfer_data" Data.Aeson.Types.ToJSON..= postChargesRequestBodyTransferData obj) GHC.Base.<> ("transfer_group" Data.Aeson.Types.ToJSON..= postChargesRequestBodyTransferGroup obj)))))))))))))))))))

instance Data.Aeson.Types.FromJSON.FromJSON PostChargesRequestBody where
  parseJSON = Data.Aeson.Types.FromJSON.withObject "PostChargesRequestBody" (\obj -> ((((((((((((((((((GHC.Base.pure PostChargesRequestBody GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "amount")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "application_fee")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "application_fee_amount")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "capture")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "card")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "currency")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "customer")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "description")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "destination")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "expand")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "metadata")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "on_behalf_of")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "receipt_email")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "shipping")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "source")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "statement_descriptor")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "statement_descriptor_suffix")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "transfer_data")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "transfer_group"))

-- | Create a new 'PostChargesRequestBody' with all required fields.
mkPostChargesRequestBody :: PostChargesRequestBody
mkPostChargesRequestBody =
  PostChargesRequestBody
    { postChargesRequestBodyAmount = GHC.Maybe.Nothing,
      postChargesRequestBodyApplicationFee = GHC.Maybe.Nothing,
      postChargesRequestBodyApplicationFeeAmount = GHC.Maybe.Nothing,
      postChargesRequestBodyCapture = GHC.Maybe.Nothing,
      postChargesRequestBodyCard = GHC.Maybe.Nothing,
      postChargesRequestBodyCurrency = GHC.Maybe.Nothing,
      postChargesRequestBodyCustomer = GHC.Maybe.Nothing,
      postChargesRequestBodyDescription = GHC.Maybe.Nothing,
      postChargesRequestBodyDestination = GHC.Maybe.Nothing,
      postChargesRequestBodyExpand = GHC.Maybe.Nothing,
      postChargesRequestBodyMetadata = GHC.Maybe.Nothing,
      postChargesRequestBodyOnBehalfOf = GHC.Maybe.Nothing,
      postChargesRequestBodyReceiptEmail = GHC.Maybe.Nothing,
      postChargesRequestBodyShipping = GHC.Maybe.Nothing,
      postChargesRequestBodySource = GHC.Maybe.Nothing,
      postChargesRequestBodyStatementDescriptor = GHC.Maybe.Nothing,
      postChargesRequestBodyStatementDescriptorSuffix = GHC.Maybe.Nothing,
      postChargesRequestBodyTransferData = GHC.Maybe.Nothing,
      postChargesRequestBodyTransferGroup = GHC.Maybe.Nothing
    }

-- | Defines the object schema located at @paths.\/v1\/charges.POST.requestBody.content.application\/x-www-form-urlencoded.schema.properties.card.anyOf@ in the specification.
data PostChargesRequestBodyCard'OneOf1 = PostChargesRequestBodyCard'OneOf1
  { -- | address_city
    --
    -- Constraints:
    --
    -- * Maximum length of 5000
    postChargesRequestBodyCard'OneOf1AddressCity :: (GHC.Maybe.Maybe Data.Text.Internal.Text),
    -- | address_country
    --
    -- Constraints:
    --
    -- * Maximum length of 5000
    postChargesRequestBodyCard'OneOf1AddressCountry :: (GHC.Maybe.Maybe Data.Text.Internal.Text),
    -- | address_line1
    --
    -- Constraints:
    --
    -- * Maximum length of 5000
    postChargesRequestBodyCard'OneOf1AddressLine1 :: (GHC.Maybe.Maybe Data.Text.Internal.Text),
    -- | address_line2
    --
    -- Constraints:
    --
    -- * Maximum length of 5000
    postChargesRequestBodyCard'OneOf1AddressLine2 :: (GHC.Maybe.Maybe Data.Text.Internal.Text),
    -- | address_state
    --
    -- Constraints:
    --
    -- * Maximum length of 5000
    postChargesRequestBodyCard'OneOf1AddressState :: (GHC.Maybe.Maybe Data.Text.Internal.Text),
    -- | address_zip
    --
    -- Constraints:
    --
    -- * Maximum length of 5000
    postChargesRequestBodyCard'OneOf1AddressZip :: (GHC.Maybe.Maybe Data.Text.Internal.Text),
    -- | cvc
    --
    -- Constraints:
    --
    -- * Maximum length of 5000
    postChargesRequestBodyCard'OneOf1Cvc :: (GHC.Maybe.Maybe Data.Text.Internal.Text),
    -- | exp_month
    postChargesRequestBodyCard'OneOf1ExpMonth :: GHC.Types.Int,
    -- | exp_year
    postChargesRequestBodyCard'OneOf1ExpYear :: GHC.Types.Int,
    -- | metadata
    postChargesRequestBodyCard'OneOf1Metadata :: (GHC.Maybe.Maybe Data.Aeson.Types.Internal.Object),
    -- | name
    --
    -- Constraints:
    --
    -- * Maximum length of 5000
    postChargesRequestBodyCard'OneOf1Name :: (GHC.Maybe.Maybe Data.Text.Internal.Text),
    -- | number
    --
    -- Constraints:
    --
    -- * Maximum length of 5000
    postChargesRequestBodyCard'OneOf1Number :: Data.Text.Internal.Text,
    -- | object
    --
    -- Constraints:
    --
    -- * Maximum length of 5000
    postChargesRequestBodyCard'OneOf1Object :: (GHC.Maybe.Maybe PostChargesRequestBodyCard'OneOf1Object')
  }
  deriving
    ( GHC.Show.Show,
      GHC.Classes.Eq
    )

instance Data.Aeson.Types.ToJSON.ToJSON PostChargesRequestBodyCard'OneOf1 where
  toJSON obj = Data.Aeson.Types.Internal.object ("address_city" Data.Aeson.Types.ToJSON..= postChargesRequestBodyCard'OneOf1AddressCity obj : "address_country" Data.Aeson.Types.ToJSON..= postChargesRequestBodyCard'OneOf1AddressCountry obj : "address_line1" Data.Aeson.Types.ToJSON..= postChargesRequestBodyCard'OneOf1AddressLine1 obj : "address_line2" Data.Aeson.Types.ToJSON..= postChargesRequestBodyCard'OneOf1AddressLine2 obj : "address_state" Data.Aeson.Types.ToJSON..= postChargesRequestBodyCard'OneOf1AddressState obj : "address_zip" Data.Aeson.Types.ToJSON..= postChargesRequestBodyCard'OneOf1AddressZip obj : "cvc" Data.Aeson.Types.ToJSON..= postChargesRequestBodyCard'OneOf1Cvc obj : "exp_month" Data.Aeson.Types.ToJSON..= postChargesRequestBodyCard'OneOf1ExpMonth obj : "exp_year" Data.Aeson.Types.ToJSON..= postChargesRequestBodyCard'OneOf1ExpYear obj : "metadata" Data.Aeson.Types.ToJSON..= postChargesRequestBodyCard'OneOf1Metadata obj : "name" Data.Aeson.Types.ToJSON..= postChargesRequestBodyCard'OneOf1Name obj : "number" Data.Aeson.Types.ToJSON..= postChargesRequestBodyCard'OneOf1Number obj : "object" Data.Aeson.Types.ToJSON..= postChargesRequestBodyCard'OneOf1Object obj : GHC.Base.mempty)
  toEncoding obj = Data.Aeson.Encoding.Internal.pairs (("address_city" Data.Aeson.Types.ToJSON..= postChargesRequestBodyCard'OneOf1AddressCity obj) GHC.Base.<> (("address_country" Data.Aeson.Types.ToJSON..= postChargesRequestBodyCard'OneOf1AddressCountry obj) GHC.Base.<> (("address_line1" Data.Aeson.Types.ToJSON..= postChargesRequestBodyCard'OneOf1AddressLine1 obj) GHC.Base.<> (("address_line2" Data.Aeson.Types.ToJSON..= postChargesRequestBodyCard'OneOf1AddressLine2 obj) GHC.Base.<> (("address_state" Data.Aeson.Types.ToJSON..= postChargesRequestBodyCard'OneOf1AddressState obj) GHC.Base.<> (("address_zip" Data.Aeson.Types.ToJSON..= postChargesRequestBodyCard'OneOf1AddressZip obj) GHC.Base.<> (("cvc" Data.Aeson.Types.ToJSON..= postChargesRequestBodyCard'OneOf1Cvc obj) GHC.Base.<> (("exp_month" Data.Aeson.Types.ToJSON..= postChargesRequestBodyCard'OneOf1ExpMonth obj) GHC.Base.<> (("exp_year" Data.Aeson.Types.ToJSON..= postChargesRequestBodyCard'OneOf1ExpYear obj) GHC.Base.<> (("metadata" Data.Aeson.Types.ToJSON..= postChargesRequestBodyCard'OneOf1Metadata obj) GHC.Base.<> (("name" Data.Aeson.Types.ToJSON..= postChargesRequestBodyCard'OneOf1Name obj) GHC.Base.<> (("number" Data.Aeson.Types.ToJSON..= postChargesRequestBodyCard'OneOf1Number obj) GHC.Base.<> ("object" Data.Aeson.Types.ToJSON..= postChargesRequestBodyCard'OneOf1Object obj)))))))))))))

instance Data.Aeson.Types.FromJSON.FromJSON PostChargesRequestBodyCard'OneOf1 where
  parseJSON = Data.Aeson.Types.FromJSON.withObject "PostChargesRequestBodyCard'OneOf1" (\obj -> ((((((((((((GHC.Base.pure PostChargesRequestBodyCard'OneOf1 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "address_city")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "address_country")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "address_line1")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "address_line2")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "address_state")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "address_zip")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "cvc")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "exp_month")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "exp_year")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "metadata")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "name")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "number")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "object"))

-- | Create a new 'PostChargesRequestBodyCard'OneOf1' with all required fields.
mkPostChargesRequestBodyCard'OneOf1 ::
  -- | 'postChargesRequestBodyCard'OneOf1ExpMonth'
  GHC.Types.Int ->
  -- | 'postChargesRequestBodyCard'OneOf1ExpYear'
  GHC.Types.Int ->
  -- | 'postChargesRequestBodyCard'OneOf1Number'
  Data.Text.Internal.Text ->
  PostChargesRequestBodyCard'OneOf1
mkPostChargesRequestBodyCard'OneOf1 postChargesRequestBodyCard'OneOf1ExpMonth postChargesRequestBodyCard'OneOf1ExpYear postChargesRequestBodyCard'OneOf1Number =
  PostChargesRequestBodyCard'OneOf1
    { postChargesRequestBodyCard'OneOf1AddressCity = GHC.Maybe.Nothing,
      postChargesRequestBodyCard'OneOf1AddressCountry = GHC.Maybe.Nothing,
      postChargesRequestBodyCard'OneOf1AddressLine1 = GHC.Maybe.Nothing,
      postChargesRequestBodyCard'OneOf1AddressLine2 = GHC.Maybe.Nothing,
      postChargesRequestBodyCard'OneOf1AddressState = GHC.Maybe.Nothing,
      postChargesRequestBodyCard'OneOf1AddressZip = GHC.Maybe.Nothing,
      postChargesRequestBodyCard'OneOf1Cvc = GHC.Maybe.Nothing,
      postChargesRequestBodyCard'OneOf1ExpMonth = postChargesRequestBodyCard'OneOf1ExpMonth,
      postChargesRequestBodyCard'OneOf1ExpYear = postChargesRequestBodyCard'OneOf1ExpYear,
      postChargesRequestBodyCard'OneOf1Metadata = GHC.Maybe.Nothing,
      postChargesRequestBodyCard'OneOf1Name = GHC.Maybe.Nothing,
      postChargesRequestBodyCard'OneOf1Number = postChargesRequestBodyCard'OneOf1Number,
      postChargesRequestBodyCard'OneOf1Object = GHC.Maybe.Nothing
    }

-- | Defines the enum schema located at @paths.\/v1\/charges.POST.requestBody.content.application\/x-www-form-urlencoded.schema.properties.card.anyOf.properties.object@ in the specification.
data PostChargesRequestBodyCard'OneOf1Object'
  = -- | This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
    PostChargesRequestBodyCard'OneOf1Object'Other Data.Aeson.Types.Internal.Value
  | -- | This constructor can be used to send values to the server which are not present in the specification yet.
    PostChargesRequestBodyCard'OneOf1Object'Typed Data.Text.Internal.Text
  | -- | Represents the JSON value @"card"@
    PostChargesRequestBodyCard'OneOf1Object'EnumCard
  deriving (GHC.Show.Show, GHC.Classes.Eq)

instance Data.Aeson.Types.ToJSON.ToJSON PostChargesRequestBodyCard'OneOf1Object' where
  toJSON (PostChargesRequestBodyCard'OneOf1Object'Other val) = val
  toJSON (PostChargesRequestBodyCard'OneOf1Object'Typed val) = Data.Aeson.Types.ToJSON.toJSON val
  toJSON (PostChargesRequestBodyCard'OneOf1Object'EnumCard) = "card"

instance Data.Aeson.Types.FromJSON.FromJSON PostChargesRequestBodyCard'OneOf1Object' where
  parseJSON val =
    GHC.Base.pure
      ( if
            | val GHC.Classes.== "card" -> PostChargesRequestBodyCard'OneOf1Object'EnumCard
            | GHC.Base.otherwise -> PostChargesRequestBodyCard'OneOf1Object'Other val
      )

-- | Defines the oneOf schema located at @paths.\/v1\/charges.POST.requestBody.content.application\/x-www-form-urlencoded.schema.properties.card.anyOf@ in the specification.
--
-- A token, like the ones returned by [Stripe.js](https:\/\/stripe.com\/docs\/stripe.js).
data PostChargesRequestBodyCard'Variants
  = PostChargesRequestBodyCard'PostChargesRequestBodyCard'OneOf1 PostChargesRequestBodyCard'OneOf1
  | PostChargesRequestBodyCard'Text Data.Text.Internal.Text
  deriving (GHC.Show.Show, GHC.Classes.Eq)

instance Data.Aeson.Types.ToJSON.ToJSON PostChargesRequestBodyCard'Variants where
  toJSON (PostChargesRequestBodyCard'PostChargesRequestBodyCard'OneOf1 a) = Data.Aeson.Types.ToJSON.toJSON a
  toJSON (PostChargesRequestBodyCard'Text a) = Data.Aeson.Types.ToJSON.toJSON a

instance Data.Aeson.Types.FromJSON.FromJSON PostChargesRequestBodyCard'Variants where
  parseJSON val = case (PostChargesRequestBodyCard'PostChargesRequestBodyCard'OneOf1 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((PostChargesRequestBodyCard'Text Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> Data.Aeson.Types.Internal.Error "No variant matched") of
    Data.Aeson.Types.Internal.Success a -> GHC.Base.pure a
    Data.Aeson.Types.Internal.Error a -> Control.Monad.Fail.fail a

-- | Defines the object schema located at @paths.\/v1\/charges.POST.requestBody.content.application\/x-www-form-urlencoded.schema.properties.destination.anyOf@ in the specification.
data PostChargesRequestBodyDestination'OneOf1 = PostChargesRequestBodyDestination'OneOf1
  { -- | account
    --
    -- Constraints:
    --
    -- * Maximum length of 5000
    postChargesRequestBodyDestination'OneOf1Account :: Data.Text.Internal.Text,
    -- | amount
    postChargesRequestBodyDestination'OneOf1Amount :: (GHC.Maybe.Maybe GHC.Types.Int)
  }
  deriving
    ( GHC.Show.Show,
      GHC.Classes.Eq
    )

instance Data.Aeson.Types.ToJSON.ToJSON PostChargesRequestBodyDestination'OneOf1 where
  toJSON obj = Data.Aeson.Types.Internal.object ("account" Data.Aeson.Types.ToJSON..= postChargesRequestBodyDestination'OneOf1Account obj : "amount" Data.Aeson.Types.ToJSON..= postChargesRequestBodyDestination'OneOf1Amount obj : GHC.Base.mempty)
  toEncoding obj = Data.Aeson.Encoding.Internal.pairs (("account" Data.Aeson.Types.ToJSON..= postChargesRequestBodyDestination'OneOf1Account obj) GHC.Base.<> ("amount" Data.Aeson.Types.ToJSON..= postChargesRequestBodyDestination'OneOf1Amount obj))

instance Data.Aeson.Types.FromJSON.FromJSON PostChargesRequestBodyDestination'OneOf1 where
  parseJSON = Data.Aeson.Types.FromJSON.withObject "PostChargesRequestBodyDestination'OneOf1" (\obj -> (GHC.Base.pure PostChargesRequestBodyDestination'OneOf1 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "account")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "amount"))

-- | Create a new 'PostChargesRequestBodyDestination'OneOf1' with all required fields.
mkPostChargesRequestBodyDestination'OneOf1 ::
  -- | 'postChargesRequestBodyDestination'OneOf1Account'
  Data.Text.Internal.Text ->
  PostChargesRequestBodyDestination'OneOf1
mkPostChargesRequestBodyDestination'OneOf1 postChargesRequestBodyDestination'OneOf1Account =
  PostChargesRequestBodyDestination'OneOf1
    { postChargesRequestBodyDestination'OneOf1Account = postChargesRequestBodyDestination'OneOf1Account,
      postChargesRequestBodyDestination'OneOf1Amount = GHC.Maybe.Nothing
    }

-- | Defines the oneOf schema located at @paths.\/v1\/charges.POST.requestBody.content.application\/x-www-form-urlencoded.schema.properties.destination.anyOf@ in the specification.
data PostChargesRequestBodyDestination'Variants
  = PostChargesRequestBodyDestination'PostChargesRequestBodyDestination'OneOf1 PostChargesRequestBodyDestination'OneOf1
  | PostChargesRequestBodyDestination'Text Data.Text.Internal.Text
  deriving (GHC.Show.Show, GHC.Classes.Eq)

instance Data.Aeson.Types.ToJSON.ToJSON PostChargesRequestBodyDestination'Variants where
  toJSON (PostChargesRequestBodyDestination'PostChargesRequestBodyDestination'OneOf1 a) = Data.Aeson.Types.ToJSON.toJSON a
  toJSON (PostChargesRequestBodyDestination'Text a) = Data.Aeson.Types.ToJSON.toJSON a

instance Data.Aeson.Types.FromJSON.FromJSON PostChargesRequestBodyDestination'Variants where
  parseJSON val = case (PostChargesRequestBodyDestination'PostChargesRequestBodyDestination'OneOf1 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((PostChargesRequestBodyDestination'Text Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> Data.Aeson.Types.Internal.Error "No variant matched") of
    Data.Aeson.Types.Internal.Success a -> GHC.Base.pure a
    Data.Aeson.Types.Internal.Error a -> Control.Monad.Fail.fail a

-- | Defines the oneOf schema located at @paths.\/v1\/charges.POST.requestBody.content.application\/x-www-form-urlencoded.schema.properties.metadata.anyOf@ in the specification.
--
-- Set of [key-value pairs](https:\/\/stripe.com\/docs\/api\/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to \`metadata\`.
data PostChargesRequestBodyMetadata'Variants
  = -- | Represents the JSON value @""@
    PostChargesRequestBodyMetadata'EmptyString
  | PostChargesRequestBodyMetadata'Object Data.Aeson.Types.Internal.Object
  deriving (GHC.Show.Show, GHC.Classes.Eq)

instance Data.Aeson.Types.ToJSON.ToJSON PostChargesRequestBodyMetadata'Variants where
  toJSON (PostChargesRequestBodyMetadata'Object a) = Data.Aeson.Types.ToJSON.toJSON a
  toJSON (PostChargesRequestBodyMetadata'EmptyString) = ""

instance Data.Aeson.Types.FromJSON.FromJSON PostChargesRequestBodyMetadata'Variants where
  parseJSON val =
    if
        | val GHC.Classes.== "" -> GHC.Base.pure PostChargesRequestBodyMetadata'EmptyString
        | GHC.Base.otherwise -> case (PostChargesRequestBodyMetadata'Object Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> Data.Aeson.Types.Internal.Error "No variant matched" of
          Data.Aeson.Types.Internal.Success a -> GHC.Base.pure a
          Data.Aeson.Types.Internal.Error a -> Control.Monad.Fail.fail a

-- | Defines the object schema located at @paths.\/v1\/charges.POST.requestBody.content.application\/x-www-form-urlencoded.schema.properties.shipping@ in the specification.
--
-- Shipping information for the charge. Helps prevent fraud on charges for physical goods.
data PostChargesRequestBodyShipping' = PostChargesRequestBodyShipping'
  { -- | address
    postChargesRequestBodyShipping'Address :: PostChargesRequestBodyShipping'Address',
    -- | carrier
    --
    -- Constraints:
    --
    -- * Maximum length of 5000
    postChargesRequestBodyShipping'Carrier :: (GHC.Maybe.Maybe Data.Text.Internal.Text),
    -- | name
    --
    -- Constraints:
    --
    -- * Maximum length of 5000
    postChargesRequestBodyShipping'Name :: Data.Text.Internal.Text,
    -- | phone
    --
    -- Constraints:
    --
    -- * Maximum length of 5000
    postChargesRequestBodyShipping'Phone :: (GHC.Maybe.Maybe Data.Text.Internal.Text),
    -- | tracking_number
    --
    -- Constraints:
    --
    -- * Maximum length of 5000
    postChargesRequestBodyShipping'TrackingNumber :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  }
  deriving
    ( GHC.Show.Show,
      GHC.Classes.Eq
    )

instance Data.Aeson.Types.ToJSON.ToJSON PostChargesRequestBodyShipping' where
  toJSON obj = Data.Aeson.Types.Internal.object ("address" Data.Aeson.Types.ToJSON..= postChargesRequestBodyShipping'Address obj : "carrier" Data.Aeson.Types.ToJSON..= postChargesRequestBodyShipping'Carrier obj : "name" Data.Aeson.Types.ToJSON..= postChargesRequestBodyShipping'Name obj : "phone" Data.Aeson.Types.ToJSON..= postChargesRequestBodyShipping'Phone obj : "tracking_number" Data.Aeson.Types.ToJSON..= postChargesRequestBodyShipping'TrackingNumber obj : GHC.Base.mempty)
  toEncoding obj = Data.Aeson.Encoding.Internal.pairs (("address" Data.Aeson.Types.ToJSON..= postChargesRequestBodyShipping'Address obj) GHC.Base.<> (("carrier" Data.Aeson.Types.ToJSON..= postChargesRequestBodyShipping'Carrier obj) GHC.Base.<> (("name" Data.Aeson.Types.ToJSON..= postChargesRequestBodyShipping'Name obj) GHC.Base.<> (("phone" Data.Aeson.Types.ToJSON..= postChargesRequestBodyShipping'Phone obj) GHC.Base.<> ("tracking_number" Data.Aeson.Types.ToJSON..= postChargesRequestBodyShipping'TrackingNumber obj)))))

instance Data.Aeson.Types.FromJSON.FromJSON PostChargesRequestBodyShipping' where
  parseJSON = Data.Aeson.Types.FromJSON.withObject "PostChargesRequestBodyShipping'" (\obj -> ((((GHC.Base.pure PostChargesRequestBodyShipping' GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "address")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "carrier")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "name")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "phone")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "tracking_number"))

-- | Create a new 'PostChargesRequestBodyShipping'' with all required fields.
mkPostChargesRequestBodyShipping' ::
  -- | 'postChargesRequestBodyShipping'Address'
  PostChargesRequestBodyShipping'Address' ->
  -- | 'postChargesRequestBodyShipping'Name'
  Data.Text.Internal.Text ->
  PostChargesRequestBodyShipping'
mkPostChargesRequestBodyShipping' postChargesRequestBodyShipping'Address postChargesRequestBodyShipping'Name =
  PostChargesRequestBodyShipping'
    { postChargesRequestBodyShipping'Address = postChargesRequestBodyShipping'Address,
      postChargesRequestBodyShipping'Carrier = GHC.Maybe.Nothing,
      postChargesRequestBodyShipping'Name = postChargesRequestBodyShipping'Name,
      postChargesRequestBodyShipping'Phone = GHC.Maybe.Nothing,
      postChargesRequestBodyShipping'TrackingNumber = GHC.Maybe.Nothing
    }

-- | Defines the object schema located at @paths.\/v1\/charges.POST.requestBody.content.application\/x-www-form-urlencoded.schema.properties.shipping.properties.address@ in the specification.
data PostChargesRequestBodyShipping'Address' = PostChargesRequestBodyShipping'Address'
  { -- | city
    --
    -- Constraints:
    --
    -- * Maximum length of 5000
    postChargesRequestBodyShipping'Address'City :: (GHC.Maybe.Maybe Data.Text.Internal.Text),
    -- | country
    --
    -- Constraints:
    --
    -- * Maximum length of 5000
    postChargesRequestBodyShipping'Address'Country :: (GHC.Maybe.Maybe Data.Text.Internal.Text),
    -- | line1
    --
    -- Constraints:
    --
    -- * Maximum length of 5000
    postChargesRequestBodyShipping'Address'Line1 :: Data.Text.Internal.Text,
    -- | line2
    --
    -- Constraints:
    --
    -- * Maximum length of 5000
    postChargesRequestBodyShipping'Address'Line2 :: (GHC.Maybe.Maybe Data.Text.Internal.Text),
    -- | postal_code
    --
    -- Constraints:
    --
    -- * Maximum length of 5000
    postChargesRequestBodyShipping'Address'PostalCode :: (GHC.Maybe.Maybe Data.Text.Internal.Text),
    -- | state
    --
    -- Constraints:
    --
    -- * Maximum length of 5000
    postChargesRequestBodyShipping'Address'State :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  }
  deriving
    ( GHC.Show.Show,
      GHC.Classes.Eq
    )

instance Data.Aeson.Types.ToJSON.ToJSON PostChargesRequestBodyShipping'Address' where
  toJSON obj = Data.Aeson.Types.Internal.object ("city" Data.Aeson.Types.ToJSON..= postChargesRequestBodyShipping'Address'City obj : "country" Data.Aeson.Types.ToJSON..= postChargesRequestBodyShipping'Address'Country obj : "line1" Data.Aeson.Types.ToJSON..= postChargesRequestBodyShipping'Address'Line1 obj : "line2" Data.Aeson.Types.ToJSON..= postChargesRequestBodyShipping'Address'Line2 obj : "postal_code" Data.Aeson.Types.ToJSON..= postChargesRequestBodyShipping'Address'PostalCode obj : "state" Data.Aeson.Types.ToJSON..= postChargesRequestBodyShipping'Address'State obj : GHC.Base.mempty)
  toEncoding obj = Data.Aeson.Encoding.Internal.pairs (("city" Data.Aeson.Types.ToJSON..= postChargesRequestBodyShipping'Address'City obj) GHC.Base.<> (("country" Data.Aeson.Types.ToJSON..= postChargesRequestBodyShipping'Address'Country obj) GHC.Base.<> (("line1" Data.Aeson.Types.ToJSON..= postChargesRequestBodyShipping'Address'Line1 obj) GHC.Base.<> (("line2" Data.Aeson.Types.ToJSON..= postChargesRequestBodyShipping'Address'Line2 obj) GHC.Base.<> (("postal_code" Data.Aeson.Types.ToJSON..= postChargesRequestBodyShipping'Address'PostalCode obj) GHC.Base.<> ("state" Data.Aeson.Types.ToJSON..= postChargesRequestBodyShipping'Address'State obj))))))

instance Data.Aeson.Types.FromJSON.FromJSON PostChargesRequestBodyShipping'Address' where
  parseJSON = Data.Aeson.Types.FromJSON.withObject "PostChargesRequestBodyShipping'Address'" (\obj -> (((((GHC.Base.pure PostChargesRequestBodyShipping'Address' GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "city")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "country")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "line1")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "line2")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "postal_code")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "state"))

-- | Create a new 'PostChargesRequestBodyShipping'Address'' with all required fields.
mkPostChargesRequestBodyShipping'Address' ::
  -- | 'postChargesRequestBodyShipping'Address'Line1'
  Data.Text.Internal.Text ->
  PostChargesRequestBodyShipping'Address'
mkPostChargesRequestBodyShipping'Address' postChargesRequestBodyShipping'Address'Line1 =
  PostChargesRequestBodyShipping'Address'
    { postChargesRequestBodyShipping'Address'City = GHC.Maybe.Nothing,
      postChargesRequestBodyShipping'Address'Country = GHC.Maybe.Nothing,
      postChargesRequestBodyShipping'Address'Line1 = postChargesRequestBodyShipping'Address'Line1,
      postChargesRequestBodyShipping'Address'Line2 = GHC.Maybe.Nothing,
      postChargesRequestBodyShipping'Address'PostalCode = GHC.Maybe.Nothing,
      postChargesRequestBodyShipping'Address'State = GHC.Maybe.Nothing
    }

-- | Defines the object schema located at @paths.\/v1\/charges.POST.requestBody.content.application\/x-www-form-urlencoded.schema.properties.transfer_data@ in the specification.
--
-- An optional dictionary including the account to automatically transfer to as part of a destination charge. [See the Connect documentation](https:\/\/stripe.com\/docs\/connect\/destination-charges) for details.
data PostChargesRequestBodyTransferData' = PostChargesRequestBodyTransferData'
  { -- | amount
    postChargesRequestBodyTransferData'Amount :: (GHC.Maybe.Maybe GHC.Types.Int),
    -- | destination
    --
    -- Constraints:
    --
    -- * Maximum length of 5000
    postChargesRequestBodyTransferData'Destination :: Data.Text.Internal.Text
  }
  deriving
    ( GHC.Show.Show,
      GHC.Classes.Eq
    )

instance Data.Aeson.Types.ToJSON.ToJSON PostChargesRequestBodyTransferData' where
  toJSON obj = Data.Aeson.Types.Internal.object ("amount" Data.Aeson.Types.ToJSON..= postChargesRequestBodyTransferData'Amount obj : "destination" Data.Aeson.Types.ToJSON..= postChargesRequestBodyTransferData'Destination obj : GHC.Base.mempty)
  toEncoding obj = Data.Aeson.Encoding.Internal.pairs (("amount" Data.Aeson.Types.ToJSON..= postChargesRequestBodyTransferData'Amount obj) GHC.Base.<> ("destination" Data.Aeson.Types.ToJSON..= postChargesRequestBodyTransferData'Destination obj))

instance Data.Aeson.Types.FromJSON.FromJSON PostChargesRequestBodyTransferData' where
  parseJSON = Data.Aeson.Types.FromJSON.withObject "PostChargesRequestBodyTransferData'" (\obj -> (GHC.Base.pure PostChargesRequestBodyTransferData' GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "amount")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "destination"))

-- | Create a new 'PostChargesRequestBodyTransferData'' with all required fields.
mkPostChargesRequestBodyTransferData' ::
  -- | 'postChargesRequestBodyTransferData'Destination'
  Data.Text.Internal.Text ->
  PostChargesRequestBodyTransferData'
mkPostChargesRequestBodyTransferData' postChargesRequestBodyTransferData'Destination =
  PostChargesRequestBodyTransferData'
    { postChargesRequestBodyTransferData'Amount = GHC.Maybe.Nothing,
      postChargesRequestBodyTransferData'Destination = postChargesRequestBodyTransferData'Destination
    }

-- | Represents a response of the operation 'postCharges'.
--
-- The response constructor is chosen by the status code of the response. If no case matches (no specific case for the response code, no range case, no default case), 'PostChargesResponseError' is used.
data PostChargesResponse
  = -- | Means either no matching case available or a parse error
    PostChargesResponseError GHC.Base.String
  | -- | Successful response.
    PostChargesResponse200 Charge
  | -- | Error response.
    PostChargesResponseDefault Error
  deriving (GHC.Show.Show, GHC.Classes.Eq)
