{-# LANGUAGE ExplicitForAll #-}
{-# LANGUAGE MultiWayIf #-}
-- CHANGE WITH CAUTION: This is a generated code file generated by https://github.com/Haskell-OpenAPI-Code-Generator/Haskell-OpenAPI-Client-Code-Generator.
{-# LANGUAGE OverloadedStrings #-}

-- | Contains the different functions to run the operation postPrices
module StripeAPI.Operations.PostPrices where

import qualified Control.Monad.Fail
import qualified Control.Monad.Trans.Reader
import qualified Data.Aeson
import qualified Data.Aeson as Data.Aeson.Encoding.Internal
import qualified Data.Aeson as Data.Aeson.Types
import qualified Data.Aeson as Data.Aeson.Types.FromJSON
import qualified Data.Aeson as Data.Aeson.Types.Internal
import qualified Data.Aeson as Data.Aeson.Types.ToJSON
import qualified Data.ByteString.Char8
import qualified Data.ByteString.Char8 as Data.ByteString.Internal
import qualified Data.Either
import qualified Data.Foldable
import qualified Data.Functor
import qualified Data.Maybe
import qualified Data.Scientific
import qualified Data.Text
import qualified Data.Text.Internal
import qualified Data.Time.Calendar as Data.Time.Calendar.Days
import qualified Data.Time.LocalTime as Data.Time.LocalTime.Internal.ZonedTime
import qualified Data.Vector
import qualified GHC.Base
import qualified GHC.Classes
import qualified GHC.Int
import qualified GHC.Show
import qualified GHC.Types
import qualified Network.HTTP.Client
import qualified Network.HTTP.Client as Network.HTTP.Client.Request
import qualified Network.HTTP.Client as Network.HTTP.Client.Types
import qualified Network.HTTP.Simple
import qualified Network.HTTP.Types
import qualified Network.HTTP.Types as Network.HTTP.Types.Status
import qualified Network.HTTP.Types as Network.HTTP.Types.URI
import qualified StripeAPI.Common
import StripeAPI.Types
import qualified Prelude as GHC.Integer.Type
import qualified Prelude as GHC.Maybe

-- | > POST /v1/prices
--
-- \<p>Creates a new price for an existing product. The price can be recurring or one-time.\<\/p>
postPrices ::
  forall m.
  StripeAPI.Common.MonadHTTP m =>
  -- | The request body to send
  PostPricesRequestBody ->
  -- | Monadic computation which returns the result of the operation
  StripeAPI.Common.ClientT m (Network.HTTP.Client.Types.Response PostPricesResponse)
postPrices body =
  GHC.Base.fmap
    ( \response_0 ->
        GHC.Base.fmap
          ( Data.Either.either PostPricesResponseError GHC.Base.id
              GHC.Base.. ( \response body ->
                             if
                                 | (\status_1 -> Network.HTTP.Types.Status.statusCode status_1 GHC.Classes.== 200) (Network.HTTP.Client.Types.responseStatus response) ->
                                   PostPricesResponse200
                                     Data.Functor.<$> ( Data.Aeson.eitherDecodeStrict body ::
                                                          Data.Either.Either
                                                            GHC.Base.String
                                                            Price
                                                      )
                                 | GHC.Base.const GHC.Types.True (Network.HTTP.Client.Types.responseStatus response) ->
                                   PostPricesResponseDefault
                                     Data.Functor.<$> ( Data.Aeson.eitherDecodeStrict body ::
                                                          Data.Either.Either
                                                            GHC.Base.String
                                                            Error
                                                      )
                                 | GHC.Base.otherwise -> Data.Either.Left "Missing default response type"
                         )
                response_0
          )
          response_0
    )
    (StripeAPI.Common.doBodyCallWithConfigurationM (Data.Text.toUpper GHC.Base.$ Data.Text.pack "POST") (Data.Text.pack "/v1/prices") GHC.Base.mempty (GHC.Maybe.Just body) StripeAPI.Common.RequestBodyEncodingFormData)

-- | Defines the object schema located at @paths.\/v1\/prices.POST.requestBody.content.application\/x-www-form-urlencoded.schema@ in the specification.
data PostPricesRequestBody = PostPricesRequestBody
  { -- | active: Whether the price can be used for new purchases. Defaults to \`true\`.
    postPricesRequestBodyActive :: (GHC.Maybe.Maybe GHC.Types.Bool),
    -- | billing_scheme: Describes how to compute the price per period. Either \`per_unit\` or \`tiered\`. \`per_unit\` indicates that the fixed amount (specified in \`unit_amount\` or \`unit_amount_decimal\`) will be charged per unit in \`quantity\` (for prices with \`usage_type=licensed\`), or per unit of total usage (for prices with \`usage_type=metered\`). \`tiered\` indicates that the unit pricing will be computed using a tiering strategy as defined using the \`tiers\` and \`tiers_mode\` attributes.
    postPricesRequestBodyBillingScheme :: (GHC.Maybe.Maybe PostPricesRequestBodyBillingScheme'),
    -- | currency: Three-letter [ISO currency code](https:\/\/www.iso.org\/iso-4217-currency-codes.html), in lowercase. Must be a [supported currency](https:\/\/stripe.com\/docs\/currencies).
    postPricesRequestBodyCurrency :: Data.Text.Internal.Text,
    -- | custom_unit_amount: When set, provides configuration for the amount to be adjusted by the customer during Checkout Sessions and Payment Links.
    postPricesRequestBodyCustomUnitAmount :: (GHC.Maybe.Maybe PostPricesRequestBodyCustomUnitAmount'),
    -- | expand: Specifies which fields in the response should be expanded.
    postPricesRequestBodyExpand :: (GHC.Maybe.Maybe ([Data.Text.Internal.Text])),
    -- | lookup_key: A lookup key used to retrieve prices dynamically from a static string. This may be up to 200 characters.
    --
    -- Constraints:
    --
    -- * Maximum length of 200
    postPricesRequestBodyLookupKey :: (GHC.Maybe.Maybe Data.Text.Internal.Text),
    -- | metadata: Set of [key-value pairs](https:\/\/stripe.com\/docs\/api\/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to \`metadata\`.
    postPricesRequestBodyMetadata :: (GHC.Maybe.Maybe Data.Aeson.Types.Internal.Object),
    -- | nickname: A brief description of the price, hidden from customers.
    --
    -- Constraints:
    --
    -- * Maximum length of 5000
    postPricesRequestBodyNickname :: (GHC.Maybe.Maybe Data.Text.Internal.Text),
    -- | product: The ID of the product that this price will belong to.
    --
    -- Constraints:
    --
    -- * Maximum length of 5000
    postPricesRequestBodyProduct :: (GHC.Maybe.Maybe Data.Text.Internal.Text),
    -- | product_data: These fields can be used to create a new product that this price will belong to.
    postPricesRequestBodyProductData :: (GHC.Maybe.Maybe PostPricesRequestBodyProductData'),
    -- | recurring: The recurring components of a price such as \`interval\` and \`usage_type\`.
    postPricesRequestBodyRecurring :: (GHC.Maybe.Maybe PostPricesRequestBodyRecurring'),
    -- | tax_behavior: Specifies whether the price is considered inclusive of taxes or exclusive of taxes. One of \`inclusive\`, \`exclusive\`, or \`unspecified\`. Once specified as either \`inclusive\` or \`exclusive\`, it cannot be changed.
    postPricesRequestBodyTaxBehavior :: (GHC.Maybe.Maybe PostPricesRequestBodyTaxBehavior'),
    -- | tiers: Each element represents a pricing tier. This parameter requires \`billing_scheme\` to be set to \`tiered\`. See also the documentation for \`billing_scheme\`.
    postPricesRequestBodyTiers :: (GHC.Maybe.Maybe ([PostPricesRequestBodyTiers'])),
    -- | tiers_mode: Defines if the tiering price should be \`graduated\` or \`volume\` based. In \`volume\`-based tiering, the maximum quantity within a period determines the per unit price, in \`graduated\` tiering pricing can successively change as the quantity grows.
    postPricesRequestBodyTiersMode :: (GHC.Maybe.Maybe PostPricesRequestBodyTiersMode'),
    -- | transfer_lookup_key: If set to true, will atomically remove the lookup key from the existing price, and assign it to this price.
    postPricesRequestBodyTransferLookupKey :: (GHC.Maybe.Maybe GHC.Types.Bool),
    -- | transform_quantity: Apply a transformation to the reported usage or set quantity before computing the billed price. Cannot be combined with \`tiers\`.
    postPricesRequestBodyTransformQuantity :: (GHC.Maybe.Maybe PostPricesRequestBodyTransformQuantity'),
    -- | unit_amount: A positive integer in cents (or local equivalent) (or 0 for a free price) representing how much to charge.
    postPricesRequestBodyUnitAmount :: (GHC.Maybe.Maybe GHC.Types.Int),
    -- | unit_amount_decimal: Same as \`unit_amount\`, but accepts a decimal value in cents (or local equivalent) with at most 12 decimal places. Only one of \`unit_amount\` and \`unit_amount_decimal\` can be set.
    postPricesRequestBodyUnitAmountDecimal :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  }
  deriving
    ( GHC.Show.Show,
      GHC.Classes.Eq
    )

instance Data.Aeson.Types.ToJSON.ToJSON PostPricesRequestBody where
  toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("active" Data.Aeson.Types.ToJSON..=)) (postPricesRequestBodyActive obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("billing_scheme" Data.Aeson.Types.ToJSON..=)) (postPricesRequestBodyBillingScheme obj) : ["currency" Data.Aeson.Types.ToJSON..= postPricesRequestBodyCurrency obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("custom_unit_amount" Data.Aeson.Types.ToJSON..=)) (postPricesRequestBodyCustomUnitAmount obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("expand" Data.Aeson.Types.ToJSON..=)) (postPricesRequestBodyExpand obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("lookup_key" Data.Aeson.Types.ToJSON..=)) (postPricesRequestBodyLookupKey obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("metadata" Data.Aeson.Types.ToJSON..=)) (postPricesRequestBodyMetadata obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("nickname" Data.Aeson.Types.ToJSON..=)) (postPricesRequestBodyNickname obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("product" Data.Aeson.Types.ToJSON..=)) (postPricesRequestBodyProduct obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("product_data" Data.Aeson.Types.ToJSON..=)) (postPricesRequestBodyProductData obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("recurring" Data.Aeson.Types.ToJSON..=)) (postPricesRequestBodyRecurring obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("tax_behavior" Data.Aeson.Types.ToJSON..=)) (postPricesRequestBodyTaxBehavior obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("tiers" Data.Aeson.Types.ToJSON..=)) (postPricesRequestBodyTiers obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("tiers_mode" Data.Aeson.Types.ToJSON..=)) (postPricesRequestBodyTiersMode obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("transfer_lookup_key" Data.Aeson.Types.ToJSON..=)) (postPricesRequestBodyTransferLookupKey obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("transform_quantity" Data.Aeson.Types.ToJSON..=)) (postPricesRequestBodyTransformQuantity obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("unit_amount" Data.Aeson.Types.ToJSON..=)) (postPricesRequestBodyUnitAmount obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("unit_amount_decimal" Data.Aeson.Types.ToJSON..=)) (postPricesRequestBodyUnitAmountDecimal obj) : GHC.Base.mempty))
  toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("active" Data.Aeson.Types.ToJSON..=)) (postPricesRequestBodyActive obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("billing_scheme" Data.Aeson.Types.ToJSON..=)) (postPricesRequestBodyBillingScheme obj) : ["currency" Data.Aeson.Types.ToJSON..= postPricesRequestBodyCurrency obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("custom_unit_amount" Data.Aeson.Types.ToJSON..=)) (postPricesRequestBodyCustomUnitAmount obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("expand" Data.Aeson.Types.ToJSON..=)) (postPricesRequestBodyExpand obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("lookup_key" Data.Aeson.Types.ToJSON..=)) (postPricesRequestBodyLookupKey obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("metadata" Data.Aeson.Types.ToJSON..=)) (postPricesRequestBodyMetadata obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("nickname" Data.Aeson.Types.ToJSON..=)) (postPricesRequestBodyNickname obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("product" Data.Aeson.Types.ToJSON..=)) (postPricesRequestBodyProduct obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("product_data" Data.Aeson.Types.ToJSON..=)) (postPricesRequestBodyProductData obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("recurring" Data.Aeson.Types.ToJSON..=)) (postPricesRequestBodyRecurring obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("tax_behavior" Data.Aeson.Types.ToJSON..=)) (postPricesRequestBodyTaxBehavior obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("tiers" Data.Aeson.Types.ToJSON..=)) (postPricesRequestBodyTiers obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("tiers_mode" Data.Aeson.Types.ToJSON..=)) (postPricesRequestBodyTiersMode obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("transfer_lookup_key" Data.Aeson.Types.ToJSON..=)) (postPricesRequestBodyTransferLookupKey obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("transform_quantity" Data.Aeson.Types.ToJSON..=)) (postPricesRequestBodyTransformQuantity obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("unit_amount" Data.Aeson.Types.ToJSON..=)) (postPricesRequestBodyUnitAmount obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("unit_amount_decimal" Data.Aeson.Types.ToJSON..=)) (postPricesRequestBodyUnitAmountDecimal obj) : GHC.Base.mempty)))

instance Data.Aeson.Types.FromJSON.FromJSON PostPricesRequestBody where
  parseJSON = Data.Aeson.Types.FromJSON.withObject "PostPricesRequestBody" (\obj -> (((((((((((((((((GHC.Base.pure PostPricesRequestBody GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "active")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "billing_scheme")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "currency")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "custom_unit_amount")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "expand")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "lookup_key")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "metadata")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "nickname")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "product")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "product_data")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "recurring")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "tax_behavior")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "tiers")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "tiers_mode")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "transfer_lookup_key")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "transform_quantity")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "unit_amount")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "unit_amount_decimal"))

-- | Create a new 'PostPricesRequestBody' with all required fields.
mkPostPricesRequestBody ::
  -- | 'postPricesRequestBodyCurrency'
  Data.Text.Internal.Text ->
  PostPricesRequestBody
mkPostPricesRequestBody postPricesRequestBodyCurrency =
  PostPricesRequestBody
    { postPricesRequestBodyActive = GHC.Maybe.Nothing,
      postPricesRequestBodyBillingScheme = GHC.Maybe.Nothing,
      postPricesRequestBodyCurrency = postPricesRequestBodyCurrency,
      postPricesRequestBodyCustomUnitAmount = GHC.Maybe.Nothing,
      postPricesRequestBodyExpand = GHC.Maybe.Nothing,
      postPricesRequestBodyLookupKey = GHC.Maybe.Nothing,
      postPricesRequestBodyMetadata = GHC.Maybe.Nothing,
      postPricesRequestBodyNickname = GHC.Maybe.Nothing,
      postPricesRequestBodyProduct = GHC.Maybe.Nothing,
      postPricesRequestBodyProductData = GHC.Maybe.Nothing,
      postPricesRequestBodyRecurring = GHC.Maybe.Nothing,
      postPricesRequestBodyTaxBehavior = GHC.Maybe.Nothing,
      postPricesRequestBodyTiers = GHC.Maybe.Nothing,
      postPricesRequestBodyTiersMode = GHC.Maybe.Nothing,
      postPricesRequestBodyTransferLookupKey = GHC.Maybe.Nothing,
      postPricesRequestBodyTransformQuantity = GHC.Maybe.Nothing,
      postPricesRequestBodyUnitAmount = GHC.Maybe.Nothing,
      postPricesRequestBodyUnitAmountDecimal = GHC.Maybe.Nothing
    }

-- | Defines the enum schema located at @paths.\/v1\/prices.POST.requestBody.content.application\/x-www-form-urlencoded.schema.properties.billing_scheme@ in the specification.
--
-- Describes how to compute the price per period. Either \`per_unit\` or \`tiered\`. \`per_unit\` indicates that the fixed amount (specified in \`unit_amount\` or \`unit_amount_decimal\`) will be charged per unit in \`quantity\` (for prices with \`usage_type=licensed\`), or per unit of total usage (for prices with \`usage_type=metered\`). \`tiered\` indicates that the unit pricing will be computed using a tiering strategy as defined using the \`tiers\` and \`tiers_mode\` attributes.
data PostPricesRequestBodyBillingScheme'
  = -- | This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
    PostPricesRequestBodyBillingScheme'Other Data.Aeson.Types.Internal.Value
  | -- | This constructor can be used to send values to the server which are not present in the specification yet.
    PostPricesRequestBodyBillingScheme'Typed Data.Text.Internal.Text
  | -- | Represents the JSON value @"per_unit"@
    PostPricesRequestBodyBillingScheme'EnumPerUnit
  | -- | Represents the JSON value @"tiered"@
    PostPricesRequestBodyBillingScheme'EnumTiered
  deriving (GHC.Show.Show, GHC.Classes.Eq)

instance Data.Aeson.Types.ToJSON.ToJSON PostPricesRequestBodyBillingScheme' where
  toJSON (PostPricesRequestBodyBillingScheme'Other val) = val
  toJSON (PostPricesRequestBodyBillingScheme'Typed val) = Data.Aeson.Types.ToJSON.toJSON val
  toJSON (PostPricesRequestBodyBillingScheme'EnumPerUnit) = "per_unit"
  toJSON (PostPricesRequestBodyBillingScheme'EnumTiered) = "tiered"

instance Data.Aeson.Types.FromJSON.FromJSON PostPricesRequestBodyBillingScheme' where
  parseJSON val =
    GHC.Base.pure
      ( if
            | val GHC.Classes.== "per_unit" -> PostPricesRequestBodyBillingScheme'EnumPerUnit
            | val GHC.Classes.== "tiered" -> PostPricesRequestBodyBillingScheme'EnumTiered
            | GHC.Base.otherwise -> PostPricesRequestBodyBillingScheme'Other val
      )

-- | Defines the object schema located at @paths.\/v1\/prices.POST.requestBody.content.application\/x-www-form-urlencoded.schema.properties.custom_unit_amount@ in the specification.
--
-- When set, provides configuration for the amount to be adjusted by the customer during Checkout Sessions and Payment Links.
data PostPricesRequestBodyCustomUnitAmount' = PostPricesRequestBodyCustomUnitAmount'
  { -- | enabled
    postPricesRequestBodyCustomUnitAmount'Enabled :: GHC.Types.Bool,
    -- | maximum
    postPricesRequestBodyCustomUnitAmount'Maximum :: (GHC.Maybe.Maybe GHC.Types.Int),
    -- | minimum
    postPricesRequestBodyCustomUnitAmount'Minimum :: (GHC.Maybe.Maybe GHC.Types.Int),
    -- | preset
    postPricesRequestBodyCustomUnitAmount'Preset :: (GHC.Maybe.Maybe GHC.Types.Int)
  }
  deriving
    ( GHC.Show.Show,
      GHC.Classes.Eq
    )

instance Data.Aeson.Types.ToJSON.ToJSON PostPricesRequestBodyCustomUnitAmount' where
  toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["enabled" Data.Aeson.Types.ToJSON..= postPricesRequestBodyCustomUnitAmount'Enabled obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("maximum" Data.Aeson.Types.ToJSON..=)) (postPricesRequestBodyCustomUnitAmount'Maximum obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("minimum" Data.Aeson.Types.ToJSON..=)) (postPricesRequestBodyCustomUnitAmount'Minimum obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("preset" Data.Aeson.Types.ToJSON..=)) (postPricesRequestBodyCustomUnitAmount'Preset obj) : GHC.Base.mempty))
  toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["enabled" Data.Aeson.Types.ToJSON..= postPricesRequestBodyCustomUnitAmount'Enabled obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("maximum" Data.Aeson.Types.ToJSON..=)) (postPricesRequestBodyCustomUnitAmount'Maximum obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("minimum" Data.Aeson.Types.ToJSON..=)) (postPricesRequestBodyCustomUnitAmount'Minimum obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("preset" Data.Aeson.Types.ToJSON..=)) (postPricesRequestBodyCustomUnitAmount'Preset obj) : GHC.Base.mempty)))

instance Data.Aeson.Types.FromJSON.FromJSON PostPricesRequestBodyCustomUnitAmount' where
  parseJSON = Data.Aeson.Types.FromJSON.withObject "PostPricesRequestBodyCustomUnitAmount'" (\obj -> (((GHC.Base.pure PostPricesRequestBodyCustomUnitAmount' GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "enabled")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "maximum")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "minimum")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "preset"))

-- | Create a new 'PostPricesRequestBodyCustomUnitAmount'' with all required fields.
mkPostPricesRequestBodyCustomUnitAmount' ::
  -- | 'postPricesRequestBodyCustomUnitAmount'Enabled'
  GHC.Types.Bool ->
  PostPricesRequestBodyCustomUnitAmount'
mkPostPricesRequestBodyCustomUnitAmount' postPricesRequestBodyCustomUnitAmount'Enabled =
  PostPricesRequestBodyCustomUnitAmount'
    { postPricesRequestBodyCustomUnitAmount'Enabled = postPricesRequestBodyCustomUnitAmount'Enabled,
      postPricesRequestBodyCustomUnitAmount'Maximum = GHC.Maybe.Nothing,
      postPricesRequestBodyCustomUnitAmount'Minimum = GHC.Maybe.Nothing,
      postPricesRequestBodyCustomUnitAmount'Preset = GHC.Maybe.Nothing
    }

-- | Defines the object schema located at @paths.\/v1\/prices.POST.requestBody.content.application\/x-www-form-urlencoded.schema.properties.product_data@ in the specification.
--
-- These fields can be used to create a new product that this price will belong to.
data PostPricesRequestBodyProductData' = PostPricesRequestBodyProductData'
  { -- | active
    postPricesRequestBodyProductData'Active :: (GHC.Maybe.Maybe GHC.Types.Bool),
    -- | id
    --
    -- Constraints:
    --
    -- * Maximum length of 5000
    postPricesRequestBodyProductData'Id :: (GHC.Maybe.Maybe Data.Text.Internal.Text),
    -- | metadata
    postPricesRequestBodyProductData'Metadata :: (GHC.Maybe.Maybe Data.Aeson.Types.Internal.Object),
    -- | name
    --
    -- Constraints:
    --
    -- * Maximum length of 5000
    postPricesRequestBodyProductData'Name :: Data.Text.Internal.Text,
    -- | statement_descriptor
    --
    -- Constraints:
    --
    -- * Maximum length of 22
    postPricesRequestBodyProductData'StatementDescriptor :: (GHC.Maybe.Maybe Data.Text.Internal.Text),
    -- | tax_code
    --
    -- Constraints:
    --
    -- * Maximum length of 5000
    postPricesRequestBodyProductData'TaxCode :: (GHC.Maybe.Maybe Data.Text.Internal.Text),
    -- | unit_label
    --
    -- Constraints:
    --
    -- * Maximum length of 12
    postPricesRequestBodyProductData'UnitLabel :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  }
  deriving
    ( GHC.Show.Show,
      GHC.Classes.Eq
    )

instance Data.Aeson.Types.ToJSON.ToJSON PostPricesRequestBodyProductData' where
  toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("active" Data.Aeson.Types.ToJSON..=)) (postPricesRequestBodyProductData'Active obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("id" Data.Aeson.Types.ToJSON..=)) (postPricesRequestBodyProductData'Id obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("metadata" Data.Aeson.Types.ToJSON..=)) (postPricesRequestBodyProductData'Metadata obj) : ["name" Data.Aeson.Types.ToJSON..= postPricesRequestBodyProductData'Name obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("statement_descriptor" Data.Aeson.Types.ToJSON..=)) (postPricesRequestBodyProductData'StatementDescriptor obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("tax_code" Data.Aeson.Types.ToJSON..=)) (postPricesRequestBodyProductData'TaxCode obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("unit_label" Data.Aeson.Types.ToJSON..=)) (postPricesRequestBodyProductData'UnitLabel obj) : GHC.Base.mempty))
  toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("active" Data.Aeson.Types.ToJSON..=)) (postPricesRequestBodyProductData'Active obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("id" Data.Aeson.Types.ToJSON..=)) (postPricesRequestBodyProductData'Id obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("metadata" Data.Aeson.Types.ToJSON..=)) (postPricesRequestBodyProductData'Metadata obj) : ["name" Data.Aeson.Types.ToJSON..= postPricesRequestBodyProductData'Name obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("statement_descriptor" Data.Aeson.Types.ToJSON..=)) (postPricesRequestBodyProductData'StatementDescriptor obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("tax_code" Data.Aeson.Types.ToJSON..=)) (postPricesRequestBodyProductData'TaxCode obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("unit_label" Data.Aeson.Types.ToJSON..=)) (postPricesRequestBodyProductData'UnitLabel obj) : GHC.Base.mempty)))

instance Data.Aeson.Types.FromJSON.FromJSON PostPricesRequestBodyProductData' where
  parseJSON = Data.Aeson.Types.FromJSON.withObject "PostPricesRequestBodyProductData'" (\obj -> ((((((GHC.Base.pure PostPricesRequestBodyProductData' GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "active")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "metadata")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "name")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "statement_descriptor")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "tax_code")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "unit_label"))

-- | Create a new 'PostPricesRequestBodyProductData'' with all required fields.
mkPostPricesRequestBodyProductData' ::
  -- | 'postPricesRequestBodyProductData'Name'
  Data.Text.Internal.Text ->
  PostPricesRequestBodyProductData'
mkPostPricesRequestBodyProductData' postPricesRequestBodyProductData'Name =
  PostPricesRequestBodyProductData'
    { postPricesRequestBodyProductData'Active = GHC.Maybe.Nothing,
      postPricesRequestBodyProductData'Id = GHC.Maybe.Nothing,
      postPricesRequestBodyProductData'Metadata = GHC.Maybe.Nothing,
      postPricesRequestBodyProductData'Name = postPricesRequestBodyProductData'Name,
      postPricesRequestBodyProductData'StatementDescriptor = GHC.Maybe.Nothing,
      postPricesRequestBodyProductData'TaxCode = GHC.Maybe.Nothing,
      postPricesRequestBodyProductData'UnitLabel = GHC.Maybe.Nothing
    }

-- | Defines the object schema located at @paths.\/v1\/prices.POST.requestBody.content.application\/x-www-form-urlencoded.schema.properties.recurring@ in the specification.
--
-- The recurring components of a price such as \`interval\` and \`usage_type\`.
data PostPricesRequestBodyRecurring' = PostPricesRequestBodyRecurring'
  { -- | aggregate_usage
    postPricesRequestBodyRecurring'AggregateUsage :: (GHC.Maybe.Maybe PostPricesRequestBodyRecurring'AggregateUsage'),
    -- | interval
    postPricesRequestBodyRecurring'Interval :: PostPricesRequestBodyRecurring'Interval',
    -- | interval_count
    postPricesRequestBodyRecurring'IntervalCount :: (GHC.Maybe.Maybe GHC.Types.Int),
    -- | usage_type
    postPricesRequestBodyRecurring'UsageType :: (GHC.Maybe.Maybe PostPricesRequestBodyRecurring'UsageType')
  }
  deriving
    ( GHC.Show.Show,
      GHC.Classes.Eq
    )

instance Data.Aeson.Types.ToJSON.ToJSON PostPricesRequestBodyRecurring' where
  toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("aggregate_usage" Data.Aeson.Types.ToJSON..=)) (postPricesRequestBodyRecurring'AggregateUsage obj) : ["interval" Data.Aeson.Types.ToJSON..= postPricesRequestBodyRecurring'Interval obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("interval_count" Data.Aeson.Types.ToJSON..=)) (postPricesRequestBodyRecurring'IntervalCount obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("usage_type" Data.Aeson.Types.ToJSON..=)) (postPricesRequestBodyRecurring'UsageType obj) : GHC.Base.mempty))
  toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("aggregate_usage" Data.Aeson.Types.ToJSON..=)) (postPricesRequestBodyRecurring'AggregateUsage obj) : ["interval" Data.Aeson.Types.ToJSON..= postPricesRequestBodyRecurring'Interval obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("interval_count" Data.Aeson.Types.ToJSON..=)) (postPricesRequestBodyRecurring'IntervalCount obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("usage_type" Data.Aeson.Types.ToJSON..=)) (postPricesRequestBodyRecurring'UsageType obj) : GHC.Base.mempty)))

instance Data.Aeson.Types.FromJSON.FromJSON PostPricesRequestBodyRecurring' where
  parseJSON = Data.Aeson.Types.FromJSON.withObject "PostPricesRequestBodyRecurring'" (\obj -> (((GHC.Base.pure PostPricesRequestBodyRecurring' GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "aggregate_usage")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "interval")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "interval_count")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "usage_type"))

-- | Create a new 'PostPricesRequestBodyRecurring'' with all required fields.
mkPostPricesRequestBodyRecurring' ::
  -- | 'postPricesRequestBodyRecurring'Interval'
  PostPricesRequestBodyRecurring'Interval' ->
  PostPricesRequestBodyRecurring'
mkPostPricesRequestBodyRecurring' postPricesRequestBodyRecurring'Interval =
  PostPricesRequestBodyRecurring'
    { postPricesRequestBodyRecurring'AggregateUsage = GHC.Maybe.Nothing,
      postPricesRequestBodyRecurring'Interval = postPricesRequestBodyRecurring'Interval,
      postPricesRequestBodyRecurring'IntervalCount = GHC.Maybe.Nothing,
      postPricesRequestBodyRecurring'UsageType = GHC.Maybe.Nothing
    }

-- | Defines the enum schema located at @paths.\/v1\/prices.POST.requestBody.content.application\/x-www-form-urlencoded.schema.properties.recurring.properties.aggregate_usage@ in the specification.
data PostPricesRequestBodyRecurring'AggregateUsage'
  = -- | This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
    PostPricesRequestBodyRecurring'AggregateUsage'Other Data.Aeson.Types.Internal.Value
  | -- | This constructor can be used to send values to the server which are not present in the specification yet.
    PostPricesRequestBodyRecurring'AggregateUsage'Typed Data.Text.Internal.Text
  | -- | Represents the JSON value @"last_during_period"@
    PostPricesRequestBodyRecurring'AggregateUsage'EnumLastDuringPeriod
  | -- | Represents the JSON value @"last_ever"@
    PostPricesRequestBodyRecurring'AggregateUsage'EnumLastEver
  | -- | Represents the JSON value @"max"@
    PostPricesRequestBodyRecurring'AggregateUsage'EnumMax
  | -- | Represents the JSON value @"sum"@
    PostPricesRequestBodyRecurring'AggregateUsage'EnumSum
  deriving (GHC.Show.Show, GHC.Classes.Eq)

instance Data.Aeson.Types.ToJSON.ToJSON PostPricesRequestBodyRecurring'AggregateUsage' where
  toJSON (PostPricesRequestBodyRecurring'AggregateUsage'Other val) = val
  toJSON (PostPricesRequestBodyRecurring'AggregateUsage'Typed val) = Data.Aeson.Types.ToJSON.toJSON val
  toJSON (PostPricesRequestBodyRecurring'AggregateUsage'EnumLastDuringPeriod) = "last_during_period"
  toJSON (PostPricesRequestBodyRecurring'AggregateUsage'EnumLastEver) = "last_ever"
  toJSON (PostPricesRequestBodyRecurring'AggregateUsage'EnumMax) = "max"
  toJSON (PostPricesRequestBodyRecurring'AggregateUsage'EnumSum) = "sum"

instance Data.Aeson.Types.FromJSON.FromJSON PostPricesRequestBodyRecurring'AggregateUsage' where
  parseJSON val =
    GHC.Base.pure
      ( if
            | val GHC.Classes.== "last_during_period" -> PostPricesRequestBodyRecurring'AggregateUsage'EnumLastDuringPeriod
            | val GHC.Classes.== "last_ever" -> PostPricesRequestBodyRecurring'AggregateUsage'EnumLastEver
            | val GHC.Classes.== "max" -> PostPricesRequestBodyRecurring'AggregateUsage'EnumMax
            | val GHC.Classes.== "sum" -> PostPricesRequestBodyRecurring'AggregateUsage'EnumSum
            | GHC.Base.otherwise -> PostPricesRequestBodyRecurring'AggregateUsage'Other val
      )

-- | Defines the enum schema located at @paths.\/v1\/prices.POST.requestBody.content.application\/x-www-form-urlencoded.schema.properties.recurring.properties.interval@ in the specification.
data PostPricesRequestBodyRecurring'Interval'
  = -- | This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
    PostPricesRequestBodyRecurring'Interval'Other Data.Aeson.Types.Internal.Value
  | -- | This constructor can be used to send values to the server which are not present in the specification yet.
    PostPricesRequestBodyRecurring'Interval'Typed Data.Text.Internal.Text
  | -- | Represents the JSON value @"day"@
    PostPricesRequestBodyRecurring'Interval'EnumDay
  | -- | Represents the JSON value @"month"@
    PostPricesRequestBodyRecurring'Interval'EnumMonth
  | -- | Represents the JSON value @"week"@
    PostPricesRequestBodyRecurring'Interval'EnumWeek
  | -- | Represents the JSON value @"year"@
    PostPricesRequestBodyRecurring'Interval'EnumYear
  deriving (GHC.Show.Show, GHC.Classes.Eq)

instance Data.Aeson.Types.ToJSON.ToJSON PostPricesRequestBodyRecurring'Interval' where
  toJSON (PostPricesRequestBodyRecurring'Interval'Other val) = val
  toJSON (PostPricesRequestBodyRecurring'Interval'Typed val) = Data.Aeson.Types.ToJSON.toJSON val
  toJSON (PostPricesRequestBodyRecurring'Interval'EnumDay) = "day"
  toJSON (PostPricesRequestBodyRecurring'Interval'EnumMonth) = "month"
  toJSON (PostPricesRequestBodyRecurring'Interval'EnumWeek) = "week"
  toJSON (PostPricesRequestBodyRecurring'Interval'EnumYear) = "year"

instance Data.Aeson.Types.FromJSON.FromJSON PostPricesRequestBodyRecurring'Interval' where
  parseJSON val =
    GHC.Base.pure
      ( if
            | val GHC.Classes.== "day" -> PostPricesRequestBodyRecurring'Interval'EnumDay
            | val GHC.Classes.== "month" -> PostPricesRequestBodyRecurring'Interval'EnumMonth
            | val GHC.Classes.== "week" -> PostPricesRequestBodyRecurring'Interval'EnumWeek
            | val GHC.Classes.== "year" -> PostPricesRequestBodyRecurring'Interval'EnumYear
            | GHC.Base.otherwise -> PostPricesRequestBodyRecurring'Interval'Other val
      )

-- | Defines the enum schema located at @paths.\/v1\/prices.POST.requestBody.content.application\/x-www-form-urlencoded.schema.properties.recurring.properties.usage_type@ in the specification.
data PostPricesRequestBodyRecurring'UsageType'
  = -- | This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
    PostPricesRequestBodyRecurring'UsageType'Other Data.Aeson.Types.Internal.Value
  | -- | This constructor can be used to send values to the server which are not present in the specification yet.
    PostPricesRequestBodyRecurring'UsageType'Typed Data.Text.Internal.Text
  | -- | Represents the JSON value @"licensed"@
    PostPricesRequestBodyRecurring'UsageType'EnumLicensed
  | -- | Represents the JSON value @"metered"@
    PostPricesRequestBodyRecurring'UsageType'EnumMetered
  deriving (GHC.Show.Show, GHC.Classes.Eq)

instance Data.Aeson.Types.ToJSON.ToJSON PostPricesRequestBodyRecurring'UsageType' where
  toJSON (PostPricesRequestBodyRecurring'UsageType'Other val) = val
  toJSON (PostPricesRequestBodyRecurring'UsageType'Typed val) = Data.Aeson.Types.ToJSON.toJSON val
  toJSON (PostPricesRequestBodyRecurring'UsageType'EnumLicensed) = "licensed"
  toJSON (PostPricesRequestBodyRecurring'UsageType'EnumMetered) = "metered"

instance Data.Aeson.Types.FromJSON.FromJSON PostPricesRequestBodyRecurring'UsageType' where
  parseJSON val =
    GHC.Base.pure
      ( if
            | val GHC.Classes.== "licensed" -> PostPricesRequestBodyRecurring'UsageType'EnumLicensed
            | val GHC.Classes.== "metered" -> PostPricesRequestBodyRecurring'UsageType'EnumMetered
            | GHC.Base.otherwise -> PostPricesRequestBodyRecurring'UsageType'Other val
      )

-- | Defines the enum schema located at @paths.\/v1\/prices.POST.requestBody.content.application\/x-www-form-urlencoded.schema.properties.tax_behavior@ in the specification.
--
-- Specifies whether the price is considered inclusive of taxes or exclusive of taxes. One of \`inclusive\`, \`exclusive\`, or \`unspecified\`. Once specified as either \`inclusive\` or \`exclusive\`, it cannot be changed.
data PostPricesRequestBodyTaxBehavior'
  = -- | This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
    PostPricesRequestBodyTaxBehavior'Other Data.Aeson.Types.Internal.Value
  | -- | This constructor can be used to send values to the server which are not present in the specification yet.
    PostPricesRequestBodyTaxBehavior'Typed Data.Text.Internal.Text
  | -- | Represents the JSON value @"exclusive"@
    PostPricesRequestBodyTaxBehavior'EnumExclusive
  | -- | Represents the JSON value @"inclusive"@
    PostPricesRequestBodyTaxBehavior'EnumInclusive
  | -- | Represents the JSON value @"unspecified"@
    PostPricesRequestBodyTaxBehavior'EnumUnspecified
  deriving (GHC.Show.Show, GHC.Classes.Eq)

instance Data.Aeson.Types.ToJSON.ToJSON PostPricesRequestBodyTaxBehavior' where
  toJSON (PostPricesRequestBodyTaxBehavior'Other val) = val
  toJSON (PostPricesRequestBodyTaxBehavior'Typed val) = Data.Aeson.Types.ToJSON.toJSON val
  toJSON (PostPricesRequestBodyTaxBehavior'EnumExclusive) = "exclusive"
  toJSON (PostPricesRequestBodyTaxBehavior'EnumInclusive) = "inclusive"
  toJSON (PostPricesRequestBodyTaxBehavior'EnumUnspecified) = "unspecified"

instance Data.Aeson.Types.FromJSON.FromJSON PostPricesRequestBodyTaxBehavior' where
  parseJSON val =
    GHC.Base.pure
      ( if
            | val GHC.Classes.== "exclusive" -> PostPricesRequestBodyTaxBehavior'EnumExclusive
            | val GHC.Classes.== "inclusive" -> PostPricesRequestBodyTaxBehavior'EnumInclusive
            | val GHC.Classes.== "unspecified" -> PostPricesRequestBodyTaxBehavior'EnumUnspecified
            | GHC.Base.otherwise -> PostPricesRequestBodyTaxBehavior'Other val
      )

-- | Defines the object schema located at @paths.\/v1\/prices.POST.requestBody.content.application\/x-www-form-urlencoded.schema.properties.tiers.items@ in the specification.
data PostPricesRequestBodyTiers' = PostPricesRequestBodyTiers'
  { -- | flat_amount
    postPricesRequestBodyTiers'FlatAmount :: (GHC.Maybe.Maybe GHC.Types.Int),
    -- | flat_amount_decimal
    postPricesRequestBodyTiers'FlatAmountDecimal :: (GHC.Maybe.Maybe Data.Text.Internal.Text),
    -- | unit_amount
    postPricesRequestBodyTiers'UnitAmount :: (GHC.Maybe.Maybe GHC.Types.Int),
    -- | unit_amount_decimal
    postPricesRequestBodyTiers'UnitAmountDecimal :: (GHC.Maybe.Maybe Data.Text.Internal.Text),
    -- | up_to
    postPricesRequestBodyTiers'UpTo :: PostPricesRequestBodyTiers'UpTo'Variants
  }
  deriving
    ( GHC.Show.Show,
      GHC.Classes.Eq
    )

instance Data.Aeson.Types.ToJSON.ToJSON PostPricesRequestBodyTiers' where
  toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("flat_amount" Data.Aeson.Types.ToJSON..=)) (postPricesRequestBodyTiers'FlatAmount obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("flat_amount_decimal" Data.Aeson.Types.ToJSON..=)) (postPricesRequestBodyTiers'FlatAmountDecimal obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("unit_amount" Data.Aeson.Types.ToJSON..=)) (postPricesRequestBodyTiers'UnitAmount obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("unit_amount_decimal" Data.Aeson.Types.ToJSON..=)) (postPricesRequestBodyTiers'UnitAmountDecimal obj) : ["up_to" Data.Aeson.Types.ToJSON..= postPricesRequestBodyTiers'UpTo obj] : GHC.Base.mempty))
  toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("flat_amount" Data.Aeson.Types.ToJSON..=)) (postPricesRequestBodyTiers'FlatAmount obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("flat_amount_decimal" Data.Aeson.Types.ToJSON..=)) (postPricesRequestBodyTiers'FlatAmountDecimal obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("unit_amount" Data.Aeson.Types.ToJSON..=)) (postPricesRequestBodyTiers'UnitAmount obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("unit_amount_decimal" Data.Aeson.Types.ToJSON..=)) (postPricesRequestBodyTiers'UnitAmountDecimal obj) : ["up_to" Data.Aeson.Types.ToJSON..= postPricesRequestBodyTiers'UpTo obj] : GHC.Base.mempty)))

instance Data.Aeson.Types.FromJSON.FromJSON PostPricesRequestBodyTiers' where
  parseJSON = Data.Aeson.Types.FromJSON.withObject "PostPricesRequestBodyTiers'" (\obj -> ((((GHC.Base.pure PostPricesRequestBodyTiers' GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "flat_amount")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "flat_amount_decimal")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "unit_amount")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "unit_amount_decimal")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "up_to"))

-- | Create a new 'PostPricesRequestBodyTiers'' with all required fields.
mkPostPricesRequestBodyTiers' ::
  -- | 'postPricesRequestBodyTiers'UpTo'
  PostPricesRequestBodyTiers'UpTo'Variants ->
  PostPricesRequestBodyTiers'
mkPostPricesRequestBodyTiers' postPricesRequestBodyTiers'UpTo =
  PostPricesRequestBodyTiers'
    { postPricesRequestBodyTiers'FlatAmount = GHC.Maybe.Nothing,
      postPricesRequestBodyTiers'FlatAmountDecimal = GHC.Maybe.Nothing,
      postPricesRequestBodyTiers'UnitAmount = GHC.Maybe.Nothing,
      postPricesRequestBodyTiers'UnitAmountDecimal = GHC.Maybe.Nothing,
      postPricesRequestBodyTiers'UpTo = postPricesRequestBodyTiers'UpTo
    }

-- | Defines the oneOf schema located at @paths.\/v1\/prices.POST.requestBody.content.application\/x-www-form-urlencoded.schema.properties.tiers.items.properties.up_to.anyOf@ in the specification.
data PostPricesRequestBodyTiers'UpTo'Variants
  = -- | Represents the JSON value @"inf"@
    PostPricesRequestBodyTiers'UpTo'Inf
  | PostPricesRequestBodyTiers'UpTo'Int GHC.Types.Int
  deriving (GHC.Show.Show, GHC.Classes.Eq)

instance Data.Aeson.Types.ToJSON.ToJSON PostPricesRequestBodyTiers'UpTo'Variants where
  toJSON (PostPricesRequestBodyTiers'UpTo'Int a) = Data.Aeson.Types.ToJSON.toJSON a
  toJSON (PostPricesRequestBodyTiers'UpTo'Inf) = "inf"

instance Data.Aeson.Types.FromJSON.FromJSON PostPricesRequestBodyTiers'UpTo'Variants where
  parseJSON val =
    if
        | val GHC.Classes.== "inf" -> GHC.Base.pure PostPricesRequestBodyTiers'UpTo'Inf
        | GHC.Base.otherwise -> case (PostPricesRequestBodyTiers'UpTo'Int Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> Data.Aeson.Types.Internal.Error "No variant matched" of
          Data.Aeson.Types.Internal.Success a -> GHC.Base.pure a
          Data.Aeson.Types.Internal.Error a -> Control.Monad.Fail.fail a

-- | Defines the enum schema located at @paths.\/v1\/prices.POST.requestBody.content.application\/x-www-form-urlencoded.schema.properties.tiers_mode@ in the specification.
--
-- Defines if the tiering price should be \`graduated\` or \`volume\` based. In \`volume\`-based tiering, the maximum quantity within a period determines the per unit price, in \`graduated\` tiering pricing can successively change as the quantity grows.
data PostPricesRequestBodyTiersMode'
  = -- | This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
    PostPricesRequestBodyTiersMode'Other Data.Aeson.Types.Internal.Value
  | -- | This constructor can be used to send values to the server which are not present in the specification yet.
    PostPricesRequestBodyTiersMode'Typed Data.Text.Internal.Text
  | -- | Represents the JSON value @"graduated"@
    PostPricesRequestBodyTiersMode'EnumGraduated
  | -- | Represents the JSON value @"volume"@
    PostPricesRequestBodyTiersMode'EnumVolume
  deriving (GHC.Show.Show, GHC.Classes.Eq)

instance Data.Aeson.Types.ToJSON.ToJSON PostPricesRequestBodyTiersMode' where
  toJSON (PostPricesRequestBodyTiersMode'Other val) = val
  toJSON (PostPricesRequestBodyTiersMode'Typed val) = Data.Aeson.Types.ToJSON.toJSON val
  toJSON (PostPricesRequestBodyTiersMode'EnumGraduated) = "graduated"
  toJSON (PostPricesRequestBodyTiersMode'EnumVolume) = "volume"

instance Data.Aeson.Types.FromJSON.FromJSON PostPricesRequestBodyTiersMode' where
  parseJSON val =
    GHC.Base.pure
      ( if
            | val GHC.Classes.== "graduated" -> PostPricesRequestBodyTiersMode'EnumGraduated
            | val GHC.Classes.== "volume" -> PostPricesRequestBodyTiersMode'EnumVolume
            | GHC.Base.otherwise -> PostPricesRequestBodyTiersMode'Other val
      )

-- | Defines the object schema located at @paths.\/v1\/prices.POST.requestBody.content.application\/x-www-form-urlencoded.schema.properties.transform_quantity@ in the specification.
--
-- Apply a transformation to the reported usage or set quantity before computing the billed price. Cannot be combined with \`tiers\`.
data PostPricesRequestBodyTransformQuantity' = PostPricesRequestBodyTransformQuantity'
  { -- | divide_by
    postPricesRequestBodyTransformQuantity'DivideBy :: GHC.Types.Int,
    -- | round
    postPricesRequestBodyTransformQuantity'Round :: PostPricesRequestBodyTransformQuantity'Round'
  }
  deriving
    ( GHC.Show.Show,
      GHC.Classes.Eq
    )

instance Data.Aeson.Types.ToJSON.ToJSON PostPricesRequestBodyTransformQuantity' where
  toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["divide_by" Data.Aeson.Types.ToJSON..= postPricesRequestBodyTransformQuantity'DivideBy obj] : ["round" Data.Aeson.Types.ToJSON..= postPricesRequestBodyTransformQuantity'Round obj] : GHC.Base.mempty))
  toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["divide_by" Data.Aeson.Types.ToJSON..= postPricesRequestBodyTransformQuantity'DivideBy obj] : ["round" Data.Aeson.Types.ToJSON..= postPricesRequestBodyTransformQuantity'Round obj] : GHC.Base.mempty)))

instance Data.Aeson.Types.FromJSON.FromJSON PostPricesRequestBodyTransformQuantity' where
  parseJSON = Data.Aeson.Types.FromJSON.withObject "PostPricesRequestBodyTransformQuantity'" (\obj -> (GHC.Base.pure PostPricesRequestBodyTransformQuantity' GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "divide_by")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "round"))

-- | Create a new 'PostPricesRequestBodyTransformQuantity'' with all required fields.
mkPostPricesRequestBodyTransformQuantity' ::
  -- | 'postPricesRequestBodyTransformQuantity'DivideBy'
  GHC.Types.Int ->
  -- | 'postPricesRequestBodyTransformQuantity'Round'
  PostPricesRequestBodyTransformQuantity'Round' ->
  PostPricesRequestBodyTransformQuantity'
mkPostPricesRequestBodyTransformQuantity' postPricesRequestBodyTransformQuantity'DivideBy postPricesRequestBodyTransformQuantity'Round =
  PostPricesRequestBodyTransformQuantity'
    { postPricesRequestBodyTransformQuantity'DivideBy = postPricesRequestBodyTransformQuantity'DivideBy,
      postPricesRequestBodyTransformQuantity'Round = postPricesRequestBodyTransformQuantity'Round
    }

-- | Defines the enum schema located at @paths.\/v1\/prices.POST.requestBody.content.application\/x-www-form-urlencoded.schema.properties.transform_quantity.properties.round@ in the specification.
data PostPricesRequestBodyTransformQuantity'Round'
  = -- | This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
    PostPricesRequestBodyTransformQuantity'Round'Other Data.Aeson.Types.Internal.Value
  | -- | This constructor can be used to send values to the server which are not present in the specification yet.
    PostPricesRequestBodyTransformQuantity'Round'Typed Data.Text.Internal.Text
  | -- | Represents the JSON value @"down"@
    PostPricesRequestBodyTransformQuantity'Round'EnumDown
  | -- | Represents the JSON value @"up"@
    PostPricesRequestBodyTransformQuantity'Round'EnumUp
  deriving (GHC.Show.Show, GHC.Classes.Eq)

instance Data.Aeson.Types.ToJSON.ToJSON PostPricesRequestBodyTransformQuantity'Round' where
  toJSON (PostPricesRequestBodyTransformQuantity'Round'Other val) = val
  toJSON (PostPricesRequestBodyTransformQuantity'Round'Typed val) = Data.Aeson.Types.ToJSON.toJSON val
  toJSON (PostPricesRequestBodyTransformQuantity'Round'EnumDown) = "down"
  toJSON (PostPricesRequestBodyTransformQuantity'Round'EnumUp) = "up"

instance Data.Aeson.Types.FromJSON.FromJSON PostPricesRequestBodyTransformQuantity'Round' where
  parseJSON val =
    GHC.Base.pure
      ( if
            | val GHC.Classes.== "down" -> PostPricesRequestBodyTransformQuantity'Round'EnumDown
            | val GHC.Classes.== "up" -> PostPricesRequestBodyTransformQuantity'Round'EnumUp
            | GHC.Base.otherwise -> PostPricesRequestBodyTransformQuantity'Round'Other val
      )

-- | Represents a response of the operation 'postPrices'.
--
-- The response constructor is chosen by the status code of the response. If no case matches (no specific case for the response code, no range case, no default case), 'PostPricesResponseError' is used.
data PostPricesResponse
  = -- | Means either no matching case available or a parse error
    PostPricesResponseError GHC.Base.String
  | -- | Successful response.
    PostPricesResponse200 Price
  | -- | Error response.
    PostPricesResponseDefault Error
  deriving (GHC.Show.Show, GHC.Classes.Eq)
