{-# LANGUAGE MultiWayIf #-}
-- CHANGE WITH CAUTION: This is a generated code file generated by https://github.com/Haskell-OpenAPI-Code-Generator/Haskell-OpenAPI-Client-Code-Generator.
{-# LANGUAGE OverloadedStrings #-}

-- | Contains the types generated from the schema Product
module StripeAPI.Types.Product where

import qualified Control.Monad.Fail
import qualified Data.Aeson
import qualified Data.Aeson as Data.Aeson.Encoding.Internal
import qualified Data.Aeson as Data.Aeson.Types
import qualified Data.Aeson as Data.Aeson.Types.FromJSON
import qualified Data.Aeson as Data.Aeson.Types.Internal
import qualified Data.Aeson as Data.Aeson.Types.ToJSON
import qualified Data.ByteString.Char8
import qualified Data.ByteString.Char8 as Data.ByteString.Internal
import qualified Data.Functor
import qualified Data.Scientific
import qualified Data.Text
import qualified Data.Text.Internal
import qualified Data.Time.Calendar as Data.Time.Calendar.Days
import qualified Data.Time.LocalTime as Data.Time.LocalTime.Internal.ZonedTime
import qualified GHC.Base
import qualified GHC.Classes
import qualified GHC.Int
import qualified GHC.Show
import qualified GHC.Types
import qualified StripeAPI.Common
import StripeAPI.TypeAlias
import {-# SOURCE #-} StripeAPI.Types.PackageDimensions
import {-# SOURCE #-} StripeAPI.Types.TaxCode
import qualified Prelude as GHC.Integer.Type
import qualified Prelude as GHC.Maybe

-- | Defines the object schema located at @components.schemas.product@ in the specification.
--
-- Products describe the specific goods or services you offer to your customers.
-- For example, you might offer a Standard and Premium version of your goods or service; each version would be a separate Product.
-- They can be used in conjunction with [Prices](https:\/\/stripe.com\/docs\/api\#prices) to configure pricing in Checkout and Subscriptions.
--
-- Related guides: [Set up a subscription](https:\/\/stripe.com\/docs\/billing\/subscriptions\/set-up-subscription) or accept [one-time payments with Checkout](https:\/\/stripe.com\/docs\/payments\/checkout\/client\#create-products) and more about [Products and Prices](https:\/\/stripe.com\/docs\/billing\/prices-guide)
data Product = Product
  { -- | active: Whether the product is currently available for purchase.
    productActive :: GHC.Types.Bool,
    -- | created: Time at which the object was created. Measured in seconds since the Unix epoch.
    productCreated :: GHC.Types.Int,
    -- | description: The product\'s description, meant to be displayable to the customer. Use this field to optionally store a long form explanation of the product being sold for your own rendering purposes.
    --
    -- Constraints:
    --
    -- * Maximum length of 5000
    productDescription :: (GHC.Maybe.Maybe Data.Text.Internal.Text),
    -- | id: Unique identifier for the object.
    --
    -- Constraints:
    --
    -- * Maximum length of 5000
    productId :: Data.Text.Internal.Text,
    -- | images: A list of up to 8 URLs of images for this product, meant to be displayable to the customer.
    productImages :: ([Data.Text.Internal.Text]),
    -- | livemode: Has the value \`true\` if the object exists in live mode or the value \`false\` if the object exists in test mode.
    productLivemode :: GHC.Types.Bool,
    -- | metadata: Set of [key-value pairs](https:\/\/stripe.com\/docs\/api\/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format.
    productMetadata :: Data.Aeson.Types.Internal.Object,
    -- | name: The product\'s name, meant to be displayable to the customer. Whenever this product is sold via a subscription, name will show up on associated invoice line item descriptions.
    --
    -- Constraints:
    --
    -- * Maximum length of 5000
    productName :: Data.Text.Internal.Text,
    -- | package_dimensions: The dimensions of this product for shipping purposes.
    productPackageDimensions :: (GHC.Maybe.Maybe ProductPackageDimensions'),
    -- | shippable: Whether this product is shipped (i.e., physical goods).
    productShippable :: (GHC.Maybe.Maybe GHC.Types.Bool),
    -- | statement_descriptor: Extra information about a product which will appear on your customer\'s credit card statement. In the case that multiple products are billed at once, the first statement descriptor will be used.
    --
    -- Constraints:
    --
    -- * Maximum length of 5000
    productStatementDescriptor :: (GHC.Maybe.Maybe Data.Text.Internal.Text),
    -- | tax_code: A [tax code](https:\/\/stripe.com\/docs\/tax\/tax-codes) ID.
    productTaxCode :: (GHC.Maybe.Maybe ProductTaxCode'Variants),
    -- | unit_label: A label that represents units of this product in Stripe and on customersâ€™ receipts and invoices. When set, this will be included in associated invoice line item descriptions.
    --
    -- Constraints:
    --
    -- * Maximum length of 5000
    productUnitLabel :: (GHC.Maybe.Maybe Data.Text.Internal.Text),
    -- | updated: Time at which the object was last updated. Measured in seconds since the Unix epoch.
    productUpdated :: GHC.Types.Int,
    -- | url: A URL of a publicly-accessible webpage for this product.
    --
    -- Constraints:
    --
    -- * Maximum length of 2048
    productUrl :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  }
  deriving
    ( GHC.Show.Show,
      GHC.Classes.Eq
    )

instance Data.Aeson.Types.ToJSON.ToJSON Product where
  toJSON obj = Data.Aeson.Types.Internal.object ("active" Data.Aeson.Types.ToJSON..= productActive obj : "created" Data.Aeson.Types.ToJSON..= productCreated obj : "description" Data.Aeson.Types.ToJSON..= productDescription obj : "id" Data.Aeson.Types.ToJSON..= productId obj : "images" Data.Aeson.Types.ToJSON..= productImages obj : "livemode" Data.Aeson.Types.ToJSON..= productLivemode obj : "metadata" Data.Aeson.Types.ToJSON..= productMetadata obj : "name" Data.Aeson.Types.ToJSON..= productName obj : "package_dimensions" Data.Aeson.Types.ToJSON..= productPackageDimensions obj : "shippable" Data.Aeson.Types.ToJSON..= productShippable obj : "statement_descriptor" Data.Aeson.Types.ToJSON..= productStatementDescriptor obj : "tax_code" Data.Aeson.Types.ToJSON..= productTaxCode obj : "unit_label" Data.Aeson.Types.ToJSON..= productUnitLabel obj : "updated" Data.Aeson.Types.ToJSON..= productUpdated obj : "url" Data.Aeson.Types.ToJSON..= productUrl obj : "object" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "product" : GHC.Base.mempty)
  toEncoding obj = Data.Aeson.Encoding.Internal.pairs (("active" Data.Aeson.Types.ToJSON..= productActive obj) GHC.Base.<> (("created" Data.Aeson.Types.ToJSON..= productCreated obj) GHC.Base.<> (("description" Data.Aeson.Types.ToJSON..= productDescription obj) GHC.Base.<> (("id" Data.Aeson.Types.ToJSON..= productId obj) GHC.Base.<> (("images" Data.Aeson.Types.ToJSON..= productImages obj) GHC.Base.<> (("livemode" Data.Aeson.Types.ToJSON..= productLivemode obj) GHC.Base.<> (("metadata" Data.Aeson.Types.ToJSON..= productMetadata obj) GHC.Base.<> (("name" Data.Aeson.Types.ToJSON..= productName obj) GHC.Base.<> (("package_dimensions" Data.Aeson.Types.ToJSON..= productPackageDimensions obj) GHC.Base.<> (("shippable" Data.Aeson.Types.ToJSON..= productShippable obj) GHC.Base.<> (("statement_descriptor" Data.Aeson.Types.ToJSON..= productStatementDescriptor obj) GHC.Base.<> (("tax_code" Data.Aeson.Types.ToJSON..= productTaxCode obj) GHC.Base.<> (("unit_label" Data.Aeson.Types.ToJSON..= productUnitLabel obj) GHC.Base.<> (("updated" Data.Aeson.Types.ToJSON..= productUpdated obj) GHC.Base.<> (("url" Data.Aeson.Types.ToJSON..= productUrl obj) GHC.Base.<> ("object" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "product"))))))))))))))))

instance Data.Aeson.Types.FromJSON.FromJSON Product where
  parseJSON = Data.Aeson.Types.FromJSON.withObject "Product" (\obj -> ((((((((((((((GHC.Base.pure Product GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "active")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "created")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "description")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "images")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "livemode")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "metadata")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "name")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "package_dimensions")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "shippable")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "statement_descriptor")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "tax_code")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "unit_label")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "updated")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "url"))

-- | Create a new 'Product' with all required fields.
mkProduct ::
  -- | 'productActive'
  GHC.Types.Bool ->
  -- | 'productCreated'
  GHC.Types.Int ->
  -- | 'productId'
  Data.Text.Internal.Text ->
  -- | 'productImages'
  [Data.Text.Internal.Text] ->
  -- | 'productLivemode'
  GHC.Types.Bool ->
  -- | 'productMetadata'
  Data.Aeson.Types.Internal.Object ->
  -- | 'productName'
  Data.Text.Internal.Text ->
  -- | 'productUpdated'
  GHC.Types.Int ->
  Product
mkProduct productActive productCreated productId productImages productLivemode productMetadata productName productUpdated =
  Product
    { productActive = productActive,
      productCreated = productCreated,
      productDescription = GHC.Maybe.Nothing,
      productId = productId,
      productImages = productImages,
      productLivemode = productLivemode,
      productMetadata = productMetadata,
      productName = productName,
      productPackageDimensions = GHC.Maybe.Nothing,
      productShippable = GHC.Maybe.Nothing,
      productStatementDescriptor = GHC.Maybe.Nothing,
      productTaxCode = GHC.Maybe.Nothing,
      productUnitLabel = GHC.Maybe.Nothing,
      productUpdated = productUpdated,
      productUrl = GHC.Maybe.Nothing
    }

-- | Defines the object schema located at @components.schemas.product.properties.package_dimensions.anyOf@ in the specification.
--
-- The dimensions of this product for shipping purposes.
data ProductPackageDimensions' = ProductPackageDimensions'
  { -- | height: Height, in inches.
    productPackageDimensions'Height :: (GHC.Maybe.Maybe GHC.Types.Double),
    -- | length: Length, in inches.
    productPackageDimensions'Length :: (GHC.Maybe.Maybe GHC.Types.Double),
    -- | weight: Weight, in ounces.
    productPackageDimensions'Weight :: (GHC.Maybe.Maybe GHC.Types.Double),
    -- | width: Width, in inches.
    productPackageDimensions'Width :: (GHC.Maybe.Maybe GHC.Types.Double)
  }
  deriving
    ( GHC.Show.Show,
      GHC.Classes.Eq
    )

instance Data.Aeson.Types.ToJSON.ToJSON ProductPackageDimensions' where
  toJSON obj = Data.Aeson.Types.Internal.object ("height" Data.Aeson.Types.ToJSON..= productPackageDimensions'Height obj : "length" Data.Aeson.Types.ToJSON..= productPackageDimensions'Length obj : "weight" Data.Aeson.Types.ToJSON..= productPackageDimensions'Weight obj : "width" Data.Aeson.Types.ToJSON..= productPackageDimensions'Width obj : GHC.Base.mempty)
  toEncoding obj = Data.Aeson.Encoding.Internal.pairs (("height" Data.Aeson.Types.ToJSON..= productPackageDimensions'Height obj) GHC.Base.<> (("length" Data.Aeson.Types.ToJSON..= productPackageDimensions'Length obj) GHC.Base.<> (("weight" Data.Aeson.Types.ToJSON..= productPackageDimensions'Weight obj) GHC.Base.<> ("width" Data.Aeson.Types.ToJSON..= productPackageDimensions'Width obj))))

instance Data.Aeson.Types.FromJSON.FromJSON ProductPackageDimensions' where
  parseJSON = Data.Aeson.Types.FromJSON.withObject "ProductPackageDimensions'" (\obj -> (((GHC.Base.pure ProductPackageDimensions' GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "height")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "length")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "weight")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "width"))

-- | Create a new 'ProductPackageDimensions'' with all required fields.
mkProductPackageDimensions' :: ProductPackageDimensions'
mkProductPackageDimensions' =
  ProductPackageDimensions'
    { productPackageDimensions'Height = GHC.Maybe.Nothing,
      productPackageDimensions'Length = GHC.Maybe.Nothing,
      productPackageDimensions'Weight = GHC.Maybe.Nothing,
      productPackageDimensions'Width = GHC.Maybe.Nothing
    }

-- | Defines the oneOf schema located at @components.schemas.product.properties.tax_code.anyOf@ in the specification.
--
-- A [tax code](https:\/\/stripe.com\/docs\/tax\/tax-codes) ID.
data ProductTaxCode'Variants
  = ProductTaxCode'Text Data.Text.Internal.Text
  | ProductTaxCode'TaxCode TaxCode
  deriving (GHC.Show.Show, GHC.Classes.Eq)

instance Data.Aeson.Types.ToJSON.ToJSON ProductTaxCode'Variants where
  toJSON (ProductTaxCode'Text a) = Data.Aeson.Types.ToJSON.toJSON a
  toJSON (ProductTaxCode'TaxCode a) = Data.Aeson.Types.ToJSON.toJSON a

instance Data.Aeson.Types.FromJSON.FromJSON ProductTaxCode'Variants where
  parseJSON val = case (ProductTaxCode'Text Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((ProductTaxCode'TaxCode Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> Data.Aeson.Types.Internal.Error "No variant matched") of
    Data.Aeson.Types.Internal.Success a -> GHC.Base.pure a
    Data.Aeson.Types.Internal.Error a -> Control.Monad.Fail.fail a
