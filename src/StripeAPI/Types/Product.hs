{-# LANGUAGE MultiWayIf #-}
{-# LANGUAGE OverloadedStrings #-}

-- CHANGE WITH CAUTION: This is a generated code file generated by https://github.com/Haskell-OpenAPI-Code-Generator/Haskell-OpenAPI-Client-Code-Generator.

-- | Contains the types generated from the schema Product
module StripeAPI.Types.Product where

import qualified Control.Monad.Fail
import qualified Data.Aeson
import qualified Data.Aeson as Data.Aeson.Encoding.Internal
import qualified Data.Aeson as Data.Aeson.Types
import qualified Data.Aeson as Data.Aeson.Types.FromJSON
import qualified Data.Aeson as Data.Aeson.Types.ToJSON
import qualified Data.Aeson as Data.Aeson.Types.Internal
import qualified Data.ByteString.Char8
import qualified Data.ByteString.Char8 as Data.ByteString.Internal
import qualified Data.Functor
import qualified Data.Scientific
import qualified Data.Text
import qualified Data.Text.Internal
import qualified Data.Time.Calendar as Data.Time.Calendar.Days
import qualified Data.Time.LocalTime as Data.Time.LocalTime.Internal.ZonedTime
import qualified GHC.Base
import qualified GHC.Classes
import qualified GHC.Int
import qualified GHC.Show
import qualified GHC.Types
import qualified StripeAPI.Common
import StripeAPI.TypeAlias
import {-# SOURCE #-} StripeAPI.Types.PackageDimensions
import qualified Prelude as GHC.Integer.Type
import qualified Prelude as GHC.Maybe

-- | Defines the object schema located at @components.schemas.product@ in the specification.
--
-- Store representations of products you sell in \`Product\` objects, used in
-- conjunction with [SKUs](https:\/\/stripe.com\/docs\/api\#skus). Products may be physical goods, to be shipped, or
-- digital.
--
-- Documentation on \`Product\`s for use with \`Subscription\`s can be found at
-- [Subscription Products](https:\/\/stripe.com\/docs\/api\#service_products).
--
-- Related guide: [Define products and SKUs](https:\/\/stripe.com\/docs\/orders\#define-products-skus)
data Product
  = Product
      { -- | active: Whether the product is currently available for purchase.
        productActive :: GHC.Types.Bool,
        -- | attributes: A list of up to 5 attributes that each SKU can provide values for (e.g., \`[\"color\", \"size\"]\`).
        productAttributes :: (GHC.Maybe.Maybe ([Data.Text.Internal.Text])),
        -- | caption: A short one-line description of the product, meant to be displayable to the customer. Only applicable to products of \`type=good\`.
        --
        -- Constraints:
        --
        -- * Maximum length of 5000
        productCaption :: (GHC.Maybe.Maybe Data.Text.Internal.Text),
        -- | created: Time at which the object was created. Measured in seconds since the Unix epoch.
        productCreated :: GHC.Types.Int,
        -- | deactivate_on: An array of connect application identifiers that cannot purchase this product. Only applicable to products of \`type=good\`.
        productDeactivateOn :: (GHC.Maybe.Maybe ([Data.Text.Internal.Text])),
        -- | description: The product\'s description, meant to be displayable to the customer. Use this field to optionally store a long form explanation of the product being sold for your own rendering purposes.
        --
        -- Constraints:
        --
        -- * Maximum length of 5000
        productDescription :: (GHC.Maybe.Maybe Data.Text.Internal.Text),
        -- | id: Unique identifier for the object.
        --
        -- Constraints:
        --
        -- * Maximum length of 5000
        productId :: Data.Text.Internal.Text,
        -- | images: A list of up to 8 URLs of images for this product, meant to be displayable to the customer. Only applicable to products of \`type=good\`.
        productImages :: ([Data.Text.Internal.Text]),
        -- | livemode: Has the value \`true\` if the object exists in live mode or the value \`false\` if the object exists in test mode.
        productLivemode :: GHC.Types.Bool,
        -- | metadata: Set of key-value pairs that you can attach to an object. This can be useful for storing additional information about the object in a structured format.
        productMetadata :: Data.Aeson.Types.Internal.Object,
        -- | name: The product\'s name, meant to be displayable to the customer. Whenever this product is sold via a subscription, name will show up on associated invoice line item descriptions.
        --
        -- Constraints:
        --
        -- * Maximum length of 5000
        productName :: Data.Text.Internal.Text,
        -- | package_dimensions: The dimensions of this product for shipping purposes. A SKU associated with this product can override this value by having its own \`package_dimensions\`. Only applicable to products of \`type=good\`.
        productPackageDimensions :: (GHC.Maybe.Maybe ProductPackageDimensions'),
        -- | shippable: Whether this product is a shipped good. Only applicable to products of \`type=good\`.
        productShippable :: (GHC.Maybe.Maybe GHC.Types.Bool),
        -- | statement_descriptor: Extra information about a product which will appear on your customer\'s credit card statement. In the case that multiple products are billed at once, the first statement descriptor will be used.
        --
        -- Constraints:
        --
        -- * Maximum length of 5000
        productStatementDescriptor :: (GHC.Maybe.Maybe Data.Text.Internal.Text),
        -- | type: The type of the product. The product is either of type \`good\`, which is eligible for use with Orders and SKUs, or \`service\`, which is eligible for use with Subscriptions and Plans.
        productType :: ProductType',
        -- | unit_label: A label that represents units of this product in Stripe and on customersâ€™ receipts and invoices. When set, this will be included in associated invoice line item descriptions.
        --
        -- Constraints:
        --
        -- * Maximum length of 5000
        productUnitLabel :: (GHC.Maybe.Maybe Data.Text.Internal.Text),
        -- | updated: Time at which the object was last updated. Measured in seconds since the Unix epoch.
        productUpdated :: GHC.Types.Int,
        -- | url: A URL of a publicly-accessible webpage for this product. Only applicable to products of \`type=good\`.
        --
        -- Constraints:
        --
        -- * Maximum length of 2048
        productUrl :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
      }
  deriving
    ( GHC.Show.Show,
      GHC.Classes.Eq
    )

instance Data.Aeson.Types.ToJSON.ToJSON Product where
  toJSON obj = Data.Aeson.Types.Internal.object ("active" Data.Aeson.Types.ToJSON..= productActive obj : "attributes" Data.Aeson.Types.ToJSON..= productAttributes obj : "caption" Data.Aeson.Types.ToJSON..= productCaption obj : "created" Data.Aeson.Types.ToJSON..= productCreated obj : "deactivate_on" Data.Aeson.Types.ToJSON..= productDeactivateOn obj : "description" Data.Aeson.Types.ToJSON..= productDescription obj : "id" Data.Aeson.Types.ToJSON..= productId obj : "images" Data.Aeson.Types.ToJSON..= productImages obj : "livemode" Data.Aeson.Types.ToJSON..= productLivemode obj : "metadata" Data.Aeson.Types.ToJSON..= productMetadata obj : "name" Data.Aeson.Types.ToJSON..= productName obj : "package_dimensions" Data.Aeson.Types.ToJSON..= productPackageDimensions obj : "shippable" Data.Aeson.Types.ToJSON..= productShippable obj : "statement_descriptor" Data.Aeson.Types.ToJSON..= productStatementDescriptor obj : "type" Data.Aeson.Types.ToJSON..= productType obj : "unit_label" Data.Aeson.Types.ToJSON..= productUnitLabel obj : "updated" Data.Aeson.Types.ToJSON..= productUpdated obj : "url" Data.Aeson.Types.ToJSON..= productUrl obj : "object" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "product" : [])
  toEncoding obj = Data.Aeson.Encoding.Internal.pairs (("active" Data.Aeson.Types.ToJSON..= productActive obj) GHC.Base.<> (("attributes" Data.Aeson.Types.ToJSON..= productAttributes obj) GHC.Base.<> (("caption" Data.Aeson.Types.ToJSON..= productCaption obj) GHC.Base.<> (("created" Data.Aeson.Types.ToJSON..= productCreated obj) GHC.Base.<> (("deactivate_on" Data.Aeson.Types.ToJSON..= productDeactivateOn obj) GHC.Base.<> (("description" Data.Aeson.Types.ToJSON..= productDescription obj) GHC.Base.<> (("id" Data.Aeson.Types.ToJSON..= productId obj) GHC.Base.<> (("images" Data.Aeson.Types.ToJSON..= productImages obj) GHC.Base.<> (("livemode" Data.Aeson.Types.ToJSON..= productLivemode obj) GHC.Base.<> (("metadata" Data.Aeson.Types.ToJSON..= productMetadata obj) GHC.Base.<> (("name" Data.Aeson.Types.ToJSON..= productName obj) GHC.Base.<> (("package_dimensions" Data.Aeson.Types.ToJSON..= productPackageDimensions obj) GHC.Base.<> (("shippable" Data.Aeson.Types.ToJSON..= productShippable obj) GHC.Base.<> (("statement_descriptor" Data.Aeson.Types.ToJSON..= productStatementDescriptor obj) GHC.Base.<> (("type" Data.Aeson.Types.ToJSON..= productType obj) GHC.Base.<> (("unit_label" Data.Aeson.Types.ToJSON..= productUnitLabel obj) GHC.Base.<> (("updated" Data.Aeson.Types.ToJSON..= productUpdated obj) GHC.Base.<> (("url" Data.Aeson.Types.ToJSON..= productUrl obj) GHC.Base.<> ("object" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "product")))))))))))))))))))

instance Data.Aeson.Types.FromJSON.FromJSON Product where
  parseJSON = Data.Aeson.Types.FromJSON.withObject "Product" (\obj -> (((((((((((((((((GHC.Base.pure Product GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "active")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "attributes")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "caption")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "created")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "deactivate_on")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "description")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "images")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "livemode")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "metadata")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "name")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "package_dimensions")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "shippable")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "statement_descriptor")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "type")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "unit_label")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "updated")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "url"))

-- | Create a new 'Product' with all required fields.
mkProduct ::
  -- | 'productActive'
  GHC.Types.Bool ->
  -- | 'productCreated'
  GHC.Types.Int ->
  -- | 'productId'
  Data.Text.Internal.Text ->
  -- | 'productImages'
  [Data.Text.Internal.Text] ->
  -- | 'productLivemode'
  GHC.Types.Bool ->
  -- | 'productMetadata'
  Data.Aeson.Types.Internal.Object ->
  -- | 'productName'
  Data.Text.Internal.Text ->
  -- | 'productType'
  ProductType' ->
  -- | 'productUpdated'
  GHC.Types.Int ->
  Product
mkProduct productActive productCreated productId productImages productLivemode productMetadata productName productType productUpdated =
  Product
    { productActive = productActive,
      productAttributes = GHC.Maybe.Nothing,
      productCaption = GHC.Maybe.Nothing,
      productCreated = productCreated,
      productDeactivateOn = GHC.Maybe.Nothing,
      productDescription = GHC.Maybe.Nothing,
      productId = productId,
      productImages = productImages,
      productLivemode = productLivemode,
      productMetadata = productMetadata,
      productName = productName,
      productPackageDimensions = GHC.Maybe.Nothing,
      productShippable = GHC.Maybe.Nothing,
      productStatementDescriptor = GHC.Maybe.Nothing,
      productType = productType,
      productUnitLabel = GHC.Maybe.Nothing,
      productUpdated = productUpdated,
      productUrl = GHC.Maybe.Nothing
    }

-- | Defines the object schema located at @components.schemas.product.properties.package_dimensions.anyOf@ in the specification.
--
-- The dimensions of this product for shipping purposes. A SKU associated with this product can override this value by having its own \\\`package_dimensions\\\`. Only applicable to products of \\\`type=good\\\`.
data ProductPackageDimensions'
  = ProductPackageDimensions'
      { -- | height: Height, in inches.
        productPackageDimensions'Height :: (GHC.Maybe.Maybe GHC.Types.Double),
        -- | length: Length, in inches.
        productPackageDimensions'Length :: (GHC.Maybe.Maybe GHC.Types.Double),
        -- | weight: Weight, in ounces.
        productPackageDimensions'Weight :: (GHC.Maybe.Maybe GHC.Types.Double),
        -- | width: Width, in inches.
        productPackageDimensions'Width :: (GHC.Maybe.Maybe GHC.Types.Double)
      }
  deriving
    ( GHC.Show.Show,
      GHC.Classes.Eq
    )

instance Data.Aeson.Types.ToJSON.ToJSON ProductPackageDimensions' where
  toJSON obj = Data.Aeson.Types.Internal.object ("height" Data.Aeson.Types.ToJSON..= productPackageDimensions'Height obj : "length" Data.Aeson.Types.ToJSON..= productPackageDimensions'Length obj : "weight" Data.Aeson.Types.ToJSON..= productPackageDimensions'Weight obj : "width" Data.Aeson.Types.ToJSON..= productPackageDimensions'Width obj : [])
  toEncoding obj = Data.Aeson.Encoding.Internal.pairs (("height" Data.Aeson.Types.ToJSON..= productPackageDimensions'Height obj) GHC.Base.<> (("length" Data.Aeson.Types.ToJSON..= productPackageDimensions'Length obj) GHC.Base.<> (("weight" Data.Aeson.Types.ToJSON..= productPackageDimensions'Weight obj) GHC.Base.<> ("width" Data.Aeson.Types.ToJSON..= productPackageDimensions'Width obj))))

instance Data.Aeson.Types.FromJSON.FromJSON ProductPackageDimensions' where
  parseJSON = Data.Aeson.Types.FromJSON.withObject "ProductPackageDimensions'" (\obj -> (((GHC.Base.pure ProductPackageDimensions' GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "height")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "length")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "weight")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "width"))

-- | Create a new 'ProductPackageDimensions'' with all required fields.
mkProductPackageDimensions' :: ProductPackageDimensions'
mkProductPackageDimensions' =
  ProductPackageDimensions'
    { productPackageDimensions'Height = GHC.Maybe.Nothing,
      productPackageDimensions'Length = GHC.Maybe.Nothing,
      productPackageDimensions'Weight = GHC.Maybe.Nothing,
      productPackageDimensions'Width = GHC.Maybe.Nothing
    }

-- | Defines the enum schema located at @components.schemas.product.properties.type@ in the specification.
--
-- The type of the product. The product is either of type \`good\`, which is eligible for use with Orders and SKUs, or \`service\`, which is eligible for use with Subscriptions and Plans.
data ProductType'
  = -- | This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
    ProductType'Other Data.Aeson.Types.Internal.Value
  | -- | This constructor can be used to send values to the server which are not present in the specification yet.
    ProductType'Typed Data.Text.Internal.Text
  | -- | Represents the JSON value @"good"@
    ProductType'EnumGood
  | -- | Represents the JSON value @"service"@
    ProductType'EnumService
  deriving (GHC.Show.Show, GHC.Classes.Eq)

instance Data.Aeson.Types.ToJSON.ToJSON ProductType' where
  toJSON (ProductType'Other val) = val
  toJSON (ProductType'Typed val) = Data.Aeson.Types.ToJSON.toJSON val
  toJSON (ProductType'EnumGood) = "good"
  toJSON (ProductType'EnumService) = "service"

instance Data.Aeson.Types.FromJSON.FromJSON ProductType' where
  parseJSON val =
    GHC.Base.pure
      ( if  | val GHC.Classes.== "good" -> ProductType'EnumGood
            | val GHC.Classes.== "service" -> ProductType'EnumService
            | GHC.Base.otherwise -> ProductType'Other val
      )
