{-# LANGUAGE MultiWayIf #-}
-- CHANGE WITH CAUTION: This is a generated code file generated by https://github.com/Haskell-OpenAPI-Code-Generator/Haskell-OpenAPI-Client-Code-Generator.
{-# LANGUAGE OverloadedStrings #-}

-- | Contains the types generated from the schema Product
module StripeAPI.Types.Product where

import qualified Control.Monad.Fail
import qualified Data.Aeson
import qualified Data.Aeson as Data.Aeson.Encoding.Internal
import qualified Data.Aeson as Data.Aeson.Types
import qualified Data.Aeson as Data.Aeson.Types.FromJSON
import qualified Data.Aeson as Data.Aeson.Types.Internal
import qualified Data.Aeson as Data.Aeson.Types.ToJSON
import qualified Data.ByteString.Char8
import qualified Data.ByteString.Char8 as Data.ByteString.Internal
import qualified Data.Foldable
import qualified Data.Functor
import qualified Data.Maybe
import qualified Data.Scientific
import qualified Data.Text
import qualified Data.Text.Internal
import qualified Data.Time.Calendar as Data.Time.Calendar.Days
import qualified Data.Time.LocalTime as Data.Time.LocalTime.Internal.ZonedTime
import qualified GHC.Base
import qualified GHC.Classes
import qualified GHC.Int
import qualified GHC.Show
import qualified GHC.Types
import qualified StripeAPI.Common
import StripeAPI.TypeAlias
import {-# SOURCE #-} StripeAPI.Types.PackageDimensions
import {-# SOURCE #-} StripeAPI.Types.Price
import {-# SOURCE #-} StripeAPI.Types.TaxCode
import qualified Prelude as GHC.Integer.Type
import qualified Prelude as GHC.Maybe

-- | Defines the object schema located at @components.schemas.product@ in the specification.
--
-- Products describe the specific goods or services you offer to your customers.
-- For example, you might offer a Standard and Premium version of your goods or service; each version would be a separate Product.
-- They can be used in conjunction with [Prices](https:\/\/stripe.com\/docs\/api\#prices) to configure pricing in Payment Links, Checkout, and Subscriptions.
--
-- Related guides: [Set up a subscription](https:\/\/stripe.com\/docs\/billing\/subscriptions\/set-up-subscription),
-- [share a Payment Link](https:\/\/stripe.com\/docs\/payments\/payment-links\/overview),
-- [accept payments with Checkout](https:\/\/stripe.com\/docs\/payments\/accept-a-payment\#create-product-prices-upfront),
-- and more about [Products and Prices](https:\/\/stripe.com\/docs\/products-prices\/overview)
data Product = Product
  { -- | active: Whether the product is currently available for purchase.
    productActive :: GHC.Types.Bool,
    -- | created: Time at which the object was created. Measured in seconds since the Unix epoch.
    productCreated :: GHC.Types.Int,
    -- | default_price: The ID of the [Price](https:\/\/stripe.com\/docs\/api\/prices) object that is the default price for this product.
    productDefaultPrice :: (GHC.Maybe.Maybe (StripeAPI.Common.Nullable ProductDefaultPrice'NonNullableVariants)),
    -- | description: The product\'s description, meant to be displayable to the customer. Use this field to optionally store a long form explanation of the product being sold for your own rendering purposes.
    --
    -- Constraints:
    --
    -- * Maximum length of 5000
    productDescription :: (GHC.Maybe.Maybe (StripeAPI.Common.Nullable Data.Text.Internal.Text)),
    -- | id: Unique identifier for the object.
    --
    -- Constraints:
    --
    -- * Maximum length of 5000
    productId :: Data.Text.Internal.Text,
    -- | images: A list of up to 8 URLs of images for this product, meant to be displayable to the customer.
    productImages :: ([Data.Text.Internal.Text]),
    -- | livemode: Has the value \`true\` if the object exists in live mode or the value \`false\` if the object exists in test mode.
    productLivemode :: GHC.Types.Bool,
    -- | metadata: Set of [key-value pairs](https:\/\/stripe.com\/docs\/api\/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format.
    productMetadata :: Data.Aeson.Types.Internal.Object,
    -- | name: The product\'s name, meant to be displayable to the customer.
    --
    -- Constraints:
    --
    -- * Maximum length of 5000
    productName :: Data.Text.Internal.Text,
    -- | package_dimensions: The dimensions of this product for shipping purposes.
    productPackageDimensions :: (GHC.Maybe.Maybe (StripeAPI.Common.Nullable ProductPackageDimensions'NonNullable)),
    -- | shippable: Whether this product is shipped (i.e., physical goods).
    productShippable :: (GHC.Maybe.Maybe (StripeAPI.Common.Nullable GHC.Types.Bool)),
    -- | statement_descriptor: Extra information about a product which will appear on your customer\'s credit card statement. In the case that multiple products are billed at once, the first statement descriptor will be used.
    --
    -- Constraints:
    --
    -- * Maximum length of 5000
    productStatementDescriptor :: (GHC.Maybe.Maybe (StripeAPI.Common.Nullable Data.Text.Internal.Text)),
    -- | tax_code: A [tax code](https:\/\/stripe.com\/docs\/tax\/tax-categories) ID.
    productTaxCode :: (GHC.Maybe.Maybe (StripeAPI.Common.Nullable ProductTaxCode'NonNullableVariants)),
    -- | unit_label: A label that represents units of this product in Stripe and on customersâ€™ receipts and invoices. When set, this will be included in associated invoice line item descriptions.
    --
    -- Constraints:
    --
    -- * Maximum length of 5000
    productUnitLabel :: (GHC.Maybe.Maybe (StripeAPI.Common.Nullable Data.Text.Internal.Text)),
    -- | updated: Time at which the object was last updated. Measured in seconds since the Unix epoch.
    productUpdated :: GHC.Types.Int,
    -- | url: A URL of a publicly-accessible webpage for this product.
    --
    -- Constraints:
    --
    -- * Maximum length of 2048
    productUrl :: (GHC.Maybe.Maybe (StripeAPI.Common.Nullable Data.Text.Internal.Text))
  }
  deriving
    ( GHC.Show.Show,
      GHC.Classes.Eq
    )

instance Data.Aeson.Types.ToJSON.ToJSON Product where
  toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["active" Data.Aeson.Types.ToJSON..= productActive obj] : ["created" Data.Aeson.Types.ToJSON..= productCreated obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("default_price" Data.Aeson.Types.ToJSON..=)) (productDefaultPrice obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("description" Data.Aeson.Types.ToJSON..=)) (productDescription obj) : ["id" Data.Aeson.Types.ToJSON..= productId obj] : ["images" Data.Aeson.Types.ToJSON..= productImages obj] : ["livemode" Data.Aeson.Types.ToJSON..= productLivemode obj] : ["metadata" Data.Aeson.Types.ToJSON..= productMetadata obj] : ["name" Data.Aeson.Types.ToJSON..= productName obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("package_dimensions" Data.Aeson.Types.ToJSON..=)) (productPackageDimensions obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("shippable" Data.Aeson.Types.ToJSON..=)) (productShippable obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("statement_descriptor" Data.Aeson.Types.ToJSON..=)) (productStatementDescriptor obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("tax_code" Data.Aeson.Types.ToJSON..=)) (productTaxCode obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("unit_label" Data.Aeson.Types.ToJSON..=)) (productUnitLabel obj) : ["updated" Data.Aeson.Types.ToJSON..= productUpdated obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("url" Data.Aeson.Types.ToJSON..=)) (productUrl obj) : ["object" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "product"] : GHC.Base.mempty))
  toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["active" Data.Aeson.Types.ToJSON..= productActive obj] : ["created" Data.Aeson.Types.ToJSON..= productCreated obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("default_price" Data.Aeson.Types.ToJSON..=)) (productDefaultPrice obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("description" Data.Aeson.Types.ToJSON..=)) (productDescription obj) : ["id" Data.Aeson.Types.ToJSON..= productId obj] : ["images" Data.Aeson.Types.ToJSON..= productImages obj] : ["livemode" Data.Aeson.Types.ToJSON..= productLivemode obj] : ["metadata" Data.Aeson.Types.ToJSON..= productMetadata obj] : ["name" Data.Aeson.Types.ToJSON..= productName obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("package_dimensions" Data.Aeson.Types.ToJSON..=)) (productPackageDimensions obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("shippable" Data.Aeson.Types.ToJSON..=)) (productShippable obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("statement_descriptor" Data.Aeson.Types.ToJSON..=)) (productStatementDescriptor obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("tax_code" Data.Aeson.Types.ToJSON..=)) (productTaxCode obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("unit_label" Data.Aeson.Types.ToJSON..=)) (productUnitLabel obj) : ["updated" Data.Aeson.Types.ToJSON..= productUpdated obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("url" Data.Aeson.Types.ToJSON..=)) (productUrl obj) : ["object" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "product"] : GHC.Base.mempty)))

instance Data.Aeson.Types.FromJSON.FromJSON Product where
  parseJSON = Data.Aeson.Types.FromJSON.withObject "Product" (\obj -> (((((((((((((((GHC.Base.pure Product GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "active")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "created")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "default_price")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "description")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "images")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "livemode")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "metadata")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "name")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "package_dimensions")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "shippable")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "statement_descriptor")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "tax_code")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "unit_label")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "updated")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "url"))

-- | Create a new 'Product' with all required fields.
mkProduct ::
  -- | 'productActive'
  GHC.Types.Bool ->
  -- | 'productCreated'
  GHC.Types.Int ->
  -- | 'productId'
  Data.Text.Internal.Text ->
  -- | 'productImages'
  [Data.Text.Internal.Text] ->
  -- | 'productLivemode'
  GHC.Types.Bool ->
  -- | 'productMetadata'
  Data.Aeson.Types.Internal.Object ->
  -- | 'productName'
  Data.Text.Internal.Text ->
  -- | 'productUpdated'
  GHC.Types.Int ->
  Product
mkProduct productActive productCreated productId productImages productLivemode productMetadata productName productUpdated =
  Product
    { productActive = productActive,
      productCreated = productCreated,
      productDefaultPrice = GHC.Maybe.Nothing,
      productDescription = GHC.Maybe.Nothing,
      productId = productId,
      productImages = productImages,
      productLivemode = productLivemode,
      productMetadata = productMetadata,
      productName = productName,
      productPackageDimensions = GHC.Maybe.Nothing,
      productShippable = GHC.Maybe.Nothing,
      productStatementDescriptor = GHC.Maybe.Nothing,
      productTaxCode = GHC.Maybe.Nothing,
      productUnitLabel = GHC.Maybe.Nothing,
      productUpdated = productUpdated,
      productUrl = GHC.Maybe.Nothing
    }

-- | Defines the oneOf schema located at @components.schemas.product.properties.default_price.anyOf@ in the specification.
--
-- The ID of the [Price](https:\/\/stripe.com\/docs\/api\/prices) object that is the default price for this product.
data ProductDefaultPrice'NonNullableVariants
  = ProductDefaultPrice'NonNullableText Data.Text.Internal.Text
  | ProductDefaultPrice'NonNullablePrice Price
  deriving (GHC.Show.Show, GHC.Classes.Eq)

instance Data.Aeson.Types.ToJSON.ToJSON ProductDefaultPrice'NonNullableVariants where
  toJSON (ProductDefaultPrice'NonNullableText a) = Data.Aeson.Types.ToJSON.toJSON a
  toJSON (ProductDefaultPrice'NonNullablePrice a) = Data.Aeson.Types.ToJSON.toJSON a

instance Data.Aeson.Types.FromJSON.FromJSON ProductDefaultPrice'NonNullableVariants where
  parseJSON val = case (ProductDefaultPrice'NonNullableText Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((ProductDefaultPrice'NonNullablePrice Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> Data.Aeson.Types.Internal.Error "No variant matched") of
    Data.Aeson.Types.Internal.Success a -> GHC.Base.pure a
    Data.Aeson.Types.Internal.Error a -> Control.Monad.Fail.fail a

-- | Defines the object schema located at @components.schemas.product.properties.package_dimensions.anyOf@ in the specification.
--
-- The dimensions of this product for shipping purposes.
data ProductPackageDimensions'NonNullable = ProductPackageDimensions'NonNullable
  { -- | height: Height, in inches.
    productPackageDimensions'NonNullableHeight :: (GHC.Maybe.Maybe GHC.Types.Double),
    -- | length: Length, in inches.
    productPackageDimensions'NonNullableLength :: (GHC.Maybe.Maybe GHC.Types.Double),
    -- | weight: Weight, in ounces.
    productPackageDimensions'NonNullableWeight :: (GHC.Maybe.Maybe GHC.Types.Double),
    -- | width: Width, in inches.
    productPackageDimensions'NonNullableWidth :: (GHC.Maybe.Maybe GHC.Types.Double)
  }
  deriving
    ( GHC.Show.Show,
      GHC.Classes.Eq
    )

instance Data.Aeson.Types.ToJSON.ToJSON ProductPackageDimensions'NonNullable where
  toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("height" Data.Aeson.Types.ToJSON..=)) (productPackageDimensions'NonNullableHeight obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("length" Data.Aeson.Types.ToJSON..=)) (productPackageDimensions'NonNullableLength obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("weight" Data.Aeson.Types.ToJSON..=)) (productPackageDimensions'NonNullableWeight obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("width" Data.Aeson.Types.ToJSON..=)) (productPackageDimensions'NonNullableWidth obj) : GHC.Base.mempty))
  toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("height" Data.Aeson.Types.ToJSON..=)) (productPackageDimensions'NonNullableHeight obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("length" Data.Aeson.Types.ToJSON..=)) (productPackageDimensions'NonNullableLength obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("weight" Data.Aeson.Types.ToJSON..=)) (productPackageDimensions'NonNullableWeight obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("width" Data.Aeson.Types.ToJSON..=)) (productPackageDimensions'NonNullableWidth obj) : GHC.Base.mempty)))

instance Data.Aeson.Types.FromJSON.FromJSON ProductPackageDimensions'NonNullable where
  parseJSON = Data.Aeson.Types.FromJSON.withObject "ProductPackageDimensions'NonNullable" (\obj -> (((GHC.Base.pure ProductPackageDimensions'NonNullable GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "height")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "length")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "weight")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "width"))

-- | Create a new 'ProductPackageDimensions'NonNullable' with all required fields.
mkProductPackageDimensions'NonNullable :: ProductPackageDimensions'NonNullable
mkProductPackageDimensions'NonNullable =
  ProductPackageDimensions'NonNullable
    { productPackageDimensions'NonNullableHeight = GHC.Maybe.Nothing,
      productPackageDimensions'NonNullableLength = GHC.Maybe.Nothing,
      productPackageDimensions'NonNullableWeight = GHC.Maybe.Nothing,
      productPackageDimensions'NonNullableWidth = GHC.Maybe.Nothing
    }

-- | Defines the oneOf schema located at @components.schemas.product.properties.tax_code.anyOf@ in the specification.
--
-- A [tax code](https:\/\/stripe.com\/docs\/tax\/tax-categories) ID.
data ProductTaxCode'NonNullableVariants
  = ProductTaxCode'NonNullableText Data.Text.Internal.Text
  | ProductTaxCode'NonNullableTaxCode TaxCode
  deriving (GHC.Show.Show, GHC.Classes.Eq)

instance Data.Aeson.Types.ToJSON.ToJSON ProductTaxCode'NonNullableVariants where
  toJSON (ProductTaxCode'NonNullableText a) = Data.Aeson.Types.ToJSON.toJSON a
  toJSON (ProductTaxCode'NonNullableTaxCode a) = Data.Aeson.Types.ToJSON.toJSON a

instance Data.Aeson.Types.FromJSON.FromJSON ProductTaxCode'NonNullableVariants where
  parseJSON val = case (ProductTaxCode'NonNullableText Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((ProductTaxCode'NonNullableTaxCode Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> Data.Aeson.Types.Internal.Error "No variant matched") of
    Data.Aeson.Types.Internal.Success a -> GHC.Base.pure a
    Data.Aeson.Types.Internal.Error a -> Control.Monad.Fail.fail a
