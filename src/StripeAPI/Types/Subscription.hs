{-# LANGUAGE MultiWayIf #-}
{-# LANGUAGE OverloadedStrings #-}

-- CHANGE WITH CAUTION: This is a generated code file generated by https://github.com/Haskell-OpenAPI-Code-Generator/Haskell-OpenAPI-Client-Code-Generator.

-- | Contains the types generated from the schema Subscription
module StripeAPI.Types.Subscription where

import qualified Control.Monad.Fail
import qualified Data.Aeson
import qualified Data.Aeson as Data.Aeson.Encoding.Internal
import qualified Data.Aeson as Data.Aeson.Types
import qualified Data.Aeson as Data.Aeson.Types.FromJSON
import qualified Data.Aeson as Data.Aeson.Types.ToJSON
import qualified Data.Aeson as Data.Aeson.Types.Internal
import qualified Data.ByteString.Char8
import qualified Data.ByteString.Char8 as Data.ByteString.Internal
import qualified Data.Functor
import qualified Data.Scientific
import qualified Data.Text
import qualified Data.Text.Internal
import qualified Data.Time.Calendar as Data.Time.Calendar.Days
import qualified Data.Time.LocalTime as Data.Time.LocalTime.Internal.ZonedTime
import qualified GHC.Base
import qualified GHC.Classes
import qualified GHC.Int
import qualified GHC.Show
import qualified GHC.Types
import qualified StripeAPI.Common
import StripeAPI.TypeAlias
import {-# SOURCE #-} StripeAPI.Types.AlipayAccount
import {-# SOURCE #-} StripeAPI.Types.BankAccount
import {-# SOURCE #-} StripeAPI.Types.BitcoinReceiver
import {-# SOURCE #-} StripeAPI.Types.Card
import {-# SOURCE #-} StripeAPI.Types.Coupon
import {-# SOURCE #-} StripeAPI.Types.Customer
import {-# SOURCE #-} StripeAPI.Types.DeletedCustomer
import {-# SOURCE #-} StripeAPI.Types.DeletedProduct
import {-# SOURCE #-} StripeAPI.Types.Discount
import {-# SOURCE #-} StripeAPI.Types.Invoice
import {-# SOURCE #-} StripeAPI.Types.PaymentMethod
import {-# SOURCE #-} StripeAPI.Types.Plan
import {-# SOURCE #-} StripeAPI.Types.PlanTier
import {-# SOURCE #-} StripeAPI.Types.Product
import {-# SOURCE #-} StripeAPI.Types.SetupIntent
import {-# SOURCE #-} StripeAPI.Types.Source
import {-# SOURCE #-} StripeAPI.Types.SubscriptionBillingThresholds
import {-# SOURCE #-} StripeAPI.Types.SubscriptionItem
import {-# SOURCE #-} StripeAPI.Types.SubscriptionPendingInvoiceItemInterval
import {-# SOURCE #-} StripeAPI.Types.SubscriptionSchedule
import {-# SOURCE #-} StripeAPI.Types.SubscriptionsResourcePendingUpdate
import {-# SOURCE #-} StripeAPI.Types.TaxRate
import {-# SOURCE #-} StripeAPI.Types.TransformUsage
import qualified Prelude as GHC.Integer.Type
import qualified Prelude as GHC.Maybe

-- | Defines the object schema located at @components.schemas.subscription@ in the specification.
--
-- Subscriptions allow you to charge a customer on a recurring basis.
--
-- Related guide: [Creating Subscriptions](https:\/\/stripe.com\/docs\/billing\/subscriptions\/creating).
data Subscription
  = Subscription
      { -- | application_fee_percent: A non-negative decimal between 0 and 100, with at most two decimal places. This represents the percentage of the subscription invoice subtotal that will be transferred to the application owner\'s Stripe account.
        subscriptionApplicationFeePercent :: (GHC.Maybe.Maybe GHC.Types.Double),
        -- | billing_cycle_anchor: Determines the date of the first full invoice, and, for plans with \`month\` or \`year\` intervals, the day of the month for subsequent invoices.
        subscriptionBillingCycleAnchor :: GHC.Types.Int,
        -- | billing_thresholds: Define thresholds at which an invoice will be sent, and the subscription advanced to a new billing period
        subscriptionBillingThresholds :: (GHC.Maybe.Maybe SubscriptionBillingThresholds'),
        -- | cancel_at: A date in the future at which the subscription will automatically get canceled
        subscriptionCancelAt :: (GHC.Maybe.Maybe GHC.Types.Int),
        -- | cancel_at_period_end: If the subscription has been canceled with the \`at_period_end\` flag set to \`true\`, \`cancel_at_period_end\` on the subscription will be true. You can use this attribute to determine whether a subscription that has a status of active is scheduled to be canceled at the end of the current period.
        subscriptionCancelAtPeriodEnd :: GHC.Types.Bool,
        -- | canceled_at: If the subscription has been canceled, the date of that cancellation. If the subscription was canceled with \`cancel_at_period_end\`, \`canceled_at\` will still reflect the date of the initial cancellation request, not the end of the subscription period when the subscription is automatically moved to a canceled state.
        subscriptionCanceledAt :: (GHC.Maybe.Maybe GHC.Types.Int),
        -- | collection_method: Either \`charge_automatically\`, or \`send_invoice\`. When charging automatically, Stripe will attempt to pay this subscription at the end of the cycle using the default source attached to the customer. When sending an invoice, Stripe will email your customer an invoice with payment instructions.
        subscriptionCollectionMethod :: (GHC.Maybe.Maybe SubscriptionCollectionMethod'),
        -- | created: Time at which the object was created. Measured in seconds since the Unix epoch.
        subscriptionCreated :: GHC.Types.Int,
        -- | current_period_end: End of the current period that the subscription has been invoiced for. At the end of this period, a new invoice will be created.
        subscriptionCurrentPeriodEnd :: GHC.Types.Int,
        -- | current_period_start: Start of the current period that the subscription has been invoiced for.
        subscriptionCurrentPeriodStart :: GHC.Types.Int,
        -- | customer: ID of the customer who owns the subscription.
        subscriptionCustomer :: SubscriptionCustomer'Variants,
        -- | days_until_due: Number of days a customer has to pay invoices generated by this subscription. This value will be \`null\` for subscriptions where \`collection_method=charge_automatically\`.
        subscriptionDaysUntilDue :: (GHC.Maybe.Maybe GHC.Types.Int),
        -- | default_payment_method: ID of the default payment method for the subscription. It must belong to the customer associated with the subscription. If not set, invoices will use the default payment method in the customer\'s invoice settings.
        subscriptionDefaultPaymentMethod :: (GHC.Maybe.Maybe SubscriptionDefaultPaymentMethod'Variants),
        -- | default_source: ID of the default payment source for the subscription. It must belong to the customer associated with the subscription and be in a chargeable state. If not set, defaults to the customer\'s default source.
        subscriptionDefaultSource :: (GHC.Maybe.Maybe SubscriptionDefaultSource'Variants),
        -- | default_tax_rates: The tax rates that will apply to any subscription item that does not have \`tax_rates\` set. Invoices created will have their \`default_tax_rates\` populated from the subscription.
        subscriptionDefaultTaxRates :: (GHC.Maybe.Maybe ([TaxRate])),
        -- | discount: Describes the current discount applied to this subscription, if there is one. When billing, a discount applied to a subscription overrides a discount applied on a customer-wide basis.
        subscriptionDiscount :: (GHC.Maybe.Maybe SubscriptionDiscount'),
        -- | ended_at: If the subscription has ended, the date the subscription ended.
        subscriptionEndedAt :: (GHC.Maybe.Maybe GHC.Types.Int),
        -- | id: Unique identifier for the object.
        --
        -- Constraints:
        --
        -- * Maximum length of 5000
        subscriptionId :: Data.Text.Internal.Text,
        -- | items: List of subscription items, each with an attached plan.
        subscriptionItems :: SubscriptionItems',
        -- | latest_invoice: The most recent invoice this subscription has generated.
        subscriptionLatestInvoice :: (GHC.Maybe.Maybe SubscriptionLatestInvoice'Variants),
        -- | livemode: Has the value \`true\` if the object exists in live mode or the value \`false\` if the object exists in test mode.
        subscriptionLivemode :: GHC.Types.Bool,
        -- | metadata: Set of key-value pairs that you can attach to an object. This can be useful for storing additional information about the object in a structured format.
        subscriptionMetadata :: Data.Aeson.Types.Internal.Object,
        -- | next_pending_invoice_item_invoice: Specifies the approximate timestamp on which any pending invoice items will be billed according to the schedule provided at \`pending_invoice_item_interval\`.
        subscriptionNextPendingInvoiceItemInvoice :: (GHC.Maybe.Maybe GHC.Types.Int),
        -- | pending_invoice_item_interval: Specifies an interval for how often to bill for any pending invoice items. It is analogous to calling [Create an invoice](https:\/\/stripe.com\/docs\/api\#create_invoice) for the given subscription at the specified interval.
        subscriptionPendingInvoiceItemInterval :: (GHC.Maybe.Maybe SubscriptionPendingInvoiceItemInterval'),
        -- | pending_setup_intent: You can use this [SetupIntent](https:\/\/stripe.com\/docs\/api\/setup_intents) to collect user authentication when creating a subscription without immediate payment or updating a subscription\'s payment method, allowing you to optimize for off-session payments. Learn more in the [SCA Migration Guide](https:\/\/stripe.com\/docs\/billing\/migration\/strong-customer-authentication\#scenario-2).
        subscriptionPendingSetupIntent :: (GHC.Maybe.Maybe SubscriptionPendingSetupIntent'Variants),
        -- | pending_update: If specified, [pending updates](https:\/\/stripe.com\/docs\/billing\/subscriptions\/pending-updates) that will be applied to the subscription once the \`latest_invoice\` has been paid.
        subscriptionPendingUpdate :: (GHC.Maybe.Maybe SubscriptionPendingUpdate'),
        -- | plan: Hash describing the plan the customer is subscribed to. Only set if the subscription contains a single plan.
        subscriptionPlan :: (GHC.Maybe.Maybe SubscriptionPlan'),
        -- | quantity: The quantity of the plan to which the customer is subscribed. For example, if your plan is \$10\/user\/month, and your customer has 5 users, you could pass 5 as the quantity to have the customer charged \$50 (5 x \$10) monthly. Only set if the subscription contains a single plan.
        subscriptionQuantity :: (GHC.Maybe.Maybe GHC.Types.Int),
        -- | schedule: The schedule attached to the subscription
        subscriptionSchedule :: (GHC.Maybe.Maybe SubscriptionSchedule'Variants),
        -- | start_date: Date when the subscription was first created. The date might differ from the \`created\` date due to backdating.
        subscriptionStartDate :: GHC.Types.Int,
        -- | status: Possible values are \`incomplete\`, \`incomplete_expired\`, \`trialing\`, \`active\`, \`past_due\`, \`canceled\`, or \`unpaid\`.
        --
        -- For \`collection_method=charge_automatically\` a subscription moves into \`incomplete\` if the initial payment attempt fails. A subscription in this state can only have metadata and default_source updated. Once the first invoice is paid, the subscription moves into an \`active\` state. If the first invoice is not paid within 23 hours, the subscription transitions to \`incomplete_expired\`. This is a terminal state, the open invoice will be voided and no further invoices will be generated.
        --
        -- A subscription that is currently in a trial period is \`trialing\` and moves to \`active\` when the trial period is over.
        --
        -- If subscription \`collection_method=charge_automatically\` it becomes \`past_due\` when payment to renew it fails and \`canceled\` or \`unpaid\` (depending on your subscriptions settings) when Stripe has exhausted all payment retry attempts.
        --
        -- If subscription \`collection_method=send_invoice\` it becomes \`past_due\` when its invoice is not paid by the due date, and \`canceled\` or \`unpaid\` if it is still not paid by an additional deadline after that. Note that when a subscription has a status of \`unpaid\`, no subsequent invoices will be attempted (invoices will be created, but then immediately automatically closed). After receiving updated payment information from a customer, you may choose to reopen and pay their closed invoices.
        subscriptionStatus :: SubscriptionStatus',
        -- | tax_percent: If provided, each invoice created by this subscription will apply the tax rate, increasing the amount billed to the customer.
        subscriptionTaxPercent :: (GHC.Maybe.Maybe GHC.Types.Double),
        -- | trial_end: If the subscription has a trial, the end of that trial.
        subscriptionTrialEnd :: (GHC.Maybe.Maybe GHC.Types.Int),
        -- | trial_start: If the subscription has a trial, the beginning of that trial.
        subscriptionTrialStart :: (GHC.Maybe.Maybe GHC.Types.Int)
      }
  deriving
    ( GHC.Show.Show,
      GHC.Classes.Eq
    )

instance Data.Aeson.Types.ToJSON.ToJSON Subscription where
  toJSON obj = Data.Aeson.Types.Internal.object ("application_fee_percent" Data.Aeson.Types.ToJSON..= subscriptionApplicationFeePercent obj : "billing_cycle_anchor" Data.Aeson.Types.ToJSON..= subscriptionBillingCycleAnchor obj : "billing_thresholds" Data.Aeson.Types.ToJSON..= subscriptionBillingThresholds obj : "cancel_at" Data.Aeson.Types.ToJSON..= subscriptionCancelAt obj : "cancel_at_period_end" Data.Aeson.Types.ToJSON..= subscriptionCancelAtPeriodEnd obj : "canceled_at" Data.Aeson.Types.ToJSON..= subscriptionCanceledAt obj : "collection_method" Data.Aeson.Types.ToJSON..= subscriptionCollectionMethod obj : "created" Data.Aeson.Types.ToJSON..= subscriptionCreated obj : "current_period_end" Data.Aeson.Types.ToJSON..= subscriptionCurrentPeriodEnd obj : "current_period_start" Data.Aeson.Types.ToJSON..= subscriptionCurrentPeriodStart obj : "customer" Data.Aeson.Types.ToJSON..= subscriptionCustomer obj : "days_until_due" Data.Aeson.Types.ToJSON..= subscriptionDaysUntilDue obj : "default_payment_method" Data.Aeson.Types.ToJSON..= subscriptionDefaultPaymentMethod obj : "default_source" Data.Aeson.Types.ToJSON..= subscriptionDefaultSource obj : "default_tax_rates" Data.Aeson.Types.ToJSON..= subscriptionDefaultTaxRates obj : "discount" Data.Aeson.Types.ToJSON..= subscriptionDiscount obj : "ended_at" Data.Aeson.Types.ToJSON..= subscriptionEndedAt obj : "id" Data.Aeson.Types.ToJSON..= subscriptionId obj : "items" Data.Aeson.Types.ToJSON..= subscriptionItems obj : "latest_invoice" Data.Aeson.Types.ToJSON..= subscriptionLatestInvoice obj : "livemode" Data.Aeson.Types.ToJSON..= subscriptionLivemode obj : "metadata" Data.Aeson.Types.ToJSON..= subscriptionMetadata obj : "next_pending_invoice_item_invoice" Data.Aeson.Types.ToJSON..= subscriptionNextPendingInvoiceItemInvoice obj : "pending_invoice_item_interval" Data.Aeson.Types.ToJSON..= subscriptionPendingInvoiceItemInterval obj : "pending_setup_intent" Data.Aeson.Types.ToJSON..= subscriptionPendingSetupIntent obj : "pending_update" Data.Aeson.Types.ToJSON..= subscriptionPendingUpdate obj : "plan" Data.Aeson.Types.ToJSON..= subscriptionPlan obj : "quantity" Data.Aeson.Types.ToJSON..= subscriptionQuantity obj : "schedule" Data.Aeson.Types.ToJSON..= subscriptionSchedule obj : "start_date" Data.Aeson.Types.ToJSON..= subscriptionStartDate obj : "status" Data.Aeson.Types.ToJSON..= subscriptionStatus obj : "tax_percent" Data.Aeson.Types.ToJSON..= subscriptionTaxPercent obj : "trial_end" Data.Aeson.Types.ToJSON..= subscriptionTrialEnd obj : "trial_start" Data.Aeson.Types.ToJSON..= subscriptionTrialStart obj : "object" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "subscription" : [])
  toEncoding obj = Data.Aeson.Encoding.Internal.pairs (("application_fee_percent" Data.Aeson.Types.ToJSON..= subscriptionApplicationFeePercent obj) GHC.Base.<> (("billing_cycle_anchor" Data.Aeson.Types.ToJSON..= subscriptionBillingCycleAnchor obj) GHC.Base.<> (("billing_thresholds" Data.Aeson.Types.ToJSON..= subscriptionBillingThresholds obj) GHC.Base.<> (("cancel_at" Data.Aeson.Types.ToJSON..= subscriptionCancelAt obj) GHC.Base.<> (("cancel_at_period_end" Data.Aeson.Types.ToJSON..= subscriptionCancelAtPeriodEnd obj) GHC.Base.<> (("canceled_at" Data.Aeson.Types.ToJSON..= subscriptionCanceledAt obj) GHC.Base.<> (("collection_method" Data.Aeson.Types.ToJSON..= subscriptionCollectionMethod obj) GHC.Base.<> (("created" Data.Aeson.Types.ToJSON..= subscriptionCreated obj) GHC.Base.<> (("current_period_end" Data.Aeson.Types.ToJSON..= subscriptionCurrentPeriodEnd obj) GHC.Base.<> (("current_period_start" Data.Aeson.Types.ToJSON..= subscriptionCurrentPeriodStart obj) GHC.Base.<> (("customer" Data.Aeson.Types.ToJSON..= subscriptionCustomer obj) GHC.Base.<> (("days_until_due" Data.Aeson.Types.ToJSON..= subscriptionDaysUntilDue obj) GHC.Base.<> (("default_payment_method" Data.Aeson.Types.ToJSON..= subscriptionDefaultPaymentMethod obj) GHC.Base.<> (("default_source" Data.Aeson.Types.ToJSON..= subscriptionDefaultSource obj) GHC.Base.<> (("default_tax_rates" Data.Aeson.Types.ToJSON..= subscriptionDefaultTaxRates obj) GHC.Base.<> (("discount" Data.Aeson.Types.ToJSON..= subscriptionDiscount obj) GHC.Base.<> (("ended_at" Data.Aeson.Types.ToJSON..= subscriptionEndedAt obj) GHC.Base.<> (("id" Data.Aeson.Types.ToJSON..= subscriptionId obj) GHC.Base.<> (("items" Data.Aeson.Types.ToJSON..= subscriptionItems obj) GHC.Base.<> (("latest_invoice" Data.Aeson.Types.ToJSON..= subscriptionLatestInvoice obj) GHC.Base.<> (("livemode" Data.Aeson.Types.ToJSON..= subscriptionLivemode obj) GHC.Base.<> (("metadata" Data.Aeson.Types.ToJSON..= subscriptionMetadata obj) GHC.Base.<> (("next_pending_invoice_item_invoice" Data.Aeson.Types.ToJSON..= subscriptionNextPendingInvoiceItemInvoice obj) GHC.Base.<> (("pending_invoice_item_interval" Data.Aeson.Types.ToJSON..= subscriptionPendingInvoiceItemInterval obj) GHC.Base.<> (("pending_setup_intent" Data.Aeson.Types.ToJSON..= subscriptionPendingSetupIntent obj) GHC.Base.<> (("pending_update" Data.Aeson.Types.ToJSON..= subscriptionPendingUpdate obj) GHC.Base.<> (("plan" Data.Aeson.Types.ToJSON..= subscriptionPlan obj) GHC.Base.<> (("quantity" Data.Aeson.Types.ToJSON..= subscriptionQuantity obj) GHC.Base.<> (("schedule" Data.Aeson.Types.ToJSON..= subscriptionSchedule obj) GHC.Base.<> (("start_date" Data.Aeson.Types.ToJSON..= subscriptionStartDate obj) GHC.Base.<> (("status" Data.Aeson.Types.ToJSON..= subscriptionStatus obj) GHC.Base.<> (("tax_percent" Data.Aeson.Types.ToJSON..= subscriptionTaxPercent obj) GHC.Base.<> (("trial_end" Data.Aeson.Types.ToJSON..= subscriptionTrialEnd obj) GHC.Base.<> (("trial_start" Data.Aeson.Types.ToJSON..= subscriptionTrialStart obj) GHC.Base.<> ("object" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "subscription")))))))))))))))))))))))))))))))))))

instance Data.Aeson.Types.FromJSON.FromJSON Subscription where
  parseJSON = Data.Aeson.Types.FromJSON.withObject "Subscription" (\obj -> (((((((((((((((((((((((((((((((((GHC.Base.pure Subscription GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "application_fee_percent")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "billing_cycle_anchor")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "billing_thresholds")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "cancel_at")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "cancel_at_period_end")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "canceled_at")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "collection_method")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "created")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "current_period_end")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "current_period_start")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "customer")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "days_until_due")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "default_payment_method")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "default_source")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "default_tax_rates")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "discount")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "ended_at")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "items")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "latest_invoice")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "livemode")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "metadata")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "next_pending_invoice_item_invoice")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "pending_invoice_item_interval")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "pending_setup_intent")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "pending_update")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "plan")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "quantity")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "schedule")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "start_date")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "status")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "tax_percent")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "trial_end")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "trial_start"))

-- | Create a new 'Subscription' with all required fields.
mkSubscription ::
  -- | 'subscriptionBillingCycleAnchor'
  GHC.Types.Int ->
  -- | 'subscriptionCancelAtPeriodEnd'
  GHC.Types.Bool ->
  -- | 'subscriptionCreated'
  GHC.Types.Int ->
  -- | 'subscriptionCurrentPeriodEnd'
  GHC.Types.Int ->
  -- | 'subscriptionCurrentPeriodStart'
  GHC.Types.Int ->
  -- | 'subscriptionCustomer'
  SubscriptionCustomer'Variants ->
  -- | 'subscriptionId'
  Data.Text.Internal.Text ->
  -- | 'subscriptionItems'
  SubscriptionItems' ->
  -- | 'subscriptionLivemode'
  GHC.Types.Bool ->
  -- | 'subscriptionMetadata'
  Data.Aeson.Types.Internal.Object ->
  -- | 'subscriptionStartDate'
  GHC.Types.Int ->
  -- | 'subscriptionStatus'
  SubscriptionStatus' ->
  Subscription
mkSubscription subscriptionBillingCycleAnchor subscriptionCancelAtPeriodEnd subscriptionCreated subscriptionCurrentPeriodEnd subscriptionCurrentPeriodStart subscriptionCustomer subscriptionId subscriptionItems subscriptionLivemode subscriptionMetadata subscriptionStartDate subscriptionStatus =
  Subscription
    { subscriptionApplicationFeePercent = GHC.Maybe.Nothing,
      subscriptionBillingCycleAnchor = subscriptionBillingCycleAnchor,
      subscriptionBillingThresholds = GHC.Maybe.Nothing,
      subscriptionCancelAt = GHC.Maybe.Nothing,
      subscriptionCancelAtPeriodEnd = subscriptionCancelAtPeriodEnd,
      subscriptionCanceledAt = GHC.Maybe.Nothing,
      subscriptionCollectionMethod = GHC.Maybe.Nothing,
      subscriptionCreated = subscriptionCreated,
      subscriptionCurrentPeriodEnd = subscriptionCurrentPeriodEnd,
      subscriptionCurrentPeriodStart = subscriptionCurrentPeriodStart,
      subscriptionCustomer = subscriptionCustomer,
      subscriptionDaysUntilDue = GHC.Maybe.Nothing,
      subscriptionDefaultPaymentMethod = GHC.Maybe.Nothing,
      subscriptionDefaultSource = GHC.Maybe.Nothing,
      subscriptionDefaultTaxRates = GHC.Maybe.Nothing,
      subscriptionDiscount = GHC.Maybe.Nothing,
      subscriptionEndedAt = GHC.Maybe.Nothing,
      subscriptionId = subscriptionId,
      subscriptionItems = subscriptionItems,
      subscriptionLatestInvoice = GHC.Maybe.Nothing,
      subscriptionLivemode = subscriptionLivemode,
      subscriptionMetadata = subscriptionMetadata,
      subscriptionNextPendingInvoiceItemInvoice = GHC.Maybe.Nothing,
      subscriptionPendingInvoiceItemInterval = GHC.Maybe.Nothing,
      subscriptionPendingSetupIntent = GHC.Maybe.Nothing,
      subscriptionPendingUpdate = GHC.Maybe.Nothing,
      subscriptionPlan = GHC.Maybe.Nothing,
      subscriptionQuantity = GHC.Maybe.Nothing,
      subscriptionSchedule = GHC.Maybe.Nothing,
      subscriptionStartDate = subscriptionStartDate,
      subscriptionStatus = subscriptionStatus,
      subscriptionTaxPercent = GHC.Maybe.Nothing,
      subscriptionTrialEnd = GHC.Maybe.Nothing,
      subscriptionTrialStart = GHC.Maybe.Nothing
    }

-- | Defines the object schema located at @components.schemas.subscription.properties.billing_thresholds.anyOf@ in the specification.
--
-- Define thresholds at which an invoice will be sent, and the subscription advanced to a new billing period
data SubscriptionBillingThresholds'
  = SubscriptionBillingThresholds'
      { -- | amount_gte: Monetary threshold that triggers the subscription to create an invoice
        subscriptionBillingThresholds'AmountGte :: (GHC.Maybe.Maybe GHC.Types.Int),
        -- | reset_billing_cycle_anchor: Indicates if the \`billing_cycle_anchor\` should be reset when a threshold is reached. If true, \`billing_cycle_anchor\` will be updated to the date\/time the threshold was last reached; otherwise, the value will remain unchanged. This value may not be \`true\` if the subscription contains items with plans that have \`aggregate_usage=last_ever\`.
        subscriptionBillingThresholds'ResetBillingCycleAnchor :: (GHC.Maybe.Maybe GHC.Types.Bool)
      }
  deriving
    ( GHC.Show.Show,
      GHC.Classes.Eq
    )

instance Data.Aeson.Types.ToJSON.ToJSON SubscriptionBillingThresholds' where
  toJSON obj = Data.Aeson.Types.Internal.object ("amount_gte" Data.Aeson.Types.ToJSON..= subscriptionBillingThresholds'AmountGte obj : "reset_billing_cycle_anchor" Data.Aeson.Types.ToJSON..= subscriptionBillingThresholds'ResetBillingCycleAnchor obj : [])
  toEncoding obj = Data.Aeson.Encoding.Internal.pairs (("amount_gte" Data.Aeson.Types.ToJSON..= subscriptionBillingThresholds'AmountGte obj) GHC.Base.<> ("reset_billing_cycle_anchor" Data.Aeson.Types.ToJSON..= subscriptionBillingThresholds'ResetBillingCycleAnchor obj))

instance Data.Aeson.Types.FromJSON.FromJSON SubscriptionBillingThresholds' where
  parseJSON = Data.Aeson.Types.FromJSON.withObject "SubscriptionBillingThresholds'" (\obj -> (GHC.Base.pure SubscriptionBillingThresholds' GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "amount_gte")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "reset_billing_cycle_anchor"))

-- | Create a new 'SubscriptionBillingThresholds'' with all required fields.
mkSubscriptionBillingThresholds' :: SubscriptionBillingThresholds'
mkSubscriptionBillingThresholds' =
  SubscriptionBillingThresholds'
    { subscriptionBillingThresholds'AmountGte = GHC.Maybe.Nothing,
      subscriptionBillingThresholds'ResetBillingCycleAnchor = GHC.Maybe.Nothing
    }

-- | Defines the enum schema located at @components.schemas.subscription.properties.collection_method@ in the specification.
--
-- Either \`charge_automatically\`, or \`send_invoice\`. When charging automatically, Stripe will attempt to pay this subscription at the end of the cycle using the default source attached to the customer. When sending an invoice, Stripe will email your customer an invoice with payment instructions.
data SubscriptionCollectionMethod'
  = -- | This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
    SubscriptionCollectionMethod'Other Data.Aeson.Types.Internal.Value
  | -- | This constructor can be used to send values to the server which are not present in the specification yet.
    SubscriptionCollectionMethod'Typed Data.Text.Internal.Text
  | -- | Represents the JSON value @"charge_automatically"@
    SubscriptionCollectionMethod'EnumChargeAutomatically
  | -- | Represents the JSON value @"send_invoice"@
    SubscriptionCollectionMethod'EnumSendInvoice
  deriving (GHC.Show.Show, GHC.Classes.Eq)

instance Data.Aeson.Types.ToJSON.ToJSON SubscriptionCollectionMethod' where
  toJSON (SubscriptionCollectionMethod'Other val) = val
  toJSON (SubscriptionCollectionMethod'Typed val) = Data.Aeson.Types.ToJSON.toJSON val
  toJSON (SubscriptionCollectionMethod'EnumChargeAutomatically) = "charge_automatically"
  toJSON (SubscriptionCollectionMethod'EnumSendInvoice) = "send_invoice"

instance Data.Aeson.Types.FromJSON.FromJSON SubscriptionCollectionMethod' where
  parseJSON val =
    GHC.Base.pure
      ( if  | val GHC.Classes.== "charge_automatically" -> SubscriptionCollectionMethod'EnumChargeAutomatically
            | val GHC.Classes.== "send_invoice" -> SubscriptionCollectionMethod'EnumSendInvoice
            | GHC.Base.otherwise -> SubscriptionCollectionMethod'Other val
      )

-- | Defines the oneOf schema located at @components.schemas.subscription.properties.customer.anyOf@ in the specification.
--
-- ID of the customer who owns the subscription.
data SubscriptionCustomer'Variants
  = SubscriptionCustomer'Customer Customer
  | SubscriptionCustomer'DeletedCustomer DeletedCustomer
  | SubscriptionCustomer'Text Data.Text.Internal.Text
  deriving (GHC.Show.Show, GHC.Classes.Eq)

instance Data.Aeson.Types.ToJSON.ToJSON SubscriptionCustomer'Variants where
  toJSON (SubscriptionCustomer'Customer a) = Data.Aeson.Types.ToJSON.toJSON a
  toJSON (SubscriptionCustomer'DeletedCustomer a) = Data.Aeson.Types.ToJSON.toJSON a
  toJSON (SubscriptionCustomer'Text a) = Data.Aeson.Types.ToJSON.toJSON a

instance Data.Aeson.Types.FromJSON.FromJSON SubscriptionCustomer'Variants where
  parseJSON val = case (SubscriptionCustomer'Customer Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((SubscriptionCustomer'DeletedCustomer Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((SubscriptionCustomer'Text Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> Data.Aeson.Types.Internal.Error "No variant matched")) of
    Data.Aeson.Types.Internal.Success a -> GHC.Base.pure a
    Data.Aeson.Types.Internal.Error a -> Control.Monad.Fail.fail a

-- | Defines the oneOf schema located at @components.schemas.subscription.properties.default_payment_method.anyOf@ in the specification.
--
-- ID of the default payment method for the subscription. It must belong to the customer associated with the subscription. If not set, invoices will use the default payment method in the customer\'s invoice settings.
data SubscriptionDefaultPaymentMethod'Variants
  = SubscriptionDefaultPaymentMethod'PaymentMethod PaymentMethod
  | SubscriptionDefaultPaymentMethod'Text Data.Text.Internal.Text
  deriving (GHC.Show.Show, GHC.Classes.Eq)

instance Data.Aeson.Types.ToJSON.ToJSON SubscriptionDefaultPaymentMethod'Variants where
  toJSON (SubscriptionDefaultPaymentMethod'PaymentMethod a) = Data.Aeson.Types.ToJSON.toJSON a
  toJSON (SubscriptionDefaultPaymentMethod'Text a) = Data.Aeson.Types.ToJSON.toJSON a

instance Data.Aeson.Types.FromJSON.FromJSON SubscriptionDefaultPaymentMethod'Variants where
  parseJSON val = case (SubscriptionDefaultPaymentMethod'PaymentMethod Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((SubscriptionDefaultPaymentMethod'Text Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> Data.Aeson.Types.Internal.Error "No variant matched") of
    Data.Aeson.Types.Internal.Success a -> GHC.Base.pure a
    Data.Aeson.Types.Internal.Error a -> Control.Monad.Fail.fail a

-- | Defines the oneOf schema located at @components.schemas.subscription.properties.default_source.anyOf@ in the specification.
--
-- ID of the default payment source for the subscription. It must belong to the customer associated with the subscription and be in a chargeable state. If not set, defaults to the customer\'s default source.
data SubscriptionDefaultSource'Variants
  = SubscriptionDefaultSource'AlipayAccount AlipayAccount
  | SubscriptionDefaultSource'BankAccount BankAccount
  | SubscriptionDefaultSource'BitcoinReceiver BitcoinReceiver
  | SubscriptionDefaultSource'Card Card
  | SubscriptionDefaultSource'Source Source
  | SubscriptionDefaultSource'Text Data.Text.Internal.Text
  deriving (GHC.Show.Show, GHC.Classes.Eq)

instance Data.Aeson.Types.ToJSON.ToJSON SubscriptionDefaultSource'Variants where
  toJSON (SubscriptionDefaultSource'AlipayAccount a) = Data.Aeson.Types.ToJSON.toJSON a
  toJSON (SubscriptionDefaultSource'BankAccount a) = Data.Aeson.Types.ToJSON.toJSON a
  toJSON (SubscriptionDefaultSource'BitcoinReceiver a) = Data.Aeson.Types.ToJSON.toJSON a
  toJSON (SubscriptionDefaultSource'Card a) = Data.Aeson.Types.ToJSON.toJSON a
  toJSON (SubscriptionDefaultSource'Source a) = Data.Aeson.Types.ToJSON.toJSON a
  toJSON (SubscriptionDefaultSource'Text a) = Data.Aeson.Types.ToJSON.toJSON a

instance Data.Aeson.Types.FromJSON.FromJSON SubscriptionDefaultSource'Variants where
  parseJSON val = case (SubscriptionDefaultSource'AlipayAccount Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((SubscriptionDefaultSource'BankAccount Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((SubscriptionDefaultSource'BitcoinReceiver Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((SubscriptionDefaultSource'Card Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((SubscriptionDefaultSource'Source Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((SubscriptionDefaultSource'Text Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> Data.Aeson.Types.Internal.Error "No variant matched"))))) of
    Data.Aeson.Types.Internal.Success a -> GHC.Base.pure a
    Data.Aeson.Types.Internal.Error a -> Control.Monad.Fail.fail a

-- | Defines the object schema located at @components.schemas.subscription.properties.discount.anyOf@ in the specification.
--
-- Describes the current discount applied to this subscription, if there is one. When billing, a discount applied to a subscription overrides a discount applied on a customer-wide basis.
data SubscriptionDiscount'
  = SubscriptionDiscount'
      { -- | coupon: A coupon contains information about a percent-off or amount-off discount you
        -- might want to apply to a customer. Coupons may be applied to [invoices](https:\/\/stripe.com\/docs\/api\#invoices) or
        -- [orders](https:\/\/stripe.com\/docs\/api\#create_order-coupon). Coupons do not work with conventional one-off [charges](https:\/\/stripe.com\/docs\/api\#create_charge).
        subscriptionDiscount'Coupon :: (GHC.Maybe.Maybe Coupon),
        -- | customer: The ID of the customer associated with this discount.
        subscriptionDiscount'Customer :: (GHC.Maybe.Maybe SubscriptionDiscount'Customer'Variants),
        -- | end: If the coupon has a duration of \`repeating\`, the date that this discount will end. If the coupon has a duration of \`once\` or \`forever\`, this attribute will be null.
        subscriptionDiscount'End :: (GHC.Maybe.Maybe GHC.Types.Int),
        -- | start: Date that the coupon was applied.
        subscriptionDiscount'Start :: (GHC.Maybe.Maybe GHC.Types.Int),
        -- | subscription: The subscription that this coupon is applied to, if it is applied to a particular subscription.
        --
        -- Constraints:
        --
        -- * Maximum length of 5000
        subscriptionDiscount'Subscription :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
      }
  deriving
    ( GHC.Show.Show,
      GHC.Classes.Eq
    )

instance Data.Aeson.Types.ToJSON.ToJSON SubscriptionDiscount' where
  toJSON obj = Data.Aeson.Types.Internal.object ("coupon" Data.Aeson.Types.ToJSON..= subscriptionDiscount'Coupon obj : "customer" Data.Aeson.Types.ToJSON..= subscriptionDiscount'Customer obj : "end" Data.Aeson.Types.ToJSON..= subscriptionDiscount'End obj : "start" Data.Aeson.Types.ToJSON..= subscriptionDiscount'Start obj : "subscription" Data.Aeson.Types.ToJSON..= subscriptionDiscount'Subscription obj : "object" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "discount" : [])
  toEncoding obj = Data.Aeson.Encoding.Internal.pairs (("coupon" Data.Aeson.Types.ToJSON..= subscriptionDiscount'Coupon obj) GHC.Base.<> (("customer" Data.Aeson.Types.ToJSON..= subscriptionDiscount'Customer obj) GHC.Base.<> (("end" Data.Aeson.Types.ToJSON..= subscriptionDiscount'End obj) GHC.Base.<> (("start" Data.Aeson.Types.ToJSON..= subscriptionDiscount'Start obj) GHC.Base.<> (("subscription" Data.Aeson.Types.ToJSON..= subscriptionDiscount'Subscription obj) GHC.Base.<> ("object" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "discount"))))))

instance Data.Aeson.Types.FromJSON.FromJSON SubscriptionDiscount' where
  parseJSON = Data.Aeson.Types.FromJSON.withObject "SubscriptionDiscount'" (\obj -> ((((GHC.Base.pure SubscriptionDiscount' GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "coupon")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "customer")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "end")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "start")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "subscription"))

-- | Create a new 'SubscriptionDiscount'' with all required fields.
mkSubscriptionDiscount' :: SubscriptionDiscount'
mkSubscriptionDiscount' =
  SubscriptionDiscount'
    { subscriptionDiscount'Coupon = GHC.Maybe.Nothing,
      subscriptionDiscount'Customer = GHC.Maybe.Nothing,
      subscriptionDiscount'End = GHC.Maybe.Nothing,
      subscriptionDiscount'Start = GHC.Maybe.Nothing,
      subscriptionDiscount'Subscription = GHC.Maybe.Nothing
    }

-- | Defines the oneOf schema located at @components.schemas.subscription.properties.discount.anyOf.properties.customer.anyOf@ in the specification.
--
-- The ID of the customer associated with this discount.
data SubscriptionDiscount'Customer'Variants
  = SubscriptionDiscount'Customer'Customer Customer
  | SubscriptionDiscount'Customer'DeletedCustomer DeletedCustomer
  | SubscriptionDiscount'Customer'Text Data.Text.Internal.Text
  deriving (GHC.Show.Show, GHC.Classes.Eq)

instance Data.Aeson.Types.ToJSON.ToJSON SubscriptionDiscount'Customer'Variants where
  toJSON (SubscriptionDiscount'Customer'Customer a) = Data.Aeson.Types.ToJSON.toJSON a
  toJSON (SubscriptionDiscount'Customer'DeletedCustomer a) = Data.Aeson.Types.ToJSON.toJSON a
  toJSON (SubscriptionDiscount'Customer'Text a) = Data.Aeson.Types.ToJSON.toJSON a

instance Data.Aeson.Types.FromJSON.FromJSON SubscriptionDiscount'Customer'Variants where
  parseJSON val = case (SubscriptionDiscount'Customer'Customer Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((SubscriptionDiscount'Customer'DeletedCustomer Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((SubscriptionDiscount'Customer'Text Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> Data.Aeson.Types.Internal.Error "No variant matched")) of
    Data.Aeson.Types.Internal.Success a -> GHC.Base.pure a
    Data.Aeson.Types.Internal.Error a -> Control.Monad.Fail.fail a

-- | Defines the object schema located at @components.schemas.subscription.properties.items@ in the specification.
--
-- List of subscription items, each with an attached plan.
data SubscriptionItems'
  = SubscriptionItems'
      { -- | data: Details about each object.
        subscriptionItems'Data :: ([SubscriptionItem]),
        -- | has_more: True if this list has another page of items after this one that can be fetched.
        subscriptionItems'HasMore :: GHC.Types.Bool,
        -- | url: The URL where this list can be accessed.
        --
        -- Constraints:
        --
        -- * Maximum length of 5000
        subscriptionItems'Url :: Data.Text.Internal.Text
      }
  deriving
    ( GHC.Show.Show,
      GHC.Classes.Eq
    )

instance Data.Aeson.Types.ToJSON.ToJSON SubscriptionItems' where
  toJSON obj = Data.Aeson.Types.Internal.object ("data" Data.Aeson.Types.ToJSON..= subscriptionItems'Data obj : "has_more" Data.Aeson.Types.ToJSON..= subscriptionItems'HasMore obj : "url" Data.Aeson.Types.ToJSON..= subscriptionItems'Url obj : "object" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "list" : [])
  toEncoding obj = Data.Aeson.Encoding.Internal.pairs (("data" Data.Aeson.Types.ToJSON..= subscriptionItems'Data obj) GHC.Base.<> (("has_more" Data.Aeson.Types.ToJSON..= subscriptionItems'HasMore obj) GHC.Base.<> (("url" Data.Aeson.Types.ToJSON..= subscriptionItems'Url obj) GHC.Base.<> ("object" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "list"))))

instance Data.Aeson.Types.FromJSON.FromJSON SubscriptionItems' where
  parseJSON = Data.Aeson.Types.FromJSON.withObject "SubscriptionItems'" (\obj -> ((GHC.Base.pure SubscriptionItems' GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "data")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "has_more")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "url"))

-- | Create a new 'SubscriptionItems'' with all required fields.
mkSubscriptionItems' ::
  -- | 'subscriptionItems'Data'
  [SubscriptionItem] ->
  -- | 'subscriptionItems'HasMore'
  GHC.Types.Bool ->
  -- | 'subscriptionItems'Url'
  Data.Text.Internal.Text ->
  SubscriptionItems'
mkSubscriptionItems' subscriptionItems'Data subscriptionItems'HasMore subscriptionItems'Url =
  SubscriptionItems'
    { subscriptionItems'Data = subscriptionItems'Data,
      subscriptionItems'HasMore = subscriptionItems'HasMore,
      subscriptionItems'Url = subscriptionItems'Url
    }

-- | Defines the oneOf schema located at @components.schemas.subscription.properties.latest_invoice.anyOf@ in the specification.
--
-- The most recent invoice this subscription has generated.
data SubscriptionLatestInvoice'Variants
  = SubscriptionLatestInvoice'Invoice Invoice
  | SubscriptionLatestInvoice'Text Data.Text.Internal.Text
  deriving (GHC.Show.Show, GHC.Classes.Eq)

instance Data.Aeson.Types.ToJSON.ToJSON SubscriptionLatestInvoice'Variants where
  toJSON (SubscriptionLatestInvoice'Invoice a) = Data.Aeson.Types.ToJSON.toJSON a
  toJSON (SubscriptionLatestInvoice'Text a) = Data.Aeson.Types.ToJSON.toJSON a

instance Data.Aeson.Types.FromJSON.FromJSON SubscriptionLatestInvoice'Variants where
  parseJSON val = case (SubscriptionLatestInvoice'Invoice Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((SubscriptionLatestInvoice'Text Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> Data.Aeson.Types.Internal.Error "No variant matched") of
    Data.Aeson.Types.Internal.Success a -> GHC.Base.pure a
    Data.Aeson.Types.Internal.Error a -> Control.Monad.Fail.fail a

-- | Defines the object schema located at @components.schemas.subscription.properties.pending_invoice_item_interval.anyOf@ in the specification.
--
-- Specifies an interval for how often to bill for any pending invoice items. It is analogous to calling [Create an invoice](https:\\\/\\\/stripe.com\\\/docs\\\/api\\\#create_invoice) for the given subscription at the specified interval.
data SubscriptionPendingInvoiceItemInterval'
  = SubscriptionPendingInvoiceItemInterval'
      { -- | interval: Specifies invoicing frequency. Either \`day\`, \`week\`, \`month\` or \`year\`.
        subscriptionPendingInvoiceItemInterval'Interval :: (GHC.Maybe.Maybe SubscriptionPendingInvoiceItemInterval'Interval'),
        -- | interval_count: The number of intervals between invoices. For example, \`interval=month\` and \`interval_count=3\` bills every 3 months. Maximum of one year interval allowed (1 year, 12 months, or 52 weeks).
        subscriptionPendingInvoiceItemInterval'IntervalCount :: (GHC.Maybe.Maybe GHC.Types.Int)
      }
  deriving
    ( GHC.Show.Show,
      GHC.Classes.Eq
    )

instance Data.Aeson.Types.ToJSON.ToJSON SubscriptionPendingInvoiceItemInterval' where
  toJSON obj = Data.Aeson.Types.Internal.object ("interval" Data.Aeson.Types.ToJSON..= subscriptionPendingInvoiceItemInterval'Interval obj : "interval_count" Data.Aeson.Types.ToJSON..= subscriptionPendingInvoiceItemInterval'IntervalCount obj : [])
  toEncoding obj = Data.Aeson.Encoding.Internal.pairs (("interval" Data.Aeson.Types.ToJSON..= subscriptionPendingInvoiceItemInterval'Interval obj) GHC.Base.<> ("interval_count" Data.Aeson.Types.ToJSON..= subscriptionPendingInvoiceItemInterval'IntervalCount obj))

instance Data.Aeson.Types.FromJSON.FromJSON SubscriptionPendingInvoiceItemInterval' where
  parseJSON = Data.Aeson.Types.FromJSON.withObject "SubscriptionPendingInvoiceItemInterval'" (\obj -> (GHC.Base.pure SubscriptionPendingInvoiceItemInterval' GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "interval")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "interval_count"))

-- | Create a new 'SubscriptionPendingInvoiceItemInterval'' with all required fields.
mkSubscriptionPendingInvoiceItemInterval' :: SubscriptionPendingInvoiceItemInterval'
mkSubscriptionPendingInvoiceItemInterval' =
  SubscriptionPendingInvoiceItemInterval'
    { subscriptionPendingInvoiceItemInterval'Interval = GHC.Maybe.Nothing,
      subscriptionPendingInvoiceItemInterval'IntervalCount = GHC.Maybe.Nothing
    }

-- | Defines the enum schema located at @components.schemas.subscription.properties.pending_invoice_item_interval.anyOf.properties.interval@ in the specification.
--
-- Specifies invoicing frequency. Either \`day\`, \`week\`, \`month\` or \`year\`.
data SubscriptionPendingInvoiceItemInterval'Interval'
  = -- | This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
    SubscriptionPendingInvoiceItemInterval'Interval'Other Data.Aeson.Types.Internal.Value
  | -- | This constructor can be used to send values to the server which are not present in the specification yet.
    SubscriptionPendingInvoiceItemInterval'Interval'Typed Data.Text.Internal.Text
  | -- | Represents the JSON value @"day"@
    SubscriptionPendingInvoiceItemInterval'Interval'EnumDay
  | -- | Represents the JSON value @"month"@
    SubscriptionPendingInvoiceItemInterval'Interval'EnumMonth
  | -- | Represents the JSON value @"week"@
    SubscriptionPendingInvoiceItemInterval'Interval'EnumWeek
  | -- | Represents the JSON value @"year"@
    SubscriptionPendingInvoiceItemInterval'Interval'EnumYear
  deriving (GHC.Show.Show, GHC.Classes.Eq)

instance Data.Aeson.Types.ToJSON.ToJSON SubscriptionPendingInvoiceItemInterval'Interval' where
  toJSON (SubscriptionPendingInvoiceItemInterval'Interval'Other val) = val
  toJSON (SubscriptionPendingInvoiceItemInterval'Interval'Typed val) = Data.Aeson.Types.ToJSON.toJSON val
  toJSON (SubscriptionPendingInvoiceItemInterval'Interval'EnumDay) = "day"
  toJSON (SubscriptionPendingInvoiceItemInterval'Interval'EnumMonth) = "month"
  toJSON (SubscriptionPendingInvoiceItemInterval'Interval'EnumWeek) = "week"
  toJSON (SubscriptionPendingInvoiceItemInterval'Interval'EnumYear) = "year"

instance Data.Aeson.Types.FromJSON.FromJSON SubscriptionPendingInvoiceItemInterval'Interval' where
  parseJSON val =
    GHC.Base.pure
      ( if  | val GHC.Classes.== "day" -> SubscriptionPendingInvoiceItemInterval'Interval'EnumDay
            | val GHC.Classes.== "month" -> SubscriptionPendingInvoiceItemInterval'Interval'EnumMonth
            | val GHC.Classes.== "week" -> SubscriptionPendingInvoiceItemInterval'Interval'EnumWeek
            | val GHC.Classes.== "year" -> SubscriptionPendingInvoiceItemInterval'Interval'EnumYear
            | GHC.Base.otherwise -> SubscriptionPendingInvoiceItemInterval'Interval'Other val
      )

-- | Defines the oneOf schema located at @components.schemas.subscription.properties.pending_setup_intent.anyOf@ in the specification.
--
-- You can use this [SetupIntent](https:\/\/stripe.com\/docs\/api\/setup_intents) to collect user authentication when creating a subscription without immediate payment or updating a subscription\'s payment method, allowing you to optimize for off-session payments. Learn more in the [SCA Migration Guide](https:\/\/stripe.com\/docs\/billing\/migration\/strong-customer-authentication\#scenario-2).
data SubscriptionPendingSetupIntent'Variants
  = SubscriptionPendingSetupIntent'SetupIntent SetupIntent
  | SubscriptionPendingSetupIntent'Text Data.Text.Internal.Text
  deriving (GHC.Show.Show, GHC.Classes.Eq)

instance Data.Aeson.Types.ToJSON.ToJSON SubscriptionPendingSetupIntent'Variants where
  toJSON (SubscriptionPendingSetupIntent'SetupIntent a) = Data.Aeson.Types.ToJSON.toJSON a
  toJSON (SubscriptionPendingSetupIntent'Text a) = Data.Aeson.Types.ToJSON.toJSON a

instance Data.Aeson.Types.FromJSON.FromJSON SubscriptionPendingSetupIntent'Variants where
  parseJSON val = case (SubscriptionPendingSetupIntent'SetupIntent Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((SubscriptionPendingSetupIntent'Text Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> Data.Aeson.Types.Internal.Error "No variant matched") of
    Data.Aeson.Types.Internal.Success a -> GHC.Base.pure a
    Data.Aeson.Types.Internal.Error a -> Control.Monad.Fail.fail a

-- | Defines the object schema located at @components.schemas.subscription.properties.pending_update.anyOf@ in the specification.
--
-- If specified, [pending updates](https:\\\/\\\/stripe.com\\\/docs\\\/billing\\\/subscriptions\\\/pending-updates) that will be applied to the subscription once the \\\`latest_invoice\\\` has been paid.
data SubscriptionPendingUpdate'
  = SubscriptionPendingUpdate'
      { -- | billing_cycle_anchor: If the update is applied, determines the date of the first full invoice, and, for plans with \`month\` or \`year\` intervals, the day of the month for subsequent invoices.
        subscriptionPendingUpdate'BillingCycleAnchor :: (GHC.Maybe.Maybe GHC.Types.Int),
        -- | expires_at: The point after which the changes reflected by this update will be discarded and no longer applied.
        subscriptionPendingUpdate'ExpiresAt :: (GHC.Maybe.Maybe GHC.Types.Int),
        -- | subscription_items: List of subscription items, each with an attached plan, that will be set if the update is applied.
        subscriptionPendingUpdate'SubscriptionItems :: (GHC.Maybe.Maybe ([SubscriptionItem])),
        -- | trial_end: Unix timestamp representing the end of the trial period the customer will get before being charged for the first time, if the update is applied.
        subscriptionPendingUpdate'TrialEnd :: (GHC.Maybe.Maybe GHC.Types.Int),
        -- | trial_from_plan: Indicates if a plan\'s \`trial_period_days\` should be applied to the subscription. Setting \`trial_end\` per subscription is preferred, and this defaults to \`false\`. Setting this flag to \`true\` together with \`trial_end\` is not allowed.
        subscriptionPendingUpdate'TrialFromPlan :: (GHC.Maybe.Maybe GHC.Types.Bool)
      }
  deriving
    ( GHC.Show.Show,
      GHC.Classes.Eq
    )

instance Data.Aeson.Types.ToJSON.ToJSON SubscriptionPendingUpdate' where
  toJSON obj = Data.Aeson.Types.Internal.object ("billing_cycle_anchor" Data.Aeson.Types.ToJSON..= subscriptionPendingUpdate'BillingCycleAnchor obj : "expires_at" Data.Aeson.Types.ToJSON..= subscriptionPendingUpdate'ExpiresAt obj : "subscription_items" Data.Aeson.Types.ToJSON..= subscriptionPendingUpdate'SubscriptionItems obj : "trial_end" Data.Aeson.Types.ToJSON..= subscriptionPendingUpdate'TrialEnd obj : "trial_from_plan" Data.Aeson.Types.ToJSON..= subscriptionPendingUpdate'TrialFromPlan obj : [])
  toEncoding obj = Data.Aeson.Encoding.Internal.pairs (("billing_cycle_anchor" Data.Aeson.Types.ToJSON..= subscriptionPendingUpdate'BillingCycleAnchor obj) GHC.Base.<> (("expires_at" Data.Aeson.Types.ToJSON..= subscriptionPendingUpdate'ExpiresAt obj) GHC.Base.<> (("subscription_items" Data.Aeson.Types.ToJSON..= subscriptionPendingUpdate'SubscriptionItems obj) GHC.Base.<> (("trial_end" Data.Aeson.Types.ToJSON..= subscriptionPendingUpdate'TrialEnd obj) GHC.Base.<> ("trial_from_plan" Data.Aeson.Types.ToJSON..= subscriptionPendingUpdate'TrialFromPlan obj)))))

instance Data.Aeson.Types.FromJSON.FromJSON SubscriptionPendingUpdate' where
  parseJSON = Data.Aeson.Types.FromJSON.withObject "SubscriptionPendingUpdate'" (\obj -> ((((GHC.Base.pure SubscriptionPendingUpdate' GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "billing_cycle_anchor")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "expires_at")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "subscription_items")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "trial_end")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "trial_from_plan"))

-- | Create a new 'SubscriptionPendingUpdate'' with all required fields.
mkSubscriptionPendingUpdate' :: SubscriptionPendingUpdate'
mkSubscriptionPendingUpdate' =
  SubscriptionPendingUpdate'
    { subscriptionPendingUpdate'BillingCycleAnchor = GHC.Maybe.Nothing,
      subscriptionPendingUpdate'ExpiresAt = GHC.Maybe.Nothing,
      subscriptionPendingUpdate'SubscriptionItems = GHC.Maybe.Nothing,
      subscriptionPendingUpdate'TrialEnd = GHC.Maybe.Nothing,
      subscriptionPendingUpdate'TrialFromPlan = GHC.Maybe.Nothing
    }

-- | Defines the object schema located at @components.schemas.subscription.properties.plan.anyOf@ in the specification.
--
-- Hash describing the plan the customer is subscribed to. Only set if the subscription contains a single plan.
data SubscriptionPlan'
  = SubscriptionPlan'
      { -- | active: Whether the plan is currently available for new subscriptions.
        subscriptionPlan'Active :: (GHC.Maybe.Maybe GHC.Types.Bool),
        -- | aggregate_usage: Specifies a usage aggregation strategy for plans of \`usage_type=metered\`. Allowed values are \`sum\` for summing up all usage during a period, \`last_during_period\` for using the last usage record reported within a period, \`last_ever\` for using the last usage record ever (across period bounds) or \`max\` which uses the usage record with the maximum reported usage during a period. Defaults to \`sum\`.
        subscriptionPlan'AggregateUsage :: (GHC.Maybe.Maybe SubscriptionPlan'AggregateUsage'),
        -- | amount: The amount in %s to be charged on the interval specified.
        subscriptionPlan'Amount :: (GHC.Maybe.Maybe GHC.Types.Int),
        -- | amount_decimal: Same as \`amount\`, but contains a decimal value with at most 12 decimal places.
        subscriptionPlan'AmountDecimal :: (GHC.Maybe.Maybe Data.Text.Internal.Text),
        -- | billing_scheme: Describes how to compute the price per period. Either \`per_unit\` or \`tiered\`. \`per_unit\` indicates that the fixed amount (specified in \`amount\`) will be charged per unit in \`quantity\` (for plans with \`usage_type=licensed\`), or per unit of total usage (for plans with \`usage_type=metered\`). \`tiered\` indicates that the unit pricing will be computed using a tiering strategy as defined using the \`tiers\` and \`tiers_mode\` attributes.
        subscriptionPlan'BillingScheme :: (GHC.Maybe.Maybe SubscriptionPlan'BillingScheme'),
        -- | created: Time at which the object was created. Measured in seconds since the Unix epoch.
        subscriptionPlan'Created :: (GHC.Maybe.Maybe GHC.Types.Int),
        -- | currency: Three-letter [ISO currency code](https:\/\/www.iso.org\/iso-4217-currency-codes.html), in lowercase. Must be a [supported currency](https:\/\/stripe.com\/docs\/currencies).
        subscriptionPlan'Currency :: (GHC.Maybe.Maybe Data.Text.Internal.Text),
        -- | id: Unique identifier for the object.
        --
        -- Constraints:
        --
        -- * Maximum length of 5000
        subscriptionPlan'Id :: (GHC.Maybe.Maybe Data.Text.Internal.Text),
        -- | interval: The frequency at which a subscription is billed. One of \`day\`, \`week\`, \`month\` or \`year\`.
        subscriptionPlan'Interval :: (GHC.Maybe.Maybe SubscriptionPlan'Interval'),
        -- | interval_count: The number of intervals (specified in the \`interval\` attribute) between subscription billings. For example, \`interval=month\` and \`interval_count=3\` bills every 3 months.
        subscriptionPlan'IntervalCount :: (GHC.Maybe.Maybe GHC.Types.Int),
        -- | livemode: Has the value \`true\` if the object exists in live mode or the value \`false\` if the object exists in test mode.
        subscriptionPlan'Livemode :: (GHC.Maybe.Maybe GHC.Types.Bool),
        -- | metadata: Set of key-value pairs that you can attach to an object. This can be useful for storing additional information about the object in a structured format.
        subscriptionPlan'Metadata :: (GHC.Maybe.Maybe Data.Aeson.Types.Internal.Object),
        -- | nickname: A brief description of the plan, hidden from customers.
        --
        -- Constraints:
        --
        -- * Maximum length of 5000
        subscriptionPlan'Nickname :: (GHC.Maybe.Maybe Data.Text.Internal.Text),
        -- | product: The product whose pricing this plan determines.
        subscriptionPlan'Product :: (GHC.Maybe.Maybe SubscriptionPlan'Product'Variants),
        -- | tiers: Each element represents a pricing tier. This parameter requires \`billing_scheme\` to be set to \`tiered\`. See also the documentation for \`billing_scheme\`.
        subscriptionPlan'Tiers :: (GHC.Maybe.Maybe ([PlanTier])),
        -- | tiers_mode: Defines if the tiering price should be \`graduated\` or \`volume\` based. In \`volume\`-based tiering, the maximum quantity within a period determines the per unit price. In \`graduated\` tiering, pricing can change as the quantity grows.
        subscriptionPlan'TiersMode :: (GHC.Maybe.Maybe SubscriptionPlan'TiersMode'),
        -- | transform_usage: Apply a transformation to the reported usage or set quantity before computing the amount billed. Cannot be combined with \`tiers\`.
        subscriptionPlan'TransformUsage :: (GHC.Maybe.Maybe SubscriptionPlan'TransformUsage'),
        -- | trial_period_days: Default number of trial days when subscribing a customer to this plan using [\`trial_from_plan=true\`](https:\/\/stripe.com\/docs\/api\#create_subscription-trial_from_plan).
        subscriptionPlan'TrialPeriodDays :: (GHC.Maybe.Maybe GHC.Types.Int),
        -- | usage_type: Configures how the quantity per period should be determined. Can be either \`metered\` or \`licensed\`. \`licensed\` automatically bills the \`quantity\` set when adding it to a subscription. \`metered\` aggregates the total usage based on usage records. Defaults to \`licensed\`.
        subscriptionPlan'UsageType :: (GHC.Maybe.Maybe SubscriptionPlan'UsageType')
      }
  deriving
    ( GHC.Show.Show,
      GHC.Classes.Eq
    )

instance Data.Aeson.Types.ToJSON.ToJSON SubscriptionPlan' where
  toJSON obj = Data.Aeson.Types.Internal.object ("active" Data.Aeson.Types.ToJSON..= subscriptionPlan'Active obj : "aggregate_usage" Data.Aeson.Types.ToJSON..= subscriptionPlan'AggregateUsage obj : "amount" Data.Aeson.Types.ToJSON..= subscriptionPlan'Amount obj : "amount_decimal" Data.Aeson.Types.ToJSON..= subscriptionPlan'AmountDecimal obj : "billing_scheme" Data.Aeson.Types.ToJSON..= subscriptionPlan'BillingScheme obj : "created" Data.Aeson.Types.ToJSON..= subscriptionPlan'Created obj : "currency" Data.Aeson.Types.ToJSON..= subscriptionPlan'Currency obj : "id" Data.Aeson.Types.ToJSON..= subscriptionPlan'Id obj : "interval" Data.Aeson.Types.ToJSON..= subscriptionPlan'Interval obj : "interval_count" Data.Aeson.Types.ToJSON..= subscriptionPlan'IntervalCount obj : "livemode" Data.Aeson.Types.ToJSON..= subscriptionPlan'Livemode obj : "metadata" Data.Aeson.Types.ToJSON..= subscriptionPlan'Metadata obj : "nickname" Data.Aeson.Types.ToJSON..= subscriptionPlan'Nickname obj : "product" Data.Aeson.Types.ToJSON..= subscriptionPlan'Product obj : "tiers" Data.Aeson.Types.ToJSON..= subscriptionPlan'Tiers obj : "tiers_mode" Data.Aeson.Types.ToJSON..= subscriptionPlan'TiersMode obj : "transform_usage" Data.Aeson.Types.ToJSON..= subscriptionPlan'TransformUsage obj : "trial_period_days" Data.Aeson.Types.ToJSON..= subscriptionPlan'TrialPeriodDays obj : "usage_type" Data.Aeson.Types.ToJSON..= subscriptionPlan'UsageType obj : "object" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "plan" : [])
  toEncoding obj = Data.Aeson.Encoding.Internal.pairs (("active" Data.Aeson.Types.ToJSON..= subscriptionPlan'Active obj) GHC.Base.<> (("aggregate_usage" Data.Aeson.Types.ToJSON..= subscriptionPlan'AggregateUsage obj) GHC.Base.<> (("amount" Data.Aeson.Types.ToJSON..= subscriptionPlan'Amount obj) GHC.Base.<> (("amount_decimal" Data.Aeson.Types.ToJSON..= subscriptionPlan'AmountDecimal obj) GHC.Base.<> (("billing_scheme" Data.Aeson.Types.ToJSON..= subscriptionPlan'BillingScheme obj) GHC.Base.<> (("created" Data.Aeson.Types.ToJSON..= subscriptionPlan'Created obj) GHC.Base.<> (("currency" Data.Aeson.Types.ToJSON..= subscriptionPlan'Currency obj) GHC.Base.<> (("id" Data.Aeson.Types.ToJSON..= subscriptionPlan'Id obj) GHC.Base.<> (("interval" Data.Aeson.Types.ToJSON..= subscriptionPlan'Interval obj) GHC.Base.<> (("interval_count" Data.Aeson.Types.ToJSON..= subscriptionPlan'IntervalCount obj) GHC.Base.<> (("livemode" Data.Aeson.Types.ToJSON..= subscriptionPlan'Livemode obj) GHC.Base.<> (("metadata" Data.Aeson.Types.ToJSON..= subscriptionPlan'Metadata obj) GHC.Base.<> (("nickname" Data.Aeson.Types.ToJSON..= subscriptionPlan'Nickname obj) GHC.Base.<> (("product" Data.Aeson.Types.ToJSON..= subscriptionPlan'Product obj) GHC.Base.<> (("tiers" Data.Aeson.Types.ToJSON..= subscriptionPlan'Tiers obj) GHC.Base.<> (("tiers_mode" Data.Aeson.Types.ToJSON..= subscriptionPlan'TiersMode obj) GHC.Base.<> (("transform_usage" Data.Aeson.Types.ToJSON..= subscriptionPlan'TransformUsage obj) GHC.Base.<> (("trial_period_days" Data.Aeson.Types.ToJSON..= subscriptionPlan'TrialPeriodDays obj) GHC.Base.<> (("usage_type" Data.Aeson.Types.ToJSON..= subscriptionPlan'UsageType obj) GHC.Base.<> ("object" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "plan"))))))))))))))))))))

instance Data.Aeson.Types.FromJSON.FromJSON SubscriptionPlan' where
  parseJSON = Data.Aeson.Types.FromJSON.withObject "SubscriptionPlan'" (\obj -> ((((((((((((((((((GHC.Base.pure SubscriptionPlan' GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "active")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "aggregate_usage")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "amount")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "amount_decimal")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "billing_scheme")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "created")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "currency")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "interval")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "interval_count")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "livemode")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "metadata")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "nickname")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "product")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "tiers")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "tiers_mode")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "transform_usage")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "trial_period_days")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "usage_type"))

-- | Create a new 'SubscriptionPlan'' with all required fields.
mkSubscriptionPlan' :: SubscriptionPlan'
mkSubscriptionPlan' =
  SubscriptionPlan'
    { subscriptionPlan'Active = GHC.Maybe.Nothing,
      subscriptionPlan'AggregateUsage = GHC.Maybe.Nothing,
      subscriptionPlan'Amount = GHC.Maybe.Nothing,
      subscriptionPlan'AmountDecimal = GHC.Maybe.Nothing,
      subscriptionPlan'BillingScheme = GHC.Maybe.Nothing,
      subscriptionPlan'Created = GHC.Maybe.Nothing,
      subscriptionPlan'Currency = GHC.Maybe.Nothing,
      subscriptionPlan'Id = GHC.Maybe.Nothing,
      subscriptionPlan'Interval = GHC.Maybe.Nothing,
      subscriptionPlan'IntervalCount = GHC.Maybe.Nothing,
      subscriptionPlan'Livemode = GHC.Maybe.Nothing,
      subscriptionPlan'Metadata = GHC.Maybe.Nothing,
      subscriptionPlan'Nickname = GHC.Maybe.Nothing,
      subscriptionPlan'Product = GHC.Maybe.Nothing,
      subscriptionPlan'Tiers = GHC.Maybe.Nothing,
      subscriptionPlan'TiersMode = GHC.Maybe.Nothing,
      subscriptionPlan'TransformUsage = GHC.Maybe.Nothing,
      subscriptionPlan'TrialPeriodDays = GHC.Maybe.Nothing,
      subscriptionPlan'UsageType = GHC.Maybe.Nothing
    }

-- | Defines the enum schema located at @components.schemas.subscription.properties.plan.anyOf.properties.aggregate_usage@ in the specification.
--
-- Specifies a usage aggregation strategy for plans of \`usage_type=metered\`. Allowed values are \`sum\` for summing up all usage during a period, \`last_during_period\` for using the last usage record reported within a period, \`last_ever\` for using the last usage record ever (across period bounds) or \`max\` which uses the usage record with the maximum reported usage during a period. Defaults to \`sum\`.
data SubscriptionPlan'AggregateUsage'
  = -- | This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
    SubscriptionPlan'AggregateUsage'Other Data.Aeson.Types.Internal.Value
  | -- | This constructor can be used to send values to the server which are not present in the specification yet.
    SubscriptionPlan'AggregateUsage'Typed Data.Text.Internal.Text
  | -- | Represents the JSON value @"last_during_period"@
    SubscriptionPlan'AggregateUsage'EnumLastDuringPeriod
  | -- | Represents the JSON value @"last_ever"@
    SubscriptionPlan'AggregateUsage'EnumLastEver
  | -- | Represents the JSON value @"max"@
    SubscriptionPlan'AggregateUsage'EnumMax
  | -- | Represents the JSON value @"sum"@
    SubscriptionPlan'AggregateUsage'EnumSum
  deriving (GHC.Show.Show, GHC.Classes.Eq)

instance Data.Aeson.Types.ToJSON.ToJSON SubscriptionPlan'AggregateUsage' where
  toJSON (SubscriptionPlan'AggregateUsage'Other val) = val
  toJSON (SubscriptionPlan'AggregateUsage'Typed val) = Data.Aeson.Types.ToJSON.toJSON val
  toJSON (SubscriptionPlan'AggregateUsage'EnumLastDuringPeriod) = "last_during_period"
  toJSON (SubscriptionPlan'AggregateUsage'EnumLastEver) = "last_ever"
  toJSON (SubscriptionPlan'AggregateUsage'EnumMax) = "max"
  toJSON (SubscriptionPlan'AggregateUsage'EnumSum) = "sum"

instance Data.Aeson.Types.FromJSON.FromJSON SubscriptionPlan'AggregateUsage' where
  parseJSON val =
    GHC.Base.pure
      ( if  | val GHC.Classes.== "last_during_period" -> SubscriptionPlan'AggregateUsage'EnumLastDuringPeriod
            | val GHC.Classes.== "last_ever" -> SubscriptionPlan'AggregateUsage'EnumLastEver
            | val GHC.Classes.== "max" -> SubscriptionPlan'AggregateUsage'EnumMax
            | val GHC.Classes.== "sum" -> SubscriptionPlan'AggregateUsage'EnumSum
            | GHC.Base.otherwise -> SubscriptionPlan'AggregateUsage'Other val
      )

-- | Defines the enum schema located at @components.schemas.subscription.properties.plan.anyOf.properties.billing_scheme@ in the specification.
--
-- Describes how to compute the price per period. Either \`per_unit\` or \`tiered\`. \`per_unit\` indicates that the fixed amount (specified in \`amount\`) will be charged per unit in \`quantity\` (for plans with \`usage_type=licensed\`), or per unit of total usage (for plans with \`usage_type=metered\`). \`tiered\` indicates that the unit pricing will be computed using a tiering strategy as defined using the \`tiers\` and \`tiers_mode\` attributes.
data SubscriptionPlan'BillingScheme'
  = -- | This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
    SubscriptionPlan'BillingScheme'Other Data.Aeson.Types.Internal.Value
  | -- | This constructor can be used to send values to the server which are not present in the specification yet.
    SubscriptionPlan'BillingScheme'Typed Data.Text.Internal.Text
  | -- | Represents the JSON value @"per_unit"@
    SubscriptionPlan'BillingScheme'EnumPerUnit
  | -- | Represents the JSON value @"tiered"@
    SubscriptionPlan'BillingScheme'EnumTiered
  deriving (GHC.Show.Show, GHC.Classes.Eq)

instance Data.Aeson.Types.ToJSON.ToJSON SubscriptionPlan'BillingScheme' where
  toJSON (SubscriptionPlan'BillingScheme'Other val) = val
  toJSON (SubscriptionPlan'BillingScheme'Typed val) = Data.Aeson.Types.ToJSON.toJSON val
  toJSON (SubscriptionPlan'BillingScheme'EnumPerUnit) = "per_unit"
  toJSON (SubscriptionPlan'BillingScheme'EnumTiered) = "tiered"

instance Data.Aeson.Types.FromJSON.FromJSON SubscriptionPlan'BillingScheme' where
  parseJSON val =
    GHC.Base.pure
      ( if  | val GHC.Classes.== "per_unit" -> SubscriptionPlan'BillingScheme'EnumPerUnit
            | val GHC.Classes.== "tiered" -> SubscriptionPlan'BillingScheme'EnumTiered
            | GHC.Base.otherwise -> SubscriptionPlan'BillingScheme'Other val
      )

-- | Defines the enum schema located at @components.schemas.subscription.properties.plan.anyOf.properties.interval@ in the specification.
--
-- The frequency at which a subscription is billed. One of \`day\`, \`week\`, \`month\` or \`year\`.
data SubscriptionPlan'Interval'
  = -- | This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
    SubscriptionPlan'Interval'Other Data.Aeson.Types.Internal.Value
  | -- | This constructor can be used to send values to the server which are not present in the specification yet.
    SubscriptionPlan'Interval'Typed Data.Text.Internal.Text
  | -- | Represents the JSON value @"day"@
    SubscriptionPlan'Interval'EnumDay
  | -- | Represents the JSON value @"month"@
    SubscriptionPlan'Interval'EnumMonth
  | -- | Represents the JSON value @"week"@
    SubscriptionPlan'Interval'EnumWeek
  | -- | Represents the JSON value @"year"@
    SubscriptionPlan'Interval'EnumYear
  deriving (GHC.Show.Show, GHC.Classes.Eq)

instance Data.Aeson.Types.ToJSON.ToJSON SubscriptionPlan'Interval' where
  toJSON (SubscriptionPlan'Interval'Other val) = val
  toJSON (SubscriptionPlan'Interval'Typed val) = Data.Aeson.Types.ToJSON.toJSON val
  toJSON (SubscriptionPlan'Interval'EnumDay) = "day"
  toJSON (SubscriptionPlan'Interval'EnumMonth) = "month"
  toJSON (SubscriptionPlan'Interval'EnumWeek) = "week"
  toJSON (SubscriptionPlan'Interval'EnumYear) = "year"

instance Data.Aeson.Types.FromJSON.FromJSON SubscriptionPlan'Interval' where
  parseJSON val =
    GHC.Base.pure
      ( if  | val GHC.Classes.== "day" -> SubscriptionPlan'Interval'EnumDay
            | val GHC.Classes.== "month" -> SubscriptionPlan'Interval'EnumMonth
            | val GHC.Classes.== "week" -> SubscriptionPlan'Interval'EnumWeek
            | val GHC.Classes.== "year" -> SubscriptionPlan'Interval'EnumYear
            | GHC.Base.otherwise -> SubscriptionPlan'Interval'Other val
      )

-- | Defines the oneOf schema located at @components.schemas.subscription.properties.plan.anyOf.properties.product.anyOf@ in the specification.
--
-- The product whose pricing this plan determines.
data SubscriptionPlan'Product'Variants
  = SubscriptionPlan'Product'DeletedProduct DeletedProduct
  | SubscriptionPlan'Product'Product Product
  | SubscriptionPlan'Product'Text Data.Text.Internal.Text
  deriving (GHC.Show.Show, GHC.Classes.Eq)

instance Data.Aeson.Types.ToJSON.ToJSON SubscriptionPlan'Product'Variants where
  toJSON (SubscriptionPlan'Product'DeletedProduct a) = Data.Aeson.Types.ToJSON.toJSON a
  toJSON (SubscriptionPlan'Product'Product a) = Data.Aeson.Types.ToJSON.toJSON a
  toJSON (SubscriptionPlan'Product'Text a) = Data.Aeson.Types.ToJSON.toJSON a

instance Data.Aeson.Types.FromJSON.FromJSON SubscriptionPlan'Product'Variants where
  parseJSON val = case (SubscriptionPlan'Product'DeletedProduct Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((SubscriptionPlan'Product'Product Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((SubscriptionPlan'Product'Text Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> Data.Aeson.Types.Internal.Error "No variant matched")) of
    Data.Aeson.Types.Internal.Success a -> GHC.Base.pure a
    Data.Aeson.Types.Internal.Error a -> Control.Monad.Fail.fail a

-- | Defines the enum schema located at @components.schemas.subscription.properties.plan.anyOf.properties.tiers_mode@ in the specification.
--
-- Defines if the tiering price should be \`graduated\` or \`volume\` based. In \`volume\`-based tiering, the maximum quantity within a period determines the per unit price. In \`graduated\` tiering, pricing can change as the quantity grows.
data SubscriptionPlan'TiersMode'
  = -- | This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
    SubscriptionPlan'TiersMode'Other Data.Aeson.Types.Internal.Value
  | -- | This constructor can be used to send values to the server which are not present in the specification yet.
    SubscriptionPlan'TiersMode'Typed Data.Text.Internal.Text
  | -- | Represents the JSON value @"graduated"@
    SubscriptionPlan'TiersMode'EnumGraduated
  | -- | Represents the JSON value @"volume"@
    SubscriptionPlan'TiersMode'EnumVolume
  deriving (GHC.Show.Show, GHC.Classes.Eq)

instance Data.Aeson.Types.ToJSON.ToJSON SubscriptionPlan'TiersMode' where
  toJSON (SubscriptionPlan'TiersMode'Other val) = val
  toJSON (SubscriptionPlan'TiersMode'Typed val) = Data.Aeson.Types.ToJSON.toJSON val
  toJSON (SubscriptionPlan'TiersMode'EnumGraduated) = "graduated"
  toJSON (SubscriptionPlan'TiersMode'EnumVolume) = "volume"

instance Data.Aeson.Types.FromJSON.FromJSON SubscriptionPlan'TiersMode' where
  parseJSON val =
    GHC.Base.pure
      ( if  | val GHC.Classes.== "graduated" -> SubscriptionPlan'TiersMode'EnumGraduated
            | val GHC.Classes.== "volume" -> SubscriptionPlan'TiersMode'EnumVolume
            | GHC.Base.otherwise -> SubscriptionPlan'TiersMode'Other val
      )

-- | Defines the object schema located at @components.schemas.subscription.properties.plan.anyOf.properties.transform_usage.anyOf@ in the specification.
--
-- Apply a transformation to the reported usage or set quantity before computing the amount billed. Cannot be combined with \\\`tiers\\\`.
data SubscriptionPlan'TransformUsage'
  = SubscriptionPlan'TransformUsage'
      { -- | divide_by: Divide usage by this number.
        subscriptionPlan'TransformUsage'DivideBy :: (GHC.Maybe.Maybe GHC.Types.Int),
        -- | round: After division, either round the result \`up\` or \`down\`.
        subscriptionPlan'TransformUsage'Round :: (GHC.Maybe.Maybe SubscriptionPlan'TransformUsage'Round')
      }
  deriving
    ( GHC.Show.Show,
      GHC.Classes.Eq
    )

instance Data.Aeson.Types.ToJSON.ToJSON SubscriptionPlan'TransformUsage' where
  toJSON obj = Data.Aeson.Types.Internal.object ("divide_by" Data.Aeson.Types.ToJSON..= subscriptionPlan'TransformUsage'DivideBy obj : "round" Data.Aeson.Types.ToJSON..= subscriptionPlan'TransformUsage'Round obj : [])
  toEncoding obj = Data.Aeson.Encoding.Internal.pairs (("divide_by" Data.Aeson.Types.ToJSON..= subscriptionPlan'TransformUsage'DivideBy obj) GHC.Base.<> ("round" Data.Aeson.Types.ToJSON..= subscriptionPlan'TransformUsage'Round obj))

instance Data.Aeson.Types.FromJSON.FromJSON SubscriptionPlan'TransformUsage' where
  parseJSON = Data.Aeson.Types.FromJSON.withObject "SubscriptionPlan'TransformUsage'" (\obj -> (GHC.Base.pure SubscriptionPlan'TransformUsage' GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "divide_by")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "round"))

-- | Create a new 'SubscriptionPlan'TransformUsage'' with all required fields.
mkSubscriptionPlan'TransformUsage' :: SubscriptionPlan'TransformUsage'
mkSubscriptionPlan'TransformUsage' =
  SubscriptionPlan'TransformUsage'
    { subscriptionPlan'TransformUsage'DivideBy = GHC.Maybe.Nothing,
      subscriptionPlan'TransformUsage'Round = GHC.Maybe.Nothing
    }

-- | Defines the enum schema located at @components.schemas.subscription.properties.plan.anyOf.properties.transform_usage.anyOf.properties.round@ in the specification.
--
-- After division, either round the result \`up\` or \`down\`.
data SubscriptionPlan'TransformUsage'Round'
  = -- | This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
    SubscriptionPlan'TransformUsage'Round'Other Data.Aeson.Types.Internal.Value
  | -- | This constructor can be used to send values to the server which are not present in the specification yet.
    SubscriptionPlan'TransformUsage'Round'Typed Data.Text.Internal.Text
  | -- | Represents the JSON value @"down"@
    SubscriptionPlan'TransformUsage'Round'EnumDown
  | -- | Represents the JSON value @"up"@
    SubscriptionPlan'TransformUsage'Round'EnumUp
  deriving (GHC.Show.Show, GHC.Classes.Eq)

instance Data.Aeson.Types.ToJSON.ToJSON SubscriptionPlan'TransformUsage'Round' where
  toJSON (SubscriptionPlan'TransformUsage'Round'Other val) = val
  toJSON (SubscriptionPlan'TransformUsage'Round'Typed val) = Data.Aeson.Types.ToJSON.toJSON val
  toJSON (SubscriptionPlan'TransformUsage'Round'EnumDown) = "down"
  toJSON (SubscriptionPlan'TransformUsage'Round'EnumUp) = "up"

instance Data.Aeson.Types.FromJSON.FromJSON SubscriptionPlan'TransformUsage'Round' where
  parseJSON val =
    GHC.Base.pure
      ( if  | val GHC.Classes.== "down" -> SubscriptionPlan'TransformUsage'Round'EnumDown
            | val GHC.Classes.== "up" -> SubscriptionPlan'TransformUsage'Round'EnumUp
            | GHC.Base.otherwise -> SubscriptionPlan'TransformUsage'Round'Other val
      )

-- | Defines the enum schema located at @components.schemas.subscription.properties.plan.anyOf.properties.usage_type@ in the specification.
--
-- Configures how the quantity per period should be determined. Can be either \`metered\` or \`licensed\`. \`licensed\` automatically bills the \`quantity\` set when adding it to a subscription. \`metered\` aggregates the total usage based on usage records. Defaults to \`licensed\`.
data SubscriptionPlan'UsageType'
  = -- | This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
    SubscriptionPlan'UsageType'Other Data.Aeson.Types.Internal.Value
  | -- | This constructor can be used to send values to the server which are not present in the specification yet.
    SubscriptionPlan'UsageType'Typed Data.Text.Internal.Text
  | -- | Represents the JSON value @"licensed"@
    SubscriptionPlan'UsageType'EnumLicensed
  | -- | Represents the JSON value @"metered"@
    SubscriptionPlan'UsageType'EnumMetered
  deriving (GHC.Show.Show, GHC.Classes.Eq)

instance Data.Aeson.Types.ToJSON.ToJSON SubscriptionPlan'UsageType' where
  toJSON (SubscriptionPlan'UsageType'Other val) = val
  toJSON (SubscriptionPlan'UsageType'Typed val) = Data.Aeson.Types.ToJSON.toJSON val
  toJSON (SubscriptionPlan'UsageType'EnumLicensed) = "licensed"
  toJSON (SubscriptionPlan'UsageType'EnumMetered) = "metered"

instance Data.Aeson.Types.FromJSON.FromJSON SubscriptionPlan'UsageType' where
  parseJSON val =
    GHC.Base.pure
      ( if  | val GHC.Classes.== "licensed" -> SubscriptionPlan'UsageType'EnumLicensed
            | val GHC.Classes.== "metered" -> SubscriptionPlan'UsageType'EnumMetered
            | GHC.Base.otherwise -> SubscriptionPlan'UsageType'Other val
      )

-- | Defines the oneOf schema located at @components.schemas.subscription.properties.schedule.anyOf@ in the specification.
--
-- The schedule attached to the subscription
data SubscriptionSchedule'Variants
  = SubscriptionSchedule'SubscriptionSchedule SubscriptionSchedule
  | SubscriptionSchedule'Text Data.Text.Internal.Text
  deriving (GHC.Show.Show, GHC.Classes.Eq)

instance Data.Aeson.Types.ToJSON.ToJSON SubscriptionSchedule'Variants where
  toJSON (SubscriptionSchedule'SubscriptionSchedule a) = Data.Aeson.Types.ToJSON.toJSON a
  toJSON (SubscriptionSchedule'Text a) = Data.Aeson.Types.ToJSON.toJSON a

instance Data.Aeson.Types.FromJSON.FromJSON SubscriptionSchedule'Variants where
  parseJSON val = case (SubscriptionSchedule'SubscriptionSchedule Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((SubscriptionSchedule'Text Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> Data.Aeson.Types.Internal.Error "No variant matched") of
    Data.Aeson.Types.Internal.Success a -> GHC.Base.pure a
    Data.Aeson.Types.Internal.Error a -> Control.Monad.Fail.fail a

-- | Defines the enum schema located at @components.schemas.subscription.properties.status@ in the specification.
--
-- Possible values are \`incomplete\`, \`incomplete_expired\`, \`trialing\`, \`active\`, \`past_due\`, \`canceled\`, or \`unpaid\`.
--
-- For \`collection_method=charge_automatically\` a subscription moves into \`incomplete\` if the initial payment attempt fails. A subscription in this state can only have metadata and default_source updated. Once the first invoice is paid, the subscription moves into an \`active\` state. If the first invoice is not paid within 23 hours, the subscription transitions to \`incomplete_expired\`. This is a terminal state, the open invoice will be voided and no further invoices will be generated.
--
-- A subscription that is currently in a trial period is \`trialing\` and moves to \`active\` when the trial period is over.
--
-- If subscription \`collection_method=charge_automatically\` it becomes \`past_due\` when payment to renew it fails and \`canceled\` or \`unpaid\` (depending on your subscriptions settings) when Stripe has exhausted all payment retry attempts.
--
-- If subscription \`collection_method=send_invoice\` it becomes \`past_due\` when its invoice is not paid by the due date, and \`canceled\` or \`unpaid\` if it is still not paid by an additional deadline after that. Note that when a subscription has a status of \`unpaid\`, no subsequent invoices will be attempted (invoices will be created, but then immediately automatically closed). After receiving updated payment information from a customer, you may choose to reopen and pay their closed invoices.
data SubscriptionStatus'
  = -- | This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
    SubscriptionStatus'Other Data.Aeson.Types.Internal.Value
  | -- | This constructor can be used to send values to the server which are not present in the specification yet.
    SubscriptionStatus'Typed Data.Text.Internal.Text
  | -- | Represents the JSON value @"active"@
    SubscriptionStatus'EnumActive
  | -- | Represents the JSON value @"canceled"@
    SubscriptionStatus'EnumCanceled
  | -- | Represents the JSON value @"incomplete"@
    SubscriptionStatus'EnumIncomplete
  | -- | Represents the JSON value @"incomplete_expired"@
    SubscriptionStatus'EnumIncompleteExpired
  | -- | Represents the JSON value @"past_due"@
    SubscriptionStatus'EnumPastDue
  | -- | Represents the JSON value @"trialing"@
    SubscriptionStatus'EnumTrialing
  | -- | Represents the JSON value @"unpaid"@
    SubscriptionStatus'EnumUnpaid
  deriving (GHC.Show.Show, GHC.Classes.Eq)

instance Data.Aeson.Types.ToJSON.ToJSON SubscriptionStatus' where
  toJSON (SubscriptionStatus'Other val) = val
  toJSON (SubscriptionStatus'Typed val) = Data.Aeson.Types.ToJSON.toJSON val
  toJSON (SubscriptionStatus'EnumActive) = "active"
  toJSON (SubscriptionStatus'EnumCanceled) = "canceled"
  toJSON (SubscriptionStatus'EnumIncomplete) = "incomplete"
  toJSON (SubscriptionStatus'EnumIncompleteExpired) = "incomplete_expired"
  toJSON (SubscriptionStatus'EnumPastDue) = "past_due"
  toJSON (SubscriptionStatus'EnumTrialing) = "trialing"
  toJSON (SubscriptionStatus'EnumUnpaid) = "unpaid"

instance Data.Aeson.Types.FromJSON.FromJSON SubscriptionStatus' where
  parseJSON val =
    GHC.Base.pure
      ( if  | val GHC.Classes.== "active" -> SubscriptionStatus'EnumActive
            | val GHC.Classes.== "canceled" -> SubscriptionStatus'EnumCanceled
            | val GHC.Classes.== "incomplete" -> SubscriptionStatus'EnumIncomplete
            | val GHC.Classes.== "incomplete_expired" -> SubscriptionStatus'EnumIncompleteExpired
            | val GHC.Classes.== "past_due" -> SubscriptionStatus'EnumPastDue
            | val GHC.Classes.== "trialing" -> SubscriptionStatus'EnumTrialing
            | val GHC.Classes.== "unpaid" -> SubscriptionStatus'EnumUnpaid
            | GHC.Base.otherwise -> SubscriptionStatus'Other val
      )
