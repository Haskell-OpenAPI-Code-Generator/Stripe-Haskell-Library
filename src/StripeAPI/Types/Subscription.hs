{-# LANGUAGE MultiWayIf #-}
-- CHANGE WITH CAUTION: This is a generated code file generated by https://github.com/Haskell-OpenAPI-Code-Generator/Haskell-OpenAPI-Client-Code-Generator.
{-# LANGUAGE OverloadedStrings #-}

-- | Contains the types generated from the schema Subscription
module StripeAPI.Types.Subscription where

import qualified Control.Monad.Fail
import qualified Data.Aeson
import qualified Data.Aeson as Data.Aeson.Encoding.Internal
import qualified Data.Aeson as Data.Aeson.Types
import qualified Data.Aeson as Data.Aeson.Types.FromJSON
import qualified Data.Aeson as Data.Aeson.Types.Internal
import qualified Data.Aeson as Data.Aeson.Types.ToJSON
import qualified Data.ByteString
import qualified Data.ByteString as Data.ByteString.Internal
import qualified Data.Foldable
import qualified Data.Functor
import qualified Data.Maybe
import qualified Data.Scientific
import qualified Data.Text
import qualified Data.Text as Data.Text.Internal
import qualified Data.Time.Calendar as Data.Time.Calendar.Days
import qualified Data.Time.LocalTime as Data.Time.LocalTime.Internal.ZonedTime
import qualified GHC.Base
import qualified GHC.Classes
import qualified GHC.Int
import qualified GHC.Show
import qualified GHC.Types
import qualified StripeAPI.Common
import StripeAPI.TypeAlias
import {-# SOURCE #-} StripeAPI.Types.Account
import {-# SOURCE #-} StripeAPI.Types.Application
import {-# SOURCE #-} StripeAPI.Types.BankAccount
import {-# SOURCE #-} StripeAPI.Types.CancellationDetails
import {-# SOURCE #-} StripeAPI.Types.Card
import {-# SOURCE #-} StripeAPI.Types.Coupon
import {-# SOURCE #-} StripeAPI.Types.Customer
import {-# SOURCE #-} StripeAPI.Types.DeletedApplication
import {-# SOURCE #-} StripeAPI.Types.DeletedCustomer
import {-# SOURCE #-} StripeAPI.Types.Discount
import {-# SOURCE #-} StripeAPI.Types.Invoice
import {-# SOURCE #-} StripeAPI.Types.InvoiceMandateOptionsCard
import {-# SOURCE #-} StripeAPI.Types.InvoicePaymentMethodOptionsAcssDebit
import {-# SOURCE #-} StripeAPI.Types.InvoicePaymentMethodOptionsAcssDebitMandateOptions
import {-# SOURCE #-} StripeAPI.Types.InvoicePaymentMethodOptionsBancontact
import {-# SOURCE #-} StripeAPI.Types.InvoicePaymentMethodOptionsCustomerBalance
import {-# SOURCE #-} StripeAPI.Types.InvoicePaymentMethodOptionsCustomerBalanceBankTransfer
import {-# SOURCE #-} StripeAPI.Types.InvoicePaymentMethodOptionsUsBankAccount
import {-# SOURCE #-} StripeAPI.Types.InvoicePaymentMethodOptionsUsBankAccountLinkedAccountOptions
import {-# SOURCE #-} StripeAPI.Types.PaymentMethod
import {-# SOURCE #-} StripeAPI.Types.PromotionCode
import {-# SOURCE #-} StripeAPI.Types.SetupIntent
import {-# SOURCE #-} StripeAPI.Types.Source
import {-# SOURCE #-} StripeAPI.Types.SubscriptionAutomaticTax
import {-# SOURCE #-} StripeAPI.Types.SubscriptionBillingThresholds
import {-# SOURCE #-} StripeAPI.Types.SubscriptionItem
import {-# SOURCE #-} StripeAPI.Types.SubscriptionPaymentMethodOptionsCard
import {-# SOURCE #-} StripeAPI.Types.SubscriptionPendingInvoiceItemInterval
import {-# SOURCE #-} StripeAPI.Types.SubscriptionSchedule
import {-# SOURCE #-} StripeAPI.Types.SubscriptionTransferData
import {-# SOURCE #-} StripeAPI.Types.SubscriptionsResourcePauseCollection
import {-# SOURCE #-} StripeAPI.Types.SubscriptionsResourcePaymentMethodOptions
import {-# SOURCE #-} StripeAPI.Types.SubscriptionsResourcePaymentSettings
import {-# SOURCE #-} StripeAPI.Types.SubscriptionsResourcePendingUpdate
import {-# SOURCE #-} StripeAPI.Types.SubscriptionsTrialsResourceEndBehavior
import {-# SOURCE #-} StripeAPI.Types.SubscriptionsTrialsResourceTrialSettings
import {-# SOURCE #-} StripeAPI.Types.TaxRate
import {-# SOURCE #-} StripeAPI.Types.TestHelpers_TestClock
import qualified Prelude as GHC.Integer.Type
import qualified Prelude as GHC.Maybe

-- | Defines the object schema located at @components.schemas.subscription@ in the specification.
--
-- Subscriptions allow you to charge a customer on a recurring basis.
--
-- Related guide: [Creating subscriptions](https:\/\/stripe.com\/docs\/billing\/subscriptions\/creating)
data Subscription = Subscription
  { -- | application: ID of the Connect Application that created the subscription.
    subscriptionApplication :: (GHC.Maybe.Maybe (StripeAPI.Common.Nullable SubscriptionApplication'NonNullableVariants)),
    -- | application_fee_percent: A non-negative decimal between 0 and 100, with at most two decimal places. This represents the percentage of the subscription invoice total that will be transferred to the application owner\'s Stripe account.
    subscriptionApplicationFeePercent :: (GHC.Maybe.Maybe (StripeAPI.Common.Nullable GHC.Types.Double)),
    -- | automatic_tax:
    subscriptionAutomaticTax :: SubscriptionAutomaticTax,
    -- | billing_cycle_anchor: The reference point that aligns future [billing cycle](https:\/\/stripe.com\/docs\/subscriptions\/billing-cycle) dates. It sets the day of week for \`week\` intervals, the day of month for \`month\` and \`year\` intervals, and the month of year for \`year\` intervals. The timestamp is in UTC format.
    subscriptionBillingCycleAnchor :: GHC.Types.Int,
    -- | billing_thresholds: Define thresholds at which an invoice will be sent, and the subscription advanced to a new billing period
    subscriptionBillingThresholds :: (GHC.Maybe.Maybe (StripeAPI.Common.Nullable SubscriptionBillingThresholds'NonNullable)),
    -- | cancel_at: A date in the future at which the subscription will automatically get canceled
    subscriptionCancelAt :: (GHC.Maybe.Maybe (StripeAPI.Common.Nullable GHC.Types.Int)),
    -- | cancel_at_period_end: If the subscription has been canceled with the \`at_period_end\` flag set to \`true\`, \`cancel_at_period_end\` on the subscription will be true. You can use this attribute to determine whether a subscription that has a status of active is scheduled to be canceled at the end of the current period.
    subscriptionCancelAtPeriodEnd :: GHC.Types.Bool,
    -- | canceled_at: If the subscription has been canceled, the date of that cancellation. If the subscription was canceled with \`cancel_at_period_end\`, \`canceled_at\` will reflect the time of the most recent update request, not the end of the subscription period when the subscription is automatically moved to a canceled state.
    subscriptionCanceledAt :: (GHC.Maybe.Maybe (StripeAPI.Common.Nullable GHC.Types.Int)),
    -- | cancellation_details: Details about why this subscription was cancelled
    subscriptionCancellationDetails :: (GHC.Maybe.Maybe (StripeAPI.Common.Nullable SubscriptionCancellationDetails'NonNullable)),
    -- | collection_method: Either \`charge_automatically\`, or \`send_invoice\`. When charging automatically, Stripe will attempt to pay this subscription at the end of the cycle using the default source attached to the customer. When sending an invoice, Stripe will email your customer an invoice with payment instructions and mark the subscription as \`active\`.
    subscriptionCollectionMethod :: SubscriptionCollectionMethod',
    -- | created: Time at which the object was created. Measured in seconds since the Unix epoch.
    subscriptionCreated :: GHC.Types.Int,
    -- | currency: Three-letter [ISO currency code](https:\/\/www.iso.org\/iso-4217-currency-codes.html), in lowercase. Must be a [supported currency](https:\/\/stripe.com\/docs\/currencies).
    subscriptionCurrency :: Data.Text.Internal.Text,
    -- | current_period_end: End of the current period that the subscription has been invoiced for. At the end of this period, a new invoice will be created.
    subscriptionCurrentPeriodEnd :: GHC.Types.Int,
    -- | current_period_start: Start of the current period that the subscription has been invoiced for.
    subscriptionCurrentPeriodStart :: GHC.Types.Int,
    -- | customer: ID of the customer who owns the subscription.
    subscriptionCustomer :: SubscriptionCustomer'Variants,
    -- | days_until_due: Number of days a customer has to pay invoices generated by this subscription. This value will be \`null\` for subscriptions where \`collection_method=charge_automatically\`.
    subscriptionDaysUntilDue :: (GHC.Maybe.Maybe (StripeAPI.Common.Nullable GHC.Types.Int)),
    -- | default_payment_method: ID of the default payment method for the subscription. It must belong to the customer associated with the subscription. This takes precedence over \`default_source\`. If neither are set, invoices will use the customer\'s [invoice_settings.default_payment_method](https:\/\/stripe.com\/docs\/api\/customers\/object\#customer_object-invoice_settings-default_payment_method) or [default_source](https:\/\/stripe.com\/docs\/api\/customers\/object\#customer_object-default_source).
    subscriptionDefaultPaymentMethod :: (GHC.Maybe.Maybe (StripeAPI.Common.Nullable SubscriptionDefaultPaymentMethod'NonNullableVariants)),
    -- | default_source: ID of the default payment source for the subscription. It must belong to the customer associated with the subscription and be in a chargeable state. If \`default_payment_method\` is also set, \`default_payment_method\` will take precedence. If neither are set, invoices will use the customer\'s [invoice_settings.default_payment_method](https:\/\/stripe.com\/docs\/api\/customers\/object\#customer_object-invoice_settings-default_payment_method) or [default_source](https:\/\/stripe.com\/docs\/api\/customers\/object\#customer_object-default_source).
    subscriptionDefaultSource :: (GHC.Maybe.Maybe (StripeAPI.Common.Nullable SubscriptionDefaultSource'NonNullableVariants)),
    -- | default_tax_rates: The tax rates that will apply to any subscription item that does not have \`tax_rates\` set. Invoices created will have their \`default_tax_rates\` populated from the subscription.
    subscriptionDefaultTaxRates :: (GHC.Maybe.Maybe (StripeAPI.Common.Nullable ([TaxRate]))),
    -- | description: The subscription\'s description, meant to be displayable to the customer. Use this field to optionally store an explanation of the subscription for rendering in Stripe surfaces and certain local payment methods UIs.
    --
    -- Constraints:
    --
    -- * Maximum length of 500
    subscriptionDescription :: (GHC.Maybe.Maybe (StripeAPI.Common.Nullable Data.Text.Internal.Text)),
    -- | discount: Describes the current discount applied to this subscription, if there is one. When billing, a discount applied to a subscription overrides a discount applied on a customer-wide basis.
    subscriptionDiscount :: (GHC.Maybe.Maybe (StripeAPI.Common.Nullable SubscriptionDiscount'NonNullable)),
    -- | ended_at: If the subscription has ended, the date the subscription ended.
    subscriptionEndedAt :: (GHC.Maybe.Maybe (StripeAPI.Common.Nullable GHC.Types.Int)),
    -- | id: Unique identifier for the object.
    --
    -- Constraints:
    --
    -- * Maximum length of 5000
    subscriptionId :: Data.Text.Internal.Text,
    -- | items: List of subscription items, each with an attached price.
    subscriptionItems :: SubscriptionItems',
    -- | latest_invoice: The most recent invoice this subscription has generated.
    subscriptionLatestInvoice :: (GHC.Maybe.Maybe (StripeAPI.Common.Nullable SubscriptionLatestInvoice'NonNullableVariants)),
    -- | livemode: Has the value \`true\` if the object exists in live mode or the value \`false\` if the object exists in test mode.
    subscriptionLivemode :: GHC.Types.Bool,
    -- | metadata: Set of [key-value pairs](https:\/\/stripe.com\/docs\/api\/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format.
    subscriptionMetadata :: Data.Aeson.Types.Internal.Object,
    -- | next_pending_invoice_item_invoice: Specifies the approximate timestamp on which any pending invoice items will be billed according to the schedule provided at \`pending_invoice_item_interval\`.
    subscriptionNextPendingInvoiceItemInvoice :: (GHC.Maybe.Maybe (StripeAPI.Common.Nullable GHC.Types.Int)),
    -- | on_behalf_of: The account (if any) the charge was made on behalf of for charges associated with this subscription. See the Connect documentation for details.
    subscriptionOnBehalfOf :: (GHC.Maybe.Maybe (StripeAPI.Common.Nullable SubscriptionOnBehalfOf'NonNullableVariants)),
    -- | pause_collection: If specified, payment collection for this subscription will be paused.
    subscriptionPauseCollection :: (GHC.Maybe.Maybe (StripeAPI.Common.Nullable SubscriptionPauseCollection'NonNullable)),
    -- | payment_settings: Payment settings passed on to invoices created by the subscription.
    subscriptionPaymentSettings :: (GHC.Maybe.Maybe (StripeAPI.Common.Nullable SubscriptionPaymentSettings'NonNullable)),
    -- | pending_invoice_item_interval: Specifies an interval for how often to bill for any pending invoice items. It is analogous to calling [Create an invoice](https:\/\/stripe.com\/docs\/api\#create_invoice) for the given subscription at the specified interval.
    subscriptionPendingInvoiceItemInterval :: (GHC.Maybe.Maybe (StripeAPI.Common.Nullable SubscriptionPendingInvoiceItemInterval'NonNullable)),
    -- | pending_setup_intent: You can use this [SetupIntent](https:\/\/stripe.com\/docs\/api\/setup_intents) to collect user authentication when creating a subscription without immediate payment or updating a subscription\'s payment method, allowing you to optimize for off-session payments. Learn more in the [SCA Migration Guide](https:\/\/stripe.com\/docs\/billing\/migration\/strong-customer-authentication\#scenario-2).
    subscriptionPendingSetupIntent :: (GHC.Maybe.Maybe (StripeAPI.Common.Nullable SubscriptionPendingSetupIntent'NonNullableVariants)),
    -- | pending_update: If specified, [pending updates](https:\/\/stripe.com\/docs\/billing\/subscriptions\/pending-updates) that will be applied to the subscription once the \`latest_invoice\` has been paid.
    subscriptionPendingUpdate :: (GHC.Maybe.Maybe (StripeAPI.Common.Nullable SubscriptionPendingUpdate'NonNullable)),
    -- | schedule: The schedule attached to the subscription
    subscriptionSchedule :: (GHC.Maybe.Maybe (StripeAPI.Common.Nullable SubscriptionSchedule'NonNullableVariants)),
    -- | start_date: Date when the subscription was first created. The date might differ from the \`created\` date due to backdating.
    subscriptionStartDate :: GHC.Types.Int,
    -- | status: Possible values are \`incomplete\`, \`incomplete_expired\`, \`trialing\`, \`active\`, \`past_due\`, \`canceled\`, or \`unpaid\`.
    --
    -- For \`collection_method=charge_automatically\` a subscription moves into \`incomplete\` if the initial payment attempt fails. A subscription in this state can only have metadata and default_source updated. Once the first invoice is paid, the subscription moves into an \`active\` state. If the first invoice is not paid within 23 hours, the subscription transitions to \`incomplete_expired\`. This is a terminal state, the open invoice will be voided and no further invoices will be generated.
    --
    -- A subscription that is currently in a trial period is \`trialing\` and moves to \`active\` when the trial period is over.
    --
    -- If subscription \`collection_method=charge_automatically\`, it becomes \`past_due\` when payment is required but cannot be paid (due to failed payment or awaiting additional user actions). Once Stripe has exhausted all payment retry attempts, the subscription will become \`canceled\` or \`unpaid\` (depending on your subscriptions settings).
    --
    -- If subscription \`collection_method=send_invoice\` it becomes \`past_due\` when its invoice is not paid by the due date, and \`canceled\` or \`unpaid\` if it is still not paid by an additional deadline after that. Note that when a subscription has a status of \`unpaid\`, no subsequent invoices will be attempted (invoices will be created, but then immediately automatically closed). After receiving updated payment information from a customer, you may choose to reopen and pay their closed invoices.
    subscriptionStatus :: SubscriptionStatus',
    -- | test_clock: ID of the test clock this subscription belongs to.
    subscriptionTestClock :: (GHC.Maybe.Maybe (StripeAPI.Common.Nullable SubscriptionTestClock'NonNullableVariants)),
    -- | transfer_data: The account (if any) the subscription\'s payments will be attributed to for tax reporting, and where funds from each payment will be transferred to for each of the subscription\'s invoices.
    subscriptionTransferData :: (GHC.Maybe.Maybe (StripeAPI.Common.Nullable SubscriptionTransferData'NonNullable)),
    -- | trial_end: If the subscription has a trial, the end of that trial.
    subscriptionTrialEnd :: (GHC.Maybe.Maybe (StripeAPI.Common.Nullable GHC.Types.Int)),
    -- | trial_settings: Settings related to subscription trials.
    subscriptionTrialSettings :: (GHC.Maybe.Maybe (StripeAPI.Common.Nullable SubscriptionTrialSettings'NonNullable)),
    -- | trial_start: If the subscription has a trial, the beginning of that trial.
    subscriptionTrialStart :: (GHC.Maybe.Maybe (StripeAPI.Common.Nullable GHC.Types.Int))
  }
  deriving
    ( GHC.Show.Show,
      GHC.Classes.Eq
    )

instance Data.Aeson.Types.ToJSON.ToJSON Subscription where
  toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("application" Data.Aeson.Types.ToJSON..=)) (subscriptionApplication obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("application_fee_percent" Data.Aeson.Types.ToJSON..=)) (subscriptionApplicationFeePercent obj) : ["automatic_tax" Data.Aeson.Types.ToJSON..= subscriptionAutomaticTax obj] : ["billing_cycle_anchor" Data.Aeson.Types.ToJSON..= subscriptionBillingCycleAnchor obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("billing_thresholds" Data.Aeson.Types.ToJSON..=)) (subscriptionBillingThresholds obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("cancel_at" Data.Aeson.Types.ToJSON..=)) (subscriptionCancelAt obj) : ["cancel_at_period_end" Data.Aeson.Types.ToJSON..= subscriptionCancelAtPeriodEnd obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("canceled_at" Data.Aeson.Types.ToJSON..=)) (subscriptionCanceledAt obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("cancellation_details" Data.Aeson.Types.ToJSON..=)) (subscriptionCancellationDetails obj) : ["collection_method" Data.Aeson.Types.ToJSON..= subscriptionCollectionMethod obj] : ["created" Data.Aeson.Types.ToJSON..= subscriptionCreated obj] : ["currency" Data.Aeson.Types.ToJSON..= subscriptionCurrency obj] : ["current_period_end" Data.Aeson.Types.ToJSON..= subscriptionCurrentPeriodEnd obj] : ["current_period_start" Data.Aeson.Types.ToJSON..= subscriptionCurrentPeriodStart obj] : ["customer" Data.Aeson.Types.ToJSON..= subscriptionCustomer obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("days_until_due" Data.Aeson.Types.ToJSON..=)) (subscriptionDaysUntilDue obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("default_payment_method" Data.Aeson.Types.ToJSON..=)) (subscriptionDefaultPaymentMethod obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("default_source" Data.Aeson.Types.ToJSON..=)) (subscriptionDefaultSource obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("default_tax_rates" Data.Aeson.Types.ToJSON..=)) (subscriptionDefaultTaxRates obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("description" Data.Aeson.Types.ToJSON..=)) (subscriptionDescription obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("discount" Data.Aeson.Types.ToJSON..=)) (subscriptionDiscount obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("ended_at" Data.Aeson.Types.ToJSON..=)) (subscriptionEndedAt obj) : ["id" Data.Aeson.Types.ToJSON..= subscriptionId obj] : ["items" Data.Aeson.Types.ToJSON..= subscriptionItems obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("latest_invoice" Data.Aeson.Types.ToJSON..=)) (subscriptionLatestInvoice obj) : ["livemode" Data.Aeson.Types.ToJSON..= subscriptionLivemode obj] : ["metadata" Data.Aeson.Types.ToJSON..= subscriptionMetadata obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("next_pending_invoice_item_invoice" Data.Aeson.Types.ToJSON..=)) (subscriptionNextPendingInvoiceItemInvoice obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("on_behalf_of" Data.Aeson.Types.ToJSON..=)) (subscriptionOnBehalfOf obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("pause_collection" Data.Aeson.Types.ToJSON..=)) (subscriptionPauseCollection obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("payment_settings" Data.Aeson.Types.ToJSON..=)) (subscriptionPaymentSettings obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("pending_invoice_item_interval" Data.Aeson.Types.ToJSON..=)) (subscriptionPendingInvoiceItemInterval obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("pending_setup_intent" Data.Aeson.Types.ToJSON..=)) (subscriptionPendingSetupIntent obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("pending_update" Data.Aeson.Types.ToJSON..=)) (subscriptionPendingUpdate obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("schedule" Data.Aeson.Types.ToJSON..=)) (subscriptionSchedule obj) : ["start_date" Data.Aeson.Types.ToJSON..= subscriptionStartDate obj] : ["status" Data.Aeson.Types.ToJSON..= subscriptionStatus obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("test_clock" Data.Aeson.Types.ToJSON..=)) (subscriptionTestClock obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("transfer_data" Data.Aeson.Types.ToJSON..=)) (subscriptionTransferData obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("trial_end" Data.Aeson.Types.ToJSON..=)) (subscriptionTrialEnd obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("trial_settings" Data.Aeson.Types.ToJSON..=)) (subscriptionTrialSettings obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("trial_start" Data.Aeson.Types.ToJSON..=)) (subscriptionTrialStart obj) : ["object" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "subscription"] : GHC.Base.mempty))
  toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("application" Data.Aeson.Types.ToJSON..=)) (subscriptionApplication obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("application_fee_percent" Data.Aeson.Types.ToJSON..=)) (subscriptionApplicationFeePercent obj) : ["automatic_tax" Data.Aeson.Types.ToJSON..= subscriptionAutomaticTax obj] : ["billing_cycle_anchor" Data.Aeson.Types.ToJSON..= subscriptionBillingCycleAnchor obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("billing_thresholds" Data.Aeson.Types.ToJSON..=)) (subscriptionBillingThresholds obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("cancel_at" Data.Aeson.Types.ToJSON..=)) (subscriptionCancelAt obj) : ["cancel_at_period_end" Data.Aeson.Types.ToJSON..= subscriptionCancelAtPeriodEnd obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("canceled_at" Data.Aeson.Types.ToJSON..=)) (subscriptionCanceledAt obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("cancellation_details" Data.Aeson.Types.ToJSON..=)) (subscriptionCancellationDetails obj) : ["collection_method" Data.Aeson.Types.ToJSON..= subscriptionCollectionMethod obj] : ["created" Data.Aeson.Types.ToJSON..= subscriptionCreated obj] : ["currency" Data.Aeson.Types.ToJSON..= subscriptionCurrency obj] : ["current_period_end" Data.Aeson.Types.ToJSON..= subscriptionCurrentPeriodEnd obj] : ["current_period_start" Data.Aeson.Types.ToJSON..= subscriptionCurrentPeriodStart obj] : ["customer" Data.Aeson.Types.ToJSON..= subscriptionCustomer obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("days_until_due" Data.Aeson.Types.ToJSON..=)) (subscriptionDaysUntilDue obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("default_payment_method" Data.Aeson.Types.ToJSON..=)) (subscriptionDefaultPaymentMethod obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("default_source" Data.Aeson.Types.ToJSON..=)) (subscriptionDefaultSource obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("default_tax_rates" Data.Aeson.Types.ToJSON..=)) (subscriptionDefaultTaxRates obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("description" Data.Aeson.Types.ToJSON..=)) (subscriptionDescription obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("discount" Data.Aeson.Types.ToJSON..=)) (subscriptionDiscount obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("ended_at" Data.Aeson.Types.ToJSON..=)) (subscriptionEndedAt obj) : ["id" Data.Aeson.Types.ToJSON..= subscriptionId obj] : ["items" Data.Aeson.Types.ToJSON..= subscriptionItems obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("latest_invoice" Data.Aeson.Types.ToJSON..=)) (subscriptionLatestInvoice obj) : ["livemode" Data.Aeson.Types.ToJSON..= subscriptionLivemode obj] : ["metadata" Data.Aeson.Types.ToJSON..= subscriptionMetadata obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("next_pending_invoice_item_invoice" Data.Aeson.Types.ToJSON..=)) (subscriptionNextPendingInvoiceItemInvoice obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("on_behalf_of" Data.Aeson.Types.ToJSON..=)) (subscriptionOnBehalfOf obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("pause_collection" Data.Aeson.Types.ToJSON..=)) (subscriptionPauseCollection obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("payment_settings" Data.Aeson.Types.ToJSON..=)) (subscriptionPaymentSettings obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("pending_invoice_item_interval" Data.Aeson.Types.ToJSON..=)) (subscriptionPendingInvoiceItemInterval obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("pending_setup_intent" Data.Aeson.Types.ToJSON..=)) (subscriptionPendingSetupIntent obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("pending_update" Data.Aeson.Types.ToJSON..=)) (subscriptionPendingUpdate obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("schedule" Data.Aeson.Types.ToJSON..=)) (subscriptionSchedule obj) : ["start_date" Data.Aeson.Types.ToJSON..= subscriptionStartDate obj] : ["status" Data.Aeson.Types.ToJSON..= subscriptionStatus obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("test_clock" Data.Aeson.Types.ToJSON..=)) (subscriptionTestClock obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("transfer_data" Data.Aeson.Types.ToJSON..=)) (subscriptionTransferData obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("trial_end" Data.Aeson.Types.ToJSON..=)) (subscriptionTrialEnd obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("trial_settings" Data.Aeson.Types.ToJSON..=)) (subscriptionTrialSettings obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("trial_start" Data.Aeson.Types.ToJSON..=)) (subscriptionTrialStart obj) : ["object" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "subscription"] : GHC.Base.mempty)))

instance Data.Aeson.Types.FromJSON.FromJSON Subscription where
  parseJSON = Data.Aeson.Types.FromJSON.withObject "Subscription" (\obj -> (((((((((((((((((((((((((((((((((((((((((GHC.Base.pure Subscription GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "application")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "application_fee_percent")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "automatic_tax")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "billing_cycle_anchor")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "billing_thresholds")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "cancel_at")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "cancel_at_period_end")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "canceled_at")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "cancellation_details")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "collection_method")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "created")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "currency")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "current_period_end")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "current_period_start")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "customer")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "days_until_due")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "default_payment_method")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "default_source")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "default_tax_rates")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "description")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "discount")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "ended_at")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "items")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "latest_invoice")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "livemode")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "metadata")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "next_pending_invoice_item_invoice")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "on_behalf_of")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "pause_collection")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "payment_settings")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "pending_invoice_item_interval")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "pending_setup_intent")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "pending_update")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "schedule")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "start_date")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "status")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "test_clock")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "transfer_data")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "trial_end")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "trial_settings")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "trial_start"))

-- | Create a new 'Subscription' with all required fields.
mkSubscription ::
  -- | 'subscriptionAutomaticTax'
  SubscriptionAutomaticTax ->
  -- | 'subscriptionBillingCycleAnchor'
  GHC.Types.Int ->
  -- | 'subscriptionCancelAtPeriodEnd'
  GHC.Types.Bool ->
  -- | 'subscriptionCollectionMethod'
  SubscriptionCollectionMethod' ->
  -- | 'subscriptionCreated'
  GHC.Types.Int ->
  -- | 'subscriptionCurrency'
  Data.Text.Internal.Text ->
  -- | 'subscriptionCurrentPeriodEnd'
  GHC.Types.Int ->
  -- | 'subscriptionCurrentPeriodStart'
  GHC.Types.Int ->
  -- | 'subscriptionCustomer'
  SubscriptionCustomer'Variants ->
  -- | 'subscriptionId'
  Data.Text.Internal.Text ->
  -- | 'subscriptionItems'
  SubscriptionItems' ->
  -- | 'subscriptionLivemode'
  GHC.Types.Bool ->
  -- | 'subscriptionMetadata'
  Data.Aeson.Types.Internal.Object ->
  -- | 'subscriptionStartDate'
  GHC.Types.Int ->
  -- | 'subscriptionStatus'
  SubscriptionStatus' ->
  Subscription
mkSubscription subscriptionAutomaticTax subscriptionBillingCycleAnchor subscriptionCancelAtPeriodEnd subscriptionCollectionMethod subscriptionCreated subscriptionCurrency subscriptionCurrentPeriodEnd subscriptionCurrentPeriodStart subscriptionCustomer subscriptionId subscriptionItems subscriptionLivemode subscriptionMetadata subscriptionStartDate subscriptionStatus =
  Subscription
    { subscriptionApplication = GHC.Maybe.Nothing,
      subscriptionApplicationFeePercent = GHC.Maybe.Nothing,
      subscriptionAutomaticTax = subscriptionAutomaticTax,
      subscriptionBillingCycleAnchor = subscriptionBillingCycleAnchor,
      subscriptionBillingThresholds = GHC.Maybe.Nothing,
      subscriptionCancelAt = GHC.Maybe.Nothing,
      subscriptionCancelAtPeriodEnd = subscriptionCancelAtPeriodEnd,
      subscriptionCanceledAt = GHC.Maybe.Nothing,
      subscriptionCancellationDetails = GHC.Maybe.Nothing,
      subscriptionCollectionMethod = subscriptionCollectionMethod,
      subscriptionCreated = subscriptionCreated,
      subscriptionCurrency = subscriptionCurrency,
      subscriptionCurrentPeriodEnd = subscriptionCurrentPeriodEnd,
      subscriptionCurrentPeriodStart = subscriptionCurrentPeriodStart,
      subscriptionCustomer = subscriptionCustomer,
      subscriptionDaysUntilDue = GHC.Maybe.Nothing,
      subscriptionDefaultPaymentMethod = GHC.Maybe.Nothing,
      subscriptionDefaultSource = GHC.Maybe.Nothing,
      subscriptionDefaultTaxRates = GHC.Maybe.Nothing,
      subscriptionDescription = GHC.Maybe.Nothing,
      subscriptionDiscount = GHC.Maybe.Nothing,
      subscriptionEndedAt = GHC.Maybe.Nothing,
      subscriptionId = subscriptionId,
      subscriptionItems = subscriptionItems,
      subscriptionLatestInvoice = GHC.Maybe.Nothing,
      subscriptionLivemode = subscriptionLivemode,
      subscriptionMetadata = subscriptionMetadata,
      subscriptionNextPendingInvoiceItemInvoice = GHC.Maybe.Nothing,
      subscriptionOnBehalfOf = GHC.Maybe.Nothing,
      subscriptionPauseCollection = GHC.Maybe.Nothing,
      subscriptionPaymentSettings = GHC.Maybe.Nothing,
      subscriptionPendingInvoiceItemInterval = GHC.Maybe.Nothing,
      subscriptionPendingSetupIntent = GHC.Maybe.Nothing,
      subscriptionPendingUpdate = GHC.Maybe.Nothing,
      subscriptionSchedule = GHC.Maybe.Nothing,
      subscriptionStartDate = subscriptionStartDate,
      subscriptionStatus = subscriptionStatus,
      subscriptionTestClock = GHC.Maybe.Nothing,
      subscriptionTransferData = GHC.Maybe.Nothing,
      subscriptionTrialEnd = GHC.Maybe.Nothing,
      subscriptionTrialSettings = GHC.Maybe.Nothing,
      subscriptionTrialStart = GHC.Maybe.Nothing
    }

-- | Defines the oneOf schema located at @components.schemas.subscription.properties.application.anyOf@ in the specification.
--
-- ID of the Connect Application that created the subscription.
data SubscriptionApplication'NonNullableVariants
  = SubscriptionApplication'NonNullableText Data.Text.Internal.Text
  | SubscriptionApplication'NonNullableApplication Application
  | SubscriptionApplication'NonNullableDeletedApplication DeletedApplication
  deriving (GHC.Show.Show, GHC.Classes.Eq)

instance Data.Aeson.Types.ToJSON.ToJSON SubscriptionApplication'NonNullableVariants where
  toJSON (SubscriptionApplication'NonNullableText a) = Data.Aeson.Types.ToJSON.toJSON a
  toJSON (SubscriptionApplication'NonNullableApplication a) = Data.Aeson.Types.ToJSON.toJSON a
  toJSON (SubscriptionApplication'NonNullableDeletedApplication a) = Data.Aeson.Types.ToJSON.toJSON a

instance Data.Aeson.Types.FromJSON.FromJSON SubscriptionApplication'NonNullableVariants where
  parseJSON val = case (SubscriptionApplication'NonNullableText Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((SubscriptionApplication'NonNullableApplication Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((SubscriptionApplication'NonNullableDeletedApplication Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> Data.Aeson.Types.Internal.Error "No variant matched")) of
    Data.Aeson.Types.Internal.Success a -> GHC.Base.pure a
    Data.Aeson.Types.Internal.Error a -> Control.Monad.Fail.fail a

-- | Defines the object schema located at @components.schemas.subscription.properties.billing_thresholds.anyOf@ in the specification.
--
-- Define thresholds at which an invoice will be sent, and the subscription advanced to a new billing period
data SubscriptionBillingThresholds'NonNullable = SubscriptionBillingThresholds'NonNullable
  { -- | amount_gte: Monetary threshold that triggers the subscription to create an invoice
    subscriptionBillingThresholds'NonNullableAmountGte :: (GHC.Maybe.Maybe (StripeAPI.Common.Nullable GHC.Types.Int)),
    -- | reset_billing_cycle_anchor: Indicates if the \`billing_cycle_anchor\` should be reset when a threshold is reached. If true, \`billing_cycle_anchor\` will be updated to the date\/time the threshold was last reached; otherwise, the value will remain unchanged. This value may not be \`true\` if the subscription contains items with plans that have \`aggregate_usage=last_ever\`.
    subscriptionBillingThresholds'NonNullableResetBillingCycleAnchor :: (GHC.Maybe.Maybe (StripeAPI.Common.Nullable GHC.Types.Bool))
  }
  deriving
    ( GHC.Show.Show,
      GHC.Classes.Eq
    )

instance Data.Aeson.Types.ToJSON.ToJSON SubscriptionBillingThresholds'NonNullable where
  toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("amount_gte" Data.Aeson.Types.ToJSON..=)) (subscriptionBillingThresholds'NonNullableAmountGte obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("reset_billing_cycle_anchor" Data.Aeson.Types.ToJSON..=)) (subscriptionBillingThresholds'NonNullableResetBillingCycleAnchor obj) : GHC.Base.mempty))
  toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("amount_gte" Data.Aeson.Types.ToJSON..=)) (subscriptionBillingThresholds'NonNullableAmountGte obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("reset_billing_cycle_anchor" Data.Aeson.Types.ToJSON..=)) (subscriptionBillingThresholds'NonNullableResetBillingCycleAnchor obj) : GHC.Base.mempty)))

instance Data.Aeson.Types.FromJSON.FromJSON SubscriptionBillingThresholds'NonNullable where
  parseJSON = Data.Aeson.Types.FromJSON.withObject "SubscriptionBillingThresholds'NonNullable" (\obj -> (GHC.Base.pure SubscriptionBillingThresholds'NonNullable GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "amount_gte")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "reset_billing_cycle_anchor"))

-- | Create a new 'SubscriptionBillingThresholds'NonNullable' with all required fields.
mkSubscriptionBillingThresholds'NonNullable :: SubscriptionBillingThresholds'NonNullable
mkSubscriptionBillingThresholds'NonNullable =
  SubscriptionBillingThresholds'NonNullable
    { subscriptionBillingThresholds'NonNullableAmountGte = GHC.Maybe.Nothing,
      subscriptionBillingThresholds'NonNullableResetBillingCycleAnchor = GHC.Maybe.Nothing
    }

-- | Defines the object schema located at @components.schemas.subscription.properties.cancellation_details.anyOf@ in the specification.
--
-- Details about why this subscription was cancelled
data SubscriptionCancellationDetails'NonNullable = SubscriptionCancellationDetails'NonNullable
  { -- | comment: Additional comments about why the user canceled the subscription, if the subscription was canceled explicitly by the user.
    --
    -- Constraints:
    --
    -- * Maximum length of 5000
    subscriptionCancellationDetails'NonNullableComment :: (GHC.Maybe.Maybe (StripeAPI.Common.Nullable Data.Text.Internal.Text)),
    -- | feedback: The customer submitted reason for why they canceled, if the subscription was canceled explicitly by the user.
    subscriptionCancellationDetails'NonNullableFeedback :: (GHC.Maybe.Maybe (StripeAPI.Common.Nullable SubscriptionCancellationDetails'NonNullableFeedback'NonNullable)),
    -- | reason: Why this subscription was canceled.
    subscriptionCancellationDetails'NonNullableReason :: (GHC.Maybe.Maybe (StripeAPI.Common.Nullable SubscriptionCancellationDetails'NonNullableReason'NonNullable))
  }
  deriving
    ( GHC.Show.Show,
      GHC.Classes.Eq
    )

instance Data.Aeson.Types.ToJSON.ToJSON SubscriptionCancellationDetails'NonNullable where
  toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("comment" Data.Aeson.Types.ToJSON..=)) (subscriptionCancellationDetails'NonNullableComment obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("feedback" Data.Aeson.Types.ToJSON..=)) (subscriptionCancellationDetails'NonNullableFeedback obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("reason" Data.Aeson.Types.ToJSON..=)) (subscriptionCancellationDetails'NonNullableReason obj) : GHC.Base.mempty))
  toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("comment" Data.Aeson.Types.ToJSON..=)) (subscriptionCancellationDetails'NonNullableComment obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("feedback" Data.Aeson.Types.ToJSON..=)) (subscriptionCancellationDetails'NonNullableFeedback obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("reason" Data.Aeson.Types.ToJSON..=)) (subscriptionCancellationDetails'NonNullableReason obj) : GHC.Base.mempty)))

instance Data.Aeson.Types.FromJSON.FromJSON SubscriptionCancellationDetails'NonNullable where
  parseJSON = Data.Aeson.Types.FromJSON.withObject "SubscriptionCancellationDetails'NonNullable" (\obj -> ((GHC.Base.pure SubscriptionCancellationDetails'NonNullable GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "comment")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "feedback")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "reason"))

-- | Create a new 'SubscriptionCancellationDetails'NonNullable' with all required fields.
mkSubscriptionCancellationDetails'NonNullable :: SubscriptionCancellationDetails'NonNullable
mkSubscriptionCancellationDetails'NonNullable =
  SubscriptionCancellationDetails'NonNullable
    { subscriptionCancellationDetails'NonNullableComment = GHC.Maybe.Nothing,
      subscriptionCancellationDetails'NonNullableFeedback = GHC.Maybe.Nothing,
      subscriptionCancellationDetails'NonNullableReason = GHC.Maybe.Nothing
    }

-- | Defines the enum schema located at @components.schemas.subscription.properties.cancellation_details.anyOf.properties.feedback@ in the specification.
--
-- The customer submitted reason for why they canceled, if the subscription was canceled explicitly by the user.
data SubscriptionCancellationDetails'NonNullableFeedback'NonNullable
  = -- | This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
    SubscriptionCancellationDetails'NonNullableFeedback'NonNullableOther Data.Aeson.Types.Internal.Value
  | -- | This constructor can be used to send values to the server which are not present in the specification yet.
    SubscriptionCancellationDetails'NonNullableFeedback'NonNullableTyped Data.Text.Internal.Text
  | -- | Represents the JSON value @"customer_service"@
    SubscriptionCancellationDetails'NonNullableFeedback'NonNullableEnumCustomerService
  | -- | Represents the JSON value @"low_quality"@
    SubscriptionCancellationDetails'NonNullableFeedback'NonNullableEnumLowQuality
  | -- | Represents the JSON value @"missing_features"@
    SubscriptionCancellationDetails'NonNullableFeedback'NonNullableEnumMissingFeatures
  | -- | Represents the JSON value @"other"@
    SubscriptionCancellationDetails'NonNullableFeedback'NonNullableEnumOther
  | -- | Represents the JSON value @"switched_service"@
    SubscriptionCancellationDetails'NonNullableFeedback'NonNullableEnumSwitchedService
  | -- | Represents the JSON value @"too_complex"@
    SubscriptionCancellationDetails'NonNullableFeedback'NonNullableEnumTooComplex
  | -- | Represents the JSON value @"too_expensive"@
    SubscriptionCancellationDetails'NonNullableFeedback'NonNullableEnumTooExpensive
  | -- | Represents the JSON value @"unused"@
    SubscriptionCancellationDetails'NonNullableFeedback'NonNullableEnumUnused
  deriving (GHC.Show.Show, GHC.Classes.Eq)

instance Data.Aeson.Types.ToJSON.ToJSON SubscriptionCancellationDetails'NonNullableFeedback'NonNullable where
  toJSON (SubscriptionCancellationDetails'NonNullableFeedback'NonNullableOther val) = val
  toJSON (SubscriptionCancellationDetails'NonNullableFeedback'NonNullableTyped val) = Data.Aeson.Types.ToJSON.toJSON val
  toJSON (SubscriptionCancellationDetails'NonNullableFeedback'NonNullableEnumCustomerService) = "customer_service"
  toJSON (SubscriptionCancellationDetails'NonNullableFeedback'NonNullableEnumLowQuality) = "low_quality"
  toJSON (SubscriptionCancellationDetails'NonNullableFeedback'NonNullableEnumMissingFeatures) = "missing_features"
  toJSON (SubscriptionCancellationDetails'NonNullableFeedback'NonNullableEnumOther) = "other"
  toJSON (SubscriptionCancellationDetails'NonNullableFeedback'NonNullableEnumSwitchedService) = "switched_service"
  toJSON (SubscriptionCancellationDetails'NonNullableFeedback'NonNullableEnumTooComplex) = "too_complex"
  toJSON (SubscriptionCancellationDetails'NonNullableFeedback'NonNullableEnumTooExpensive) = "too_expensive"
  toJSON (SubscriptionCancellationDetails'NonNullableFeedback'NonNullableEnumUnused) = "unused"

instance Data.Aeson.Types.FromJSON.FromJSON SubscriptionCancellationDetails'NonNullableFeedback'NonNullable where
  parseJSON val =
    GHC.Base.pure
      ( if
            | val GHC.Classes.== "customer_service" -> SubscriptionCancellationDetails'NonNullableFeedback'NonNullableEnumCustomerService
            | val GHC.Classes.== "low_quality" -> SubscriptionCancellationDetails'NonNullableFeedback'NonNullableEnumLowQuality
            | val GHC.Classes.== "missing_features" -> SubscriptionCancellationDetails'NonNullableFeedback'NonNullableEnumMissingFeatures
            | val GHC.Classes.== "other" -> SubscriptionCancellationDetails'NonNullableFeedback'NonNullableEnumOther
            | val GHC.Classes.== "switched_service" -> SubscriptionCancellationDetails'NonNullableFeedback'NonNullableEnumSwitchedService
            | val GHC.Classes.== "too_complex" -> SubscriptionCancellationDetails'NonNullableFeedback'NonNullableEnumTooComplex
            | val GHC.Classes.== "too_expensive" -> SubscriptionCancellationDetails'NonNullableFeedback'NonNullableEnumTooExpensive
            | val GHC.Classes.== "unused" -> SubscriptionCancellationDetails'NonNullableFeedback'NonNullableEnumUnused
            | GHC.Base.otherwise -> SubscriptionCancellationDetails'NonNullableFeedback'NonNullableOther val
      )

-- | Defines the enum schema located at @components.schemas.subscription.properties.cancellation_details.anyOf.properties.reason@ in the specification.
--
-- Why this subscription was canceled.
data SubscriptionCancellationDetails'NonNullableReason'NonNullable
  = -- | This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
    SubscriptionCancellationDetails'NonNullableReason'NonNullableOther Data.Aeson.Types.Internal.Value
  | -- | This constructor can be used to send values to the server which are not present in the specification yet.
    SubscriptionCancellationDetails'NonNullableReason'NonNullableTyped Data.Text.Internal.Text
  | -- | Represents the JSON value @"cancellation_requested"@
    SubscriptionCancellationDetails'NonNullableReason'NonNullableEnumCancellationRequested
  | -- | Represents the JSON value @"payment_disputed"@
    SubscriptionCancellationDetails'NonNullableReason'NonNullableEnumPaymentDisputed
  | -- | Represents the JSON value @"payment_failed"@
    SubscriptionCancellationDetails'NonNullableReason'NonNullableEnumPaymentFailed
  deriving (GHC.Show.Show, GHC.Classes.Eq)

instance Data.Aeson.Types.ToJSON.ToJSON SubscriptionCancellationDetails'NonNullableReason'NonNullable where
  toJSON (SubscriptionCancellationDetails'NonNullableReason'NonNullableOther val) = val
  toJSON (SubscriptionCancellationDetails'NonNullableReason'NonNullableTyped val) = Data.Aeson.Types.ToJSON.toJSON val
  toJSON (SubscriptionCancellationDetails'NonNullableReason'NonNullableEnumCancellationRequested) = "cancellation_requested"
  toJSON (SubscriptionCancellationDetails'NonNullableReason'NonNullableEnumPaymentDisputed) = "payment_disputed"
  toJSON (SubscriptionCancellationDetails'NonNullableReason'NonNullableEnumPaymentFailed) = "payment_failed"

instance Data.Aeson.Types.FromJSON.FromJSON SubscriptionCancellationDetails'NonNullableReason'NonNullable where
  parseJSON val =
    GHC.Base.pure
      ( if
            | val GHC.Classes.== "cancellation_requested" -> SubscriptionCancellationDetails'NonNullableReason'NonNullableEnumCancellationRequested
            | val GHC.Classes.== "payment_disputed" -> SubscriptionCancellationDetails'NonNullableReason'NonNullableEnumPaymentDisputed
            | val GHC.Classes.== "payment_failed" -> SubscriptionCancellationDetails'NonNullableReason'NonNullableEnumPaymentFailed
            | GHC.Base.otherwise -> SubscriptionCancellationDetails'NonNullableReason'NonNullableOther val
      )

-- | Defines the enum schema located at @components.schemas.subscription.properties.collection_method@ in the specification.
--
-- Either \`charge_automatically\`, or \`send_invoice\`. When charging automatically, Stripe will attempt to pay this subscription at the end of the cycle using the default source attached to the customer. When sending an invoice, Stripe will email your customer an invoice with payment instructions and mark the subscription as \`active\`.
data SubscriptionCollectionMethod'
  = -- | This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
    SubscriptionCollectionMethod'Other Data.Aeson.Types.Internal.Value
  | -- | This constructor can be used to send values to the server which are not present in the specification yet.
    SubscriptionCollectionMethod'Typed Data.Text.Internal.Text
  | -- | Represents the JSON value @"charge_automatically"@
    SubscriptionCollectionMethod'EnumChargeAutomatically
  | -- | Represents the JSON value @"send_invoice"@
    SubscriptionCollectionMethod'EnumSendInvoice
  deriving (GHC.Show.Show, GHC.Classes.Eq)

instance Data.Aeson.Types.ToJSON.ToJSON SubscriptionCollectionMethod' where
  toJSON (SubscriptionCollectionMethod'Other val) = val
  toJSON (SubscriptionCollectionMethod'Typed val) = Data.Aeson.Types.ToJSON.toJSON val
  toJSON (SubscriptionCollectionMethod'EnumChargeAutomatically) = "charge_automatically"
  toJSON (SubscriptionCollectionMethod'EnumSendInvoice) = "send_invoice"

instance Data.Aeson.Types.FromJSON.FromJSON SubscriptionCollectionMethod' where
  parseJSON val =
    GHC.Base.pure
      ( if
            | val GHC.Classes.== "charge_automatically" -> SubscriptionCollectionMethod'EnumChargeAutomatically
            | val GHC.Classes.== "send_invoice" -> SubscriptionCollectionMethod'EnumSendInvoice
            | GHC.Base.otherwise -> SubscriptionCollectionMethod'Other val
      )

-- | Defines the oneOf schema located at @components.schemas.subscription.properties.customer.anyOf@ in the specification.
--
-- ID of the customer who owns the subscription.
data SubscriptionCustomer'Variants
  = SubscriptionCustomer'Text Data.Text.Internal.Text
  | SubscriptionCustomer'Customer Customer
  | SubscriptionCustomer'DeletedCustomer DeletedCustomer
  deriving (GHC.Show.Show, GHC.Classes.Eq)

instance Data.Aeson.Types.ToJSON.ToJSON SubscriptionCustomer'Variants where
  toJSON (SubscriptionCustomer'Text a) = Data.Aeson.Types.ToJSON.toJSON a
  toJSON (SubscriptionCustomer'Customer a) = Data.Aeson.Types.ToJSON.toJSON a
  toJSON (SubscriptionCustomer'DeletedCustomer a) = Data.Aeson.Types.ToJSON.toJSON a

instance Data.Aeson.Types.FromJSON.FromJSON SubscriptionCustomer'Variants where
  parseJSON val = case (SubscriptionCustomer'Text Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((SubscriptionCustomer'Customer Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((SubscriptionCustomer'DeletedCustomer Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> Data.Aeson.Types.Internal.Error "No variant matched")) of
    Data.Aeson.Types.Internal.Success a -> GHC.Base.pure a
    Data.Aeson.Types.Internal.Error a -> Control.Monad.Fail.fail a

-- | Defines the oneOf schema located at @components.schemas.subscription.properties.default_payment_method.anyOf@ in the specification.
--
-- ID of the default payment method for the subscription. It must belong to the customer associated with the subscription. This takes precedence over \`default_source\`. If neither are set, invoices will use the customer\'s [invoice_settings.default_payment_method](https:\/\/stripe.com\/docs\/api\/customers\/object\#customer_object-invoice_settings-default_payment_method) or [default_source](https:\/\/stripe.com\/docs\/api\/customers\/object\#customer_object-default_source).
data SubscriptionDefaultPaymentMethod'NonNullableVariants
  = SubscriptionDefaultPaymentMethod'NonNullableText Data.Text.Internal.Text
  | SubscriptionDefaultPaymentMethod'NonNullablePaymentMethod PaymentMethod
  deriving (GHC.Show.Show, GHC.Classes.Eq)

instance Data.Aeson.Types.ToJSON.ToJSON SubscriptionDefaultPaymentMethod'NonNullableVariants where
  toJSON (SubscriptionDefaultPaymentMethod'NonNullableText a) = Data.Aeson.Types.ToJSON.toJSON a
  toJSON (SubscriptionDefaultPaymentMethod'NonNullablePaymentMethod a) = Data.Aeson.Types.ToJSON.toJSON a

instance Data.Aeson.Types.FromJSON.FromJSON SubscriptionDefaultPaymentMethod'NonNullableVariants where
  parseJSON val = case (SubscriptionDefaultPaymentMethod'NonNullableText Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((SubscriptionDefaultPaymentMethod'NonNullablePaymentMethod Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> Data.Aeson.Types.Internal.Error "No variant matched") of
    Data.Aeson.Types.Internal.Success a -> GHC.Base.pure a
    Data.Aeson.Types.Internal.Error a -> Control.Monad.Fail.fail a

-- | Defines the oneOf schema located at @components.schemas.subscription.properties.default_source.anyOf@ in the specification.
--
-- ID of the default payment source for the subscription. It must belong to the customer associated with the subscription and be in a chargeable state. If \`default_payment_method\` is also set, \`default_payment_method\` will take precedence. If neither are set, invoices will use the customer\'s [invoice_settings.default_payment_method](https:\/\/stripe.com\/docs\/api\/customers\/object\#customer_object-invoice_settings-default_payment_method) or [default_source](https:\/\/stripe.com\/docs\/api\/customers\/object\#customer_object-default_source).
data SubscriptionDefaultSource'NonNullableVariants
  = SubscriptionDefaultSource'NonNullableText Data.Text.Internal.Text
  | SubscriptionDefaultSource'NonNullableBankAccount BankAccount
  | SubscriptionDefaultSource'NonNullableCard Card
  | SubscriptionDefaultSource'NonNullableSource Source
  deriving (GHC.Show.Show, GHC.Classes.Eq)

instance Data.Aeson.Types.ToJSON.ToJSON SubscriptionDefaultSource'NonNullableVariants where
  toJSON (SubscriptionDefaultSource'NonNullableText a) = Data.Aeson.Types.ToJSON.toJSON a
  toJSON (SubscriptionDefaultSource'NonNullableBankAccount a) = Data.Aeson.Types.ToJSON.toJSON a
  toJSON (SubscriptionDefaultSource'NonNullableCard a) = Data.Aeson.Types.ToJSON.toJSON a
  toJSON (SubscriptionDefaultSource'NonNullableSource a) = Data.Aeson.Types.ToJSON.toJSON a

instance Data.Aeson.Types.FromJSON.FromJSON SubscriptionDefaultSource'NonNullableVariants where
  parseJSON val = case (SubscriptionDefaultSource'NonNullableText Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((SubscriptionDefaultSource'NonNullableBankAccount Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((SubscriptionDefaultSource'NonNullableCard Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((SubscriptionDefaultSource'NonNullableSource Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> Data.Aeson.Types.Internal.Error "No variant matched"))) of
    Data.Aeson.Types.Internal.Success a -> GHC.Base.pure a
    Data.Aeson.Types.Internal.Error a -> Control.Monad.Fail.fail a

-- | Defines the object schema located at @components.schemas.subscription.properties.discount.anyOf@ in the specification.
--
-- Describes the current discount applied to this subscription, if there is one. When billing, a discount applied to a subscription overrides a discount applied on a customer-wide basis.
data SubscriptionDiscount'NonNullable = SubscriptionDiscount'NonNullable
  { -- | checkout_session: The Checkout session that this coupon is applied to, if it is applied to a particular session in payment mode. Will not be present for subscription mode.
    --
    -- Constraints:
    --
    -- * Maximum length of 5000
    subscriptionDiscount'NonNullableCheckoutSession :: (GHC.Maybe.Maybe (StripeAPI.Common.Nullable Data.Text.Internal.Text)),
    -- | coupon: A coupon contains information about a percent-off or amount-off discount you
    -- might want to apply to a customer. Coupons may be applied to [subscriptions](https:\/\/stripe.com\/docs\/api\#subscriptions), [invoices](https:\/\/stripe.com\/docs\/api\#invoices),
    -- [checkout sessions](https:\/\/stripe.com\/docs\/api\/checkout\/sessions), [quotes](https:\/\/stripe.com\/docs\/api\#quotes), and more. Coupons do not work with conventional one-off [charges](https:\/\/stripe.com\/docs\/api\#create_charge) or [payment intents](https:\/\/stripe.com\/docs\/api\/payment_intents).
    subscriptionDiscount'NonNullableCoupon :: (GHC.Maybe.Maybe Coupon),
    -- | customer: The ID of the customer associated with this discount.
    subscriptionDiscount'NonNullableCustomer :: (GHC.Maybe.Maybe (StripeAPI.Common.Nullable SubscriptionDiscount'NonNullableCustomer'NonNullableVariants)),
    -- | end: If the coupon has a duration of \`repeating\`, the date that this discount will end. If the coupon has a duration of \`once\` or \`forever\`, this attribute will be null.
    subscriptionDiscount'NonNullableEnd :: (GHC.Maybe.Maybe (StripeAPI.Common.Nullable GHC.Types.Int)),
    -- | id: The ID of the discount object. Discounts cannot be fetched by ID. Use \`expand[]=discounts\` in API calls to expand discount IDs in an array.
    --
    -- Constraints:
    --
    -- * Maximum length of 5000
    subscriptionDiscount'NonNullableId :: (GHC.Maybe.Maybe Data.Text.Internal.Text),
    -- | invoice: The invoice that the discount\'s coupon was applied to, if it was applied directly to a particular invoice.
    --
    -- Constraints:
    --
    -- * Maximum length of 5000
    subscriptionDiscount'NonNullableInvoice :: (GHC.Maybe.Maybe (StripeAPI.Common.Nullable Data.Text.Internal.Text)),
    -- | invoice_item: The invoice item \`id\` (or invoice line item \`id\` for invoice line items of type=\'subscription\') that the discount\'s coupon was applied to, if it was applied directly to a particular invoice item or invoice line item.
    --
    -- Constraints:
    --
    -- * Maximum length of 5000
    subscriptionDiscount'NonNullableInvoiceItem :: (GHC.Maybe.Maybe (StripeAPI.Common.Nullable Data.Text.Internal.Text)),
    -- | object: String representing the object\'s type. Objects of the same type share the same value.
    subscriptionDiscount'NonNullableObject :: (GHC.Maybe.Maybe SubscriptionDiscount'NonNullableObject'),
    -- | promotion_code: The promotion code applied to create this discount.
    subscriptionDiscount'NonNullablePromotionCode :: (GHC.Maybe.Maybe (StripeAPI.Common.Nullable SubscriptionDiscount'NonNullablePromotionCode'NonNullableVariants)),
    -- | start: Date that the coupon was applied.
    subscriptionDiscount'NonNullableStart :: (GHC.Maybe.Maybe GHC.Types.Int),
    -- | subscription: The subscription that this coupon is applied to, if it is applied to a particular subscription.
    --
    -- Constraints:
    --
    -- * Maximum length of 5000
    subscriptionDiscount'NonNullableSubscription :: (GHC.Maybe.Maybe (StripeAPI.Common.Nullable Data.Text.Internal.Text))
  }
  deriving
    ( GHC.Show.Show,
      GHC.Classes.Eq
    )

instance Data.Aeson.Types.ToJSON.ToJSON SubscriptionDiscount'NonNullable where
  toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("checkout_session" Data.Aeson.Types.ToJSON..=)) (subscriptionDiscount'NonNullableCheckoutSession obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("coupon" Data.Aeson.Types.ToJSON..=)) (subscriptionDiscount'NonNullableCoupon obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("customer" Data.Aeson.Types.ToJSON..=)) (subscriptionDiscount'NonNullableCustomer obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("end" Data.Aeson.Types.ToJSON..=)) (subscriptionDiscount'NonNullableEnd obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("id" Data.Aeson.Types.ToJSON..=)) (subscriptionDiscount'NonNullableId obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("invoice" Data.Aeson.Types.ToJSON..=)) (subscriptionDiscount'NonNullableInvoice obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("invoice_item" Data.Aeson.Types.ToJSON..=)) (subscriptionDiscount'NonNullableInvoiceItem obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("object" Data.Aeson.Types.ToJSON..=)) (subscriptionDiscount'NonNullableObject obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("promotion_code" Data.Aeson.Types.ToJSON..=)) (subscriptionDiscount'NonNullablePromotionCode obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("start" Data.Aeson.Types.ToJSON..=)) (subscriptionDiscount'NonNullableStart obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("subscription" Data.Aeson.Types.ToJSON..=)) (subscriptionDiscount'NonNullableSubscription obj) : GHC.Base.mempty))
  toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("checkout_session" Data.Aeson.Types.ToJSON..=)) (subscriptionDiscount'NonNullableCheckoutSession obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("coupon" Data.Aeson.Types.ToJSON..=)) (subscriptionDiscount'NonNullableCoupon obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("customer" Data.Aeson.Types.ToJSON..=)) (subscriptionDiscount'NonNullableCustomer obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("end" Data.Aeson.Types.ToJSON..=)) (subscriptionDiscount'NonNullableEnd obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("id" Data.Aeson.Types.ToJSON..=)) (subscriptionDiscount'NonNullableId obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("invoice" Data.Aeson.Types.ToJSON..=)) (subscriptionDiscount'NonNullableInvoice obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("invoice_item" Data.Aeson.Types.ToJSON..=)) (subscriptionDiscount'NonNullableInvoiceItem obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("object" Data.Aeson.Types.ToJSON..=)) (subscriptionDiscount'NonNullableObject obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("promotion_code" Data.Aeson.Types.ToJSON..=)) (subscriptionDiscount'NonNullablePromotionCode obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("start" Data.Aeson.Types.ToJSON..=)) (subscriptionDiscount'NonNullableStart obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("subscription" Data.Aeson.Types.ToJSON..=)) (subscriptionDiscount'NonNullableSubscription obj) : GHC.Base.mempty)))

instance Data.Aeson.Types.FromJSON.FromJSON SubscriptionDiscount'NonNullable where
  parseJSON = Data.Aeson.Types.FromJSON.withObject "SubscriptionDiscount'NonNullable" (\obj -> ((((((((((GHC.Base.pure SubscriptionDiscount'NonNullable GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "checkout_session")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "coupon")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "customer")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "end")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "invoice")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "invoice_item")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "object")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "promotion_code")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "start")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "subscription"))

-- | Create a new 'SubscriptionDiscount'NonNullable' with all required fields.
mkSubscriptionDiscount'NonNullable :: SubscriptionDiscount'NonNullable
mkSubscriptionDiscount'NonNullable =
  SubscriptionDiscount'NonNullable
    { subscriptionDiscount'NonNullableCheckoutSession = GHC.Maybe.Nothing,
      subscriptionDiscount'NonNullableCoupon = GHC.Maybe.Nothing,
      subscriptionDiscount'NonNullableCustomer = GHC.Maybe.Nothing,
      subscriptionDiscount'NonNullableEnd = GHC.Maybe.Nothing,
      subscriptionDiscount'NonNullableId = GHC.Maybe.Nothing,
      subscriptionDiscount'NonNullableInvoice = GHC.Maybe.Nothing,
      subscriptionDiscount'NonNullableInvoiceItem = GHC.Maybe.Nothing,
      subscriptionDiscount'NonNullableObject = GHC.Maybe.Nothing,
      subscriptionDiscount'NonNullablePromotionCode = GHC.Maybe.Nothing,
      subscriptionDiscount'NonNullableStart = GHC.Maybe.Nothing,
      subscriptionDiscount'NonNullableSubscription = GHC.Maybe.Nothing
    }

-- | Defines the oneOf schema located at @components.schemas.subscription.properties.discount.anyOf.properties.customer.anyOf@ in the specification.
--
-- The ID of the customer associated with this discount.
data SubscriptionDiscount'NonNullableCustomer'NonNullableVariants
  = SubscriptionDiscount'NonNullableCustomer'NonNullableText Data.Text.Internal.Text
  | SubscriptionDiscount'NonNullableCustomer'NonNullableCustomer Customer
  | SubscriptionDiscount'NonNullableCustomer'NonNullableDeletedCustomer DeletedCustomer
  deriving (GHC.Show.Show, GHC.Classes.Eq)

instance Data.Aeson.Types.ToJSON.ToJSON SubscriptionDiscount'NonNullableCustomer'NonNullableVariants where
  toJSON (SubscriptionDiscount'NonNullableCustomer'NonNullableText a) = Data.Aeson.Types.ToJSON.toJSON a
  toJSON (SubscriptionDiscount'NonNullableCustomer'NonNullableCustomer a) = Data.Aeson.Types.ToJSON.toJSON a
  toJSON (SubscriptionDiscount'NonNullableCustomer'NonNullableDeletedCustomer a) = Data.Aeson.Types.ToJSON.toJSON a

instance Data.Aeson.Types.FromJSON.FromJSON SubscriptionDiscount'NonNullableCustomer'NonNullableVariants where
  parseJSON val = case (SubscriptionDiscount'NonNullableCustomer'NonNullableText Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((SubscriptionDiscount'NonNullableCustomer'NonNullableCustomer Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((SubscriptionDiscount'NonNullableCustomer'NonNullableDeletedCustomer Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> Data.Aeson.Types.Internal.Error "No variant matched")) of
    Data.Aeson.Types.Internal.Success a -> GHC.Base.pure a
    Data.Aeson.Types.Internal.Error a -> Control.Monad.Fail.fail a

-- | Defines the enum schema located at @components.schemas.subscription.properties.discount.anyOf.properties.object@ in the specification.
--
-- String representing the object\'s type. Objects of the same type share the same value.
data SubscriptionDiscount'NonNullableObject'
  = -- | This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
    SubscriptionDiscount'NonNullableObject'Other Data.Aeson.Types.Internal.Value
  | -- | This constructor can be used to send values to the server which are not present in the specification yet.
    SubscriptionDiscount'NonNullableObject'Typed Data.Text.Internal.Text
  | -- | Represents the JSON value @"discount"@
    SubscriptionDiscount'NonNullableObject'EnumDiscount
  deriving (GHC.Show.Show, GHC.Classes.Eq)

instance Data.Aeson.Types.ToJSON.ToJSON SubscriptionDiscount'NonNullableObject' where
  toJSON (SubscriptionDiscount'NonNullableObject'Other val) = val
  toJSON (SubscriptionDiscount'NonNullableObject'Typed val) = Data.Aeson.Types.ToJSON.toJSON val
  toJSON (SubscriptionDiscount'NonNullableObject'EnumDiscount) = "discount"

instance Data.Aeson.Types.FromJSON.FromJSON SubscriptionDiscount'NonNullableObject' where
  parseJSON val =
    GHC.Base.pure
      ( if
            | val GHC.Classes.== "discount" -> SubscriptionDiscount'NonNullableObject'EnumDiscount
            | GHC.Base.otherwise -> SubscriptionDiscount'NonNullableObject'Other val
      )

-- | Defines the oneOf schema located at @components.schemas.subscription.properties.discount.anyOf.properties.promotion_code.anyOf@ in the specification.
--
-- The promotion code applied to create this discount.
data SubscriptionDiscount'NonNullablePromotionCode'NonNullableVariants
  = SubscriptionDiscount'NonNullablePromotionCode'NonNullableText Data.Text.Internal.Text
  | SubscriptionDiscount'NonNullablePromotionCode'NonNullablePromotionCode PromotionCode
  deriving (GHC.Show.Show, GHC.Classes.Eq)

instance Data.Aeson.Types.ToJSON.ToJSON SubscriptionDiscount'NonNullablePromotionCode'NonNullableVariants where
  toJSON (SubscriptionDiscount'NonNullablePromotionCode'NonNullableText a) = Data.Aeson.Types.ToJSON.toJSON a
  toJSON (SubscriptionDiscount'NonNullablePromotionCode'NonNullablePromotionCode a) = Data.Aeson.Types.ToJSON.toJSON a

instance Data.Aeson.Types.FromJSON.FromJSON SubscriptionDiscount'NonNullablePromotionCode'NonNullableVariants where
  parseJSON val = case (SubscriptionDiscount'NonNullablePromotionCode'NonNullableText Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((SubscriptionDiscount'NonNullablePromotionCode'NonNullablePromotionCode Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> Data.Aeson.Types.Internal.Error "No variant matched") of
    Data.Aeson.Types.Internal.Success a -> GHC.Base.pure a
    Data.Aeson.Types.Internal.Error a -> Control.Monad.Fail.fail a

-- | Defines the object schema located at @components.schemas.subscription.properties.items@ in the specification.
--
-- List of subscription items, each with an attached price.
data SubscriptionItems' = SubscriptionItems'
  { -- | data: Details about each object.
    subscriptionItems'Data :: ([SubscriptionItem]),
    -- | has_more: True if this list has another page of items after this one that can be fetched.
    subscriptionItems'HasMore :: GHC.Types.Bool,
    -- | url: The URL where this list can be accessed.
    --
    -- Constraints:
    --
    -- * Maximum length of 5000
    subscriptionItems'Url :: Data.Text.Internal.Text
  }
  deriving
    ( GHC.Show.Show,
      GHC.Classes.Eq
    )

instance Data.Aeson.Types.ToJSON.ToJSON SubscriptionItems' where
  toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["data" Data.Aeson.Types.ToJSON..= subscriptionItems'Data obj] : ["has_more" Data.Aeson.Types.ToJSON..= subscriptionItems'HasMore obj] : ["url" Data.Aeson.Types.ToJSON..= subscriptionItems'Url obj] : ["object" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "list"] : GHC.Base.mempty))
  toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["data" Data.Aeson.Types.ToJSON..= subscriptionItems'Data obj] : ["has_more" Data.Aeson.Types.ToJSON..= subscriptionItems'HasMore obj] : ["url" Data.Aeson.Types.ToJSON..= subscriptionItems'Url obj] : ["object" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "list"] : GHC.Base.mempty)))

instance Data.Aeson.Types.FromJSON.FromJSON SubscriptionItems' where
  parseJSON = Data.Aeson.Types.FromJSON.withObject "SubscriptionItems'" (\obj -> ((GHC.Base.pure SubscriptionItems' GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "data")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "has_more")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "url"))

-- | Create a new 'SubscriptionItems'' with all required fields.
mkSubscriptionItems' ::
  -- | 'subscriptionItems'Data'
  [SubscriptionItem] ->
  -- | 'subscriptionItems'HasMore'
  GHC.Types.Bool ->
  -- | 'subscriptionItems'Url'
  Data.Text.Internal.Text ->
  SubscriptionItems'
mkSubscriptionItems' subscriptionItems'Data subscriptionItems'HasMore subscriptionItems'Url =
  SubscriptionItems'
    { subscriptionItems'Data = subscriptionItems'Data,
      subscriptionItems'HasMore = subscriptionItems'HasMore,
      subscriptionItems'Url = subscriptionItems'Url
    }

-- | Defines the oneOf schema located at @components.schemas.subscription.properties.latest_invoice.anyOf@ in the specification.
--
-- The most recent invoice this subscription has generated.
data SubscriptionLatestInvoice'NonNullableVariants
  = SubscriptionLatestInvoice'NonNullableText Data.Text.Internal.Text
  | SubscriptionLatestInvoice'NonNullableInvoice Invoice
  deriving (GHC.Show.Show, GHC.Classes.Eq)

instance Data.Aeson.Types.ToJSON.ToJSON SubscriptionLatestInvoice'NonNullableVariants where
  toJSON (SubscriptionLatestInvoice'NonNullableText a) = Data.Aeson.Types.ToJSON.toJSON a
  toJSON (SubscriptionLatestInvoice'NonNullableInvoice a) = Data.Aeson.Types.ToJSON.toJSON a

instance Data.Aeson.Types.FromJSON.FromJSON SubscriptionLatestInvoice'NonNullableVariants where
  parseJSON val = case (SubscriptionLatestInvoice'NonNullableText Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((SubscriptionLatestInvoice'NonNullableInvoice Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> Data.Aeson.Types.Internal.Error "No variant matched") of
    Data.Aeson.Types.Internal.Success a -> GHC.Base.pure a
    Data.Aeson.Types.Internal.Error a -> Control.Monad.Fail.fail a

-- | Defines the oneOf schema located at @components.schemas.subscription.properties.on_behalf_of.anyOf@ in the specification.
--
-- The account (if any) the charge was made on behalf of for charges associated with this subscription. See the Connect documentation for details.
data SubscriptionOnBehalfOf'NonNullableVariants
  = SubscriptionOnBehalfOf'NonNullableText Data.Text.Internal.Text
  | SubscriptionOnBehalfOf'NonNullableAccount Account
  deriving (GHC.Show.Show, GHC.Classes.Eq)

instance Data.Aeson.Types.ToJSON.ToJSON SubscriptionOnBehalfOf'NonNullableVariants where
  toJSON (SubscriptionOnBehalfOf'NonNullableText a) = Data.Aeson.Types.ToJSON.toJSON a
  toJSON (SubscriptionOnBehalfOf'NonNullableAccount a) = Data.Aeson.Types.ToJSON.toJSON a

instance Data.Aeson.Types.FromJSON.FromJSON SubscriptionOnBehalfOf'NonNullableVariants where
  parseJSON val = case (SubscriptionOnBehalfOf'NonNullableText Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((SubscriptionOnBehalfOf'NonNullableAccount Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> Data.Aeson.Types.Internal.Error "No variant matched") of
    Data.Aeson.Types.Internal.Success a -> GHC.Base.pure a
    Data.Aeson.Types.Internal.Error a -> Control.Monad.Fail.fail a

-- | Defines the object schema located at @components.schemas.subscription.properties.pause_collection.anyOf@ in the specification.
--
-- If specified, payment collection for this subscription will be paused.
data SubscriptionPauseCollection'NonNullable = SubscriptionPauseCollection'NonNullable
  { -- | behavior: The payment collection behavior for this subscription while paused. One of \`keep_as_draft\`, \`mark_uncollectible\`, or \`void\`.
    subscriptionPauseCollection'NonNullableBehavior :: (GHC.Maybe.Maybe SubscriptionPauseCollection'NonNullableBehavior'),
    -- | resumes_at: The time after which the subscription will resume collecting payments.
    subscriptionPauseCollection'NonNullableResumesAt :: (GHC.Maybe.Maybe (StripeAPI.Common.Nullable GHC.Types.Int))
  }
  deriving
    ( GHC.Show.Show,
      GHC.Classes.Eq
    )

instance Data.Aeson.Types.ToJSON.ToJSON SubscriptionPauseCollection'NonNullable where
  toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("behavior" Data.Aeson.Types.ToJSON..=)) (subscriptionPauseCollection'NonNullableBehavior obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("resumes_at" Data.Aeson.Types.ToJSON..=)) (subscriptionPauseCollection'NonNullableResumesAt obj) : GHC.Base.mempty))
  toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("behavior" Data.Aeson.Types.ToJSON..=)) (subscriptionPauseCollection'NonNullableBehavior obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("resumes_at" Data.Aeson.Types.ToJSON..=)) (subscriptionPauseCollection'NonNullableResumesAt obj) : GHC.Base.mempty)))

instance Data.Aeson.Types.FromJSON.FromJSON SubscriptionPauseCollection'NonNullable where
  parseJSON = Data.Aeson.Types.FromJSON.withObject "SubscriptionPauseCollection'NonNullable" (\obj -> (GHC.Base.pure SubscriptionPauseCollection'NonNullable GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "behavior")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "resumes_at"))

-- | Create a new 'SubscriptionPauseCollection'NonNullable' with all required fields.
mkSubscriptionPauseCollection'NonNullable :: SubscriptionPauseCollection'NonNullable
mkSubscriptionPauseCollection'NonNullable =
  SubscriptionPauseCollection'NonNullable
    { subscriptionPauseCollection'NonNullableBehavior = GHC.Maybe.Nothing,
      subscriptionPauseCollection'NonNullableResumesAt = GHC.Maybe.Nothing
    }

-- | Defines the enum schema located at @components.schemas.subscription.properties.pause_collection.anyOf.properties.behavior@ in the specification.
--
-- The payment collection behavior for this subscription while paused. One of \`keep_as_draft\`, \`mark_uncollectible\`, or \`void\`.
data SubscriptionPauseCollection'NonNullableBehavior'
  = -- | This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
    SubscriptionPauseCollection'NonNullableBehavior'Other Data.Aeson.Types.Internal.Value
  | -- | This constructor can be used to send values to the server which are not present in the specification yet.
    SubscriptionPauseCollection'NonNullableBehavior'Typed Data.Text.Internal.Text
  | -- | Represents the JSON value @"keep_as_draft"@
    SubscriptionPauseCollection'NonNullableBehavior'EnumKeepAsDraft
  | -- | Represents the JSON value @"mark_uncollectible"@
    SubscriptionPauseCollection'NonNullableBehavior'EnumMarkUncollectible
  | -- | Represents the JSON value @"void"@
    SubscriptionPauseCollection'NonNullableBehavior'EnumVoid
  deriving (GHC.Show.Show, GHC.Classes.Eq)

instance Data.Aeson.Types.ToJSON.ToJSON SubscriptionPauseCollection'NonNullableBehavior' where
  toJSON (SubscriptionPauseCollection'NonNullableBehavior'Other val) = val
  toJSON (SubscriptionPauseCollection'NonNullableBehavior'Typed val) = Data.Aeson.Types.ToJSON.toJSON val
  toJSON (SubscriptionPauseCollection'NonNullableBehavior'EnumKeepAsDraft) = "keep_as_draft"
  toJSON (SubscriptionPauseCollection'NonNullableBehavior'EnumMarkUncollectible) = "mark_uncollectible"
  toJSON (SubscriptionPauseCollection'NonNullableBehavior'EnumVoid) = "void"

instance Data.Aeson.Types.FromJSON.FromJSON SubscriptionPauseCollection'NonNullableBehavior' where
  parseJSON val =
    GHC.Base.pure
      ( if
            | val GHC.Classes.== "keep_as_draft" -> SubscriptionPauseCollection'NonNullableBehavior'EnumKeepAsDraft
            | val GHC.Classes.== "mark_uncollectible" -> SubscriptionPauseCollection'NonNullableBehavior'EnumMarkUncollectible
            | val GHC.Classes.== "void" -> SubscriptionPauseCollection'NonNullableBehavior'EnumVoid
            | GHC.Base.otherwise -> SubscriptionPauseCollection'NonNullableBehavior'Other val
      )

-- | Defines the object schema located at @components.schemas.subscription.properties.payment_settings.anyOf@ in the specification.
--
-- Payment settings passed on to invoices created by the subscription.
data SubscriptionPaymentSettings'NonNullable = SubscriptionPaymentSettings'NonNullable
  { -- | payment_method_options: Payment-method-specific configuration to provide to invoices created by the subscription.
    subscriptionPaymentSettings'NonNullablePaymentMethodOptions :: (GHC.Maybe.Maybe (StripeAPI.Common.Nullable SubscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullable)),
    -- | payment_method_types: The list of payment method types to provide to every invoice created by the subscription. If not set, Stripe attempts to automatically determine the types to use by looking at the invoices default payment method, the subscriptions default payment method, the customers default payment method, and your [invoice template settings](https:\/\/dashboard.stripe.com\/settings\/billing\/invoice).
    subscriptionPaymentSettings'NonNullablePaymentMethodTypes :: (GHC.Maybe.Maybe (StripeAPI.Common.Nullable ([SubscriptionPaymentSettings'NonNullablePaymentMethodTypes'NonNullable]))),
    -- | save_default_payment_method: Either \`off\`, or \`on_subscription\`. With \`on_subscription\` Stripe updates \`subscription.default_payment_method\` when a subscription payment succeeds.
    subscriptionPaymentSettings'NonNullableSaveDefaultPaymentMethod :: (GHC.Maybe.Maybe (StripeAPI.Common.Nullable SubscriptionPaymentSettings'NonNullableSaveDefaultPaymentMethod'NonNullable))
  }
  deriving
    ( GHC.Show.Show,
      GHC.Classes.Eq
    )

instance Data.Aeson.Types.ToJSON.ToJSON SubscriptionPaymentSettings'NonNullable where
  toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("payment_method_options" Data.Aeson.Types.ToJSON..=)) (subscriptionPaymentSettings'NonNullablePaymentMethodOptions obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("payment_method_types" Data.Aeson.Types.ToJSON..=)) (subscriptionPaymentSettings'NonNullablePaymentMethodTypes obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("save_default_payment_method" Data.Aeson.Types.ToJSON..=)) (subscriptionPaymentSettings'NonNullableSaveDefaultPaymentMethod obj) : GHC.Base.mempty))
  toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("payment_method_options" Data.Aeson.Types.ToJSON..=)) (subscriptionPaymentSettings'NonNullablePaymentMethodOptions obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("payment_method_types" Data.Aeson.Types.ToJSON..=)) (subscriptionPaymentSettings'NonNullablePaymentMethodTypes obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("save_default_payment_method" Data.Aeson.Types.ToJSON..=)) (subscriptionPaymentSettings'NonNullableSaveDefaultPaymentMethod obj) : GHC.Base.mempty)))

instance Data.Aeson.Types.FromJSON.FromJSON SubscriptionPaymentSettings'NonNullable where
  parseJSON = Data.Aeson.Types.FromJSON.withObject "SubscriptionPaymentSettings'NonNullable" (\obj -> ((GHC.Base.pure SubscriptionPaymentSettings'NonNullable GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "payment_method_options")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "payment_method_types")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "save_default_payment_method"))

-- | Create a new 'SubscriptionPaymentSettings'NonNullable' with all required fields.
mkSubscriptionPaymentSettings'NonNullable :: SubscriptionPaymentSettings'NonNullable
mkSubscriptionPaymentSettings'NonNullable =
  SubscriptionPaymentSettings'NonNullable
    { subscriptionPaymentSettings'NonNullablePaymentMethodOptions = GHC.Maybe.Nothing,
      subscriptionPaymentSettings'NonNullablePaymentMethodTypes = GHC.Maybe.Nothing,
      subscriptionPaymentSettings'NonNullableSaveDefaultPaymentMethod = GHC.Maybe.Nothing
    }

-- | Defines the object schema located at @components.schemas.subscription.properties.payment_settings.anyOf.properties.payment_method_options.anyOf@ in the specification.
--
-- Payment-method-specific configuration to provide to invoices created by the subscription.
data SubscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullable = SubscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullable
  { -- | acss_debit: This sub-hash contains details about the Canadian pre-authorized debit payment method options to pass to invoices created by the subscription.
    subscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableAcssDebit :: (GHC.Maybe.Maybe (StripeAPI.Common.Nullable SubscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableAcssDebit'NonNullable)),
    -- | bancontact: This sub-hash contains details about the Bancontact payment method options to pass to invoices created by the subscription.
    subscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableBancontact :: (GHC.Maybe.Maybe (StripeAPI.Common.Nullable SubscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableBancontact'NonNullable)),
    -- | card: This sub-hash contains details about the Card payment method options to pass to invoices created by the subscription.
    subscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableCard :: (GHC.Maybe.Maybe (StripeAPI.Common.Nullable SubscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableCard'NonNullable)),
    -- | customer_balance: This sub-hash contains details about the Bank transfer payment method options to pass to invoices created by the subscription.
    subscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableCustomerBalance :: (GHC.Maybe.Maybe (StripeAPI.Common.Nullable SubscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableCustomerBalance'NonNullable)),
    -- | konbini: This sub-hash contains details about the Konbini payment method options to pass to invoices created by the subscription.
    subscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableKonbini :: (GHC.Maybe.Maybe (StripeAPI.Common.Nullable Data.Aeson.Types.Internal.Object)),
    -- | us_bank_account: This sub-hash contains details about the ACH direct debit payment method options to pass to invoices created by the subscription.
    subscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableUsBankAccount :: (GHC.Maybe.Maybe (StripeAPI.Common.Nullable SubscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableUsBankAccount'NonNullable))
  }
  deriving
    ( GHC.Show.Show,
      GHC.Classes.Eq
    )

instance Data.Aeson.Types.ToJSON.ToJSON SubscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullable where
  toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("acss_debit" Data.Aeson.Types.ToJSON..=)) (subscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableAcssDebit obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("bancontact" Data.Aeson.Types.ToJSON..=)) (subscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableBancontact obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("card" Data.Aeson.Types.ToJSON..=)) (subscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableCard obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("customer_balance" Data.Aeson.Types.ToJSON..=)) (subscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableCustomerBalance obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("konbini" Data.Aeson.Types.ToJSON..=)) (subscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableKonbini obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("us_bank_account" Data.Aeson.Types.ToJSON..=)) (subscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableUsBankAccount obj) : GHC.Base.mempty))
  toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("acss_debit" Data.Aeson.Types.ToJSON..=)) (subscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableAcssDebit obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("bancontact" Data.Aeson.Types.ToJSON..=)) (subscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableBancontact obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("card" Data.Aeson.Types.ToJSON..=)) (subscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableCard obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("customer_balance" Data.Aeson.Types.ToJSON..=)) (subscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableCustomerBalance obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("konbini" Data.Aeson.Types.ToJSON..=)) (subscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableKonbini obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("us_bank_account" Data.Aeson.Types.ToJSON..=)) (subscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableUsBankAccount obj) : GHC.Base.mempty)))

instance Data.Aeson.Types.FromJSON.FromJSON SubscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullable where
  parseJSON = Data.Aeson.Types.FromJSON.withObject "SubscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullable" (\obj -> (((((GHC.Base.pure SubscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullable GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "acss_debit")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "bancontact")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "card")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "customer_balance")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "konbini")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "us_bank_account"))

-- | Create a new 'SubscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullable' with all required fields.
mkSubscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullable :: SubscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullable
mkSubscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullable =
  SubscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullable
    { subscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableAcssDebit = GHC.Maybe.Nothing,
      subscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableBancontact = GHC.Maybe.Nothing,
      subscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableCard = GHC.Maybe.Nothing,
      subscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableCustomerBalance = GHC.Maybe.Nothing,
      subscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableKonbini = GHC.Maybe.Nothing,
      subscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableUsBankAccount = GHC.Maybe.Nothing
    }

-- | Defines the object schema located at @components.schemas.subscription.properties.payment_settings.anyOf.properties.payment_method_options.anyOf.properties.acss_debit.anyOf@ in the specification.
--
-- This sub-hash contains details about the Canadian pre-authorized debit payment method options to pass to invoices created by the subscription.
data SubscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableAcssDebit'NonNullable = SubscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableAcssDebit'NonNullable
  { -- | mandate_options:
    subscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableAcssDebit'NonNullableMandateOptions :: (GHC.Maybe.Maybe InvoicePaymentMethodOptionsAcssDebitMandateOptions),
    -- | verification_method: Bank account verification method.
    subscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableAcssDebit'NonNullableVerificationMethod :: (GHC.Maybe.Maybe SubscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableAcssDebit'NonNullableVerificationMethod')
  }
  deriving
    ( GHC.Show.Show,
      GHC.Classes.Eq
    )

instance Data.Aeson.Types.ToJSON.ToJSON SubscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableAcssDebit'NonNullable where
  toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("mandate_options" Data.Aeson.Types.ToJSON..=)) (subscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableAcssDebit'NonNullableMandateOptions obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("verification_method" Data.Aeson.Types.ToJSON..=)) (subscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableAcssDebit'NonNullableVerificationMethod obj) : GHC.Base.mempty))
  toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("mandate_options" Data.Aeson.Types.ToJSON..=)) (subscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableAcssDebit'NonNullableMandateOptions obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("verification_method" Data.Aeson.Types.ToJSON..=)) (subscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableAcssDebit'NonNullableVerificationMethod obj) : GHC.Base.mempty)))

instance Data.Aeson.Types.FromJSON.FromJSON SubscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableAcssDebit'NonNullable where
  parseJSON = Data.Aeson.Types.FromJSON.withObject "SubscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableAcssDebit'NonNullable" (\obj -> (GHC.Base.pure SubscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableAcssDebit'NonNullable GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "mandate_options")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "verification_method"))

-- | Create a new 'SubscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableAcssDebit'NonNullable' with all required fields.
mkSubscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableAcssDebit'NonNullable :: SubscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableAcssDebit'NonNullable
mkSubscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableAcssDebit'NonNullable =
  SubscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableAcssDebit'NonNullable
    { subscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableAcssDebit'NonNullableMandateOptions = GHC.Maybe.Nothing,
      subscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableAcssDebit'NonNullableVerificationMethod = GHC.Maybe.Nothing
    }

-- | Defines the enum schema located at @components.schemas.subscription.properties.payment_settings.anyOf.properties.payment_method_options.anyOf.properties.acss_debit.anyOf.properties.verification_method@ in the specification.
--
-- Bank account verification method.
data SubscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableAcssDebit'NonNullableVerificationMethod'
  = -- | This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
    SubscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableAcssDebit'NonNullableVerificationMethod'Other Data.Aeson.Types.Internal.Value
  | -- | This constructor can be used to send values to the server which are not present in the specification yet.
    SubscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableAcssDebit'NonNullableVerificationMethod'Typed Data.Text.Internal.Text
  | -- | Represents the JSON value @"automatic"@
    SubscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableAcssDebit'NonNullableVerificationMethod'EnumAutomatic
  | -- | Represents the JSON value @"instant"@
    SubscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableAcssDebit'NonNullableVerificationMethod'EnumInstant
  | -- | Represents the JSON value @"microdeposits"@
    SubscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableAcssDebit'NonNullableVerificationMethod'EnumMicrodeposits
  deriving (GHC.Show.Show, GHC.Classes.Eq)

instance Data.Aeson.Types.ToJSON.ToJSON SubscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableAcssDebit'NonNullableVerificationMethod' where
  toJSON (SubscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableAcssDebit'NonNullableVerificationMethod'Other val) = val
  toJSON (SubscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableAcssDebit'NonNullableVerificationMethod'Typed val) = Data.Aeson.Types.ToJSON.toJSON val
  toJSON (SubscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableAcssDebit'NonNullableVerificationMethod'EnumAutomatic) = "automatic"
  toJSON (SubscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableAcssDebit'NonNullableVerificationMethod'EnumInstant) = "instant"
  toJSON (SubscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableAcssDebit'NonNullableVerificationMethod'EnumMicrodeposits) = "microdeposits"

instance Data.Aeson.Types.FromJSON.FromJSON SubscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableAcssDebit'NonNullableVerificationMethod' where
  parseJSON val =
    GHC.Base.pure
      ( if
            | val GHC.Classes.== "automatic" -> SubscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableAcssDebit'NonNullableVerificationMethod'EnumAutomatic
            | val GHC.Classes.== "instant" -> SubscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableAcssDebit'NonNullableVerificationMethod'EnumInstant
            | val GHC.Classes.== "microdeposits" -> SubscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableAcssDebit'NonNullableVerificationMethod'EnumMicrodeposits
            | GHC.Base.otherwise -> SubscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableAcssDebit'NonNullableVerificationMethod'Other val
      )

-- | Defines the object schema located at @components.schemas.subscription.properties.payment_settings.anyOf.properties.payment_method_options.anyOf.properties.bancontact.anyOf@ in the specification.
--
-- This sub-hash contains details about the Bancontact payment method options to pass to invoices created by the subscription.
data SubscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableBancontact'NonNullable = SubscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableBancontact'NonNullable
  { -- | preferred_language: Preferred language of the Bancontact authorization page that the customer is redirected to.
    subscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableBancontact'NonNullablePreferredLanguage :: (GHC.Maybe.Maybe SubscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableBancontact'NonNullablePreferredLanguage')
  }
  deriving
    ( GHC.Show.Show,
      GHC.Classes.Eq
    )

instance Data.Aeson.Types.ToJSON.ToJSON SubscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableBancontact'NonNullable where
  toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("preferred_language" Data.Aeson.Types.ToJSON..=)) (subscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableBancontact'NonNullablePreferredLanguage obj) : GHC.Base.mempty))
  toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("preferred_language" Data.Aeson.Types.ToJSON..=)) (subscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableBancontact'NonNullablePreferredLanguage obj) : GHC.Base.mempty)))

instance Data.Aeson.Types.FromJSON.FromJSON SubscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableBancontact'NonNullable where
  parseJSON = Data.Aeson.Types.FromJSON.withObject "SubscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableBancontact'NonNullable" (\obj -> GHC.Base.pure SubscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableBancontact'NonNullable GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "preferred_language"))

-- | Create a new 'SubscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableBancontact'NonNullable' with all required fields.
mkSubscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableBancontact'NonNullable :: SubscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableBancontact'NonNullable
mkSubscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableBancontact'NonNullable = SubscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableBancontact'NonNullable {subscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableBancontact'NonNullablePreferredLanguage = GHC.Maybe.Nothing}

-- | Defines the enum schema located at @components.schemas.subscription.properties.payment_settings.anyOf.properties.payment_method_options.anyOf.properties.bancontact.anyOf.properties.preferred_language@ in the specification.
--
-- Preferred language of the Bancontact authorization page that the customer is redirected to.
data SubscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableBancontact'NonNullablePreferredLanguage'
  = -- | This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
    SubscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableBancontact'NonNullablePreferredLanguage'Other Data.Aeson.Types.Internal.Value
  | -- | This constructor can be used to send values to the server which are not present in the specification yet.
    SubscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableBancontact'NonNullablePreferredLanguage'Typed Data.Text.Internal.Text
  | -- | Represents the JSON value @"de"@
    SubscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableBancontact'NonNullablePreferredLanguage'EnumDe
  | -- | Represents the JSON value @"en"@
    SubscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableBancontact'NonNullablePreferredLanguage'EnumEn
  | -- | Represents the JSON value @"fr"@
    SubscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableBancontact'NonNullablePreferredLanguage'EnumFr
  | -- | Represents the JSON value @"nl"@
    SubscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableBancontact'NonNullablePreferredLanguage'EnumNl
  deriving (GHC.Show.Show, GHC.Classes.Eq)

instance Data.Aeson.Types.ToJSON.ToJSON SubscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableBancontact'NonNullablePreferredLanguage' where
  toJSON (SubscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableBancontact'NonNullablePreferredLanguage'Other val) = val
  toJSON (SubscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableBancontact'NonNullablePreferredLanguage'Typed val) = Data.Aeson.Types.ToJSON.toJSON val
  toJSON (SubscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableBancontact'NonNullablePreferredLanguage'EnumDe) = "de"
  toJSON (SubscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableBancontact'NonNullablePreferredLanguage'EnumEn) = "en"
  toJSON (SubscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableBancontact'NonNullablePreferredLanguage'EnumFr) = "fr"
  toJSON (SubscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableBancontact'NonNullablePreferredLanguage'EnumNl) = "nl"

instance Data.Aeson.Types.FromJSON.FromJSON SubscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableBancontact'NonNullablePreferredLanguage' where
  parseJSON val =
    GHC.Base.pure
      ( if
            | val GHC.Classes.== "de" -> SubscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableBancontact'NonNullablePreferredLanguage'EnumDe
            | val GHC.Classes.== "en" -> SubscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableBancontact'NonNullablePreferredLanguage'EnumEn
            | val GHC.Classes.== "fr" -> SubscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableBancontact'NonNullablePreferredLanguage'EnumFr
            | val GHC.Classes.== "nl" -> SubscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableBancontact'NonNullablePreferredLanguage'EnumNl
            | GHC.Base.otherwise -> SubscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableBancontact'NonNullablePreferredLanguage'Other val
      )

-- | Defines the object schema located at @components.schemas.subscription.properties.payment_settings.anyOf.properties.payment_method_options.anyOf.properties.card.anyOf@ in the specification.
--
-- This sub-hash contains details about the Card payment method options to pass to invoices created by the subscription.
data SubscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableCard'NonNullable = SubscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableCard'NonNullable
  { -- | mandate_options:
    subscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableCard'NonNullableMandateOptions :: (GHC.Maybe.Maybe InvoiceMandateOptionsCard),
    -- | network: Selected network to process this Subscription on. Depends on the available networks of the card attached to the Subscription. Can be only set confirm-time.
    subscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableCard'NonNullableNetwork :: (GHC.Maybe.Maybe (StripeAPI.Common.Nullable SubscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableCard'NonNullableNetwork'NonNullable)),
    -- | request_three_d_secure: We strongly recommend that you rely on our SCA Engine to automatically prompt your customers for authentication based on risk level and [other requirements](https:\/\/stripe.com\/docs\/strong-customer-authentication). However, if you wish to request 3D Secure based on logic from your own fraud engine, provide this option. Read our guide on [manually requesting 3D Secure](https:\/\/stripe.com\/docs\/payments\/3d-secure\#manual-three-ds) for more information on how this configuration interacts with Radar and our SCA Engine.
    subscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableCard'NonNullableRequestThreeDSecure :: (GHC.Maybe.Maybe (StripeAPI.Common.Nullable SubscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableCard'NonNullableRequestThreeDSecure'NonNullable))
  }
  deriving
    ( GHC.Show.Show,
      GHC.Classes.Eq
    )

instance Data.Aeson.Types.ToJSON.ToJSON SubscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableCard'NonNullable where
  toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("mandate_options" Data.Aeson.Types.ToJSON..=)) (subscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableCard'NonNullableMandateOptions obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("network" Data.Aeson.Types.ToJSON..=)) (subscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableCard'NonNullableNetwork obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("request_three_d_secure" Data.Aeson.Types.ToJSON..=)) (subscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableCard'NonNullableRequestThreeDSecure obj) : GHC.Base.mempty))
  toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("mandate_options" Data.Aeson.Types.ToJSON..=)) (subscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableCard'NonNullableMandateOptions obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("network" Data.Aeson.Types.ToJSON..=)) (subscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableCard'NonNullableNetwork obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("request_three_d_secure" Data.Aeson.Types.ToJSON..=)) (subscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableCard'NonNullableRequestThreeDSecure obj) : GHC.Base.mempty)))

instance Data.Aeson.Types.FromJSON.FromJSON SubscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableCard'NonNullable where
  parseJSON = Data.Aeson.Types.FromJSON.withObject "SubscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableCard'NonNullable" (\obj -> ((GHC.Base.pure SubscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableCard'NonNullable GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "mandate_options")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "network")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "request_three_d_secure"))

-- | Create a new 'SubscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableCard'NonNullable' with all required fields.
mkSubscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableCard'NonNullable :: SubscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableCard'NonNullable
mkSubscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableCard'NonNullable =
  SubscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableCard'NonNullable
    { subscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableCard'NonNullableMandateOptions = GHC.Maybe.Nothing,
      subscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableCard'NonNullableNetwork = GHC.Maybe.Nothing,
      subscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableCard'NonNullableRequestThreeDSecure = GHC.Maybe.Nothing
    }

-- | Defines the enum schema located at @components.schemas.subscription.properties.payment_settings.anyOf.properties.payment_method_options.anyOf.properties.card.anyOf.properties.network@ in the specification.
--
-- Selected network to process this Subscription on. Depends on the available networks of the card attached to the Subscription. Can be only set confirm-time.
data SubscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableCard'NonNullableNetwork'NonNullable
  = -- | This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
    SubscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableCard'NonNullableNetwork'NonNullableOther Data.Aeson.Types.Internal.Value
  | -- | This constructor can be used to send values to the server which are not present in the specification yet.
    SubscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableCard'NonNullableNetwork'NonNullableTyped Data.Text.Internal.Text
  | -- | Represents the JSON value @"amex"@
    SubscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableCard'NonNullableNetwork'NonNullableEnumAmex
  | -- | Represents the JSON value @"cartes_bancaires"@
    SubscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableCard'NonNullableNetwork'NonNullableEnumCartesBancaires
  | -- | Represents the JSON value @"diners"@
    SubscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableCard'NonNullableNetwork'NonNullableEnumDiners
  | -- | Represents the JSON value @"discover"@
    SubscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableCard'NonNullableNetwork'NonNullableEnumDiscover
  | -- | Represents the JSON value @"eftpos_au"@
    SubscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableCard'NonNullableNetwork'NonNullableEnumEftposAu
  | -- | Represents the JSON value @"interac"@
    SubscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableCard'NonNullableNetwork'NonNullableEnumInterac
  | -- | Represents the JSON value @"jcb"@
    SubscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableCard'NonNullableNetwork'NonNullableEnumJcb
  | -- | Represents the JSON value @"mastercard"@
    SubscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableCard'NonNullableNetwork'NonNullableEnumMastercard
  | -- | Represents the JSON value @"unionpay"@
    SubscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableCard'NonNullableNetwork'NonNullableEnumUnionpay
  | -- | Represents the JSON value @"unknown"@
    SubscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableCard'NonNullableNetwork'NonNullableEnumUnknown
  | -- | Represents the JSON value @"visa"@
    SubscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableCard'NonNullableNetwork'NonNullableEnumVisa
  deriving (GHC.Show.Show, GHC.Classes.Eq)

instance Data.Aeson.Types.ToJSON.ToJSON SubscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableCard'NonNullableNetwork'NonNullable where
  toJSON (SubscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableCard'NonNullableNetwork'NonNullableOther val) = val
  toJSON (SubscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableCard'NonNullableNetwork'NonNullableTyped val) = Data.Aeson.Types.ToJSON.toJSON val
  toJSON (SubscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableCard'NonNullableNetwork'NonNullableEnumAmex) = "amex"
  toJSON (SubscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableCard'NonNullableNetwork'NonNullableEnumCartesBancaires) = "cartes_bancaires"
  toJSON (SubscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableCard'NonNullableNetwork'NonNullableEnumDiners) = "diners"
  toJSON (SubscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableCard'NonNullableNetwork'NonNullableEnumDiscover) = "discover"
  toJSON (SubscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableCard'NonNullableNetwork'NonNullableEnumEftposAu) = "eftpos_au"
  toJSON (SubscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableCard'NonNullableNetwork'NonNullableEnumInterac) = "interac"
  toJSON (SubscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableCard'NonNullableNetwork'NonNullableEnumJcb) = "jcb"
  toJSON (SubscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableCard'NonNullableNetwork'NonNullableEnumMastercard) = "mastercard"
  toJSON (SubscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableCard'NonNullableNetwork'NonNullableEnumUnionpay) = "unionpay"
  toJSON (SubscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableCard'NonNullableNetwork'NonNullableEnumUnknown) = "unknown"
  toJSON (SubscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableCard'NonNullableNetwork'NonNullableEnumVisa) = "visa"

instance Data.Aeson.Types.FromJSON.FromJSON SubscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableCard'NonNullableNetwork'NonNullable where
  parseJSON val =
    GHC.Base.pure
      ( if
            | val GHC.Classes.== "amex" -> SubscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableCard'NonNullableNetwork'NonNullableEnumAmex
            | val GHC.Classes.== "cartes_bancaires" -> SubscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableCard'NonNullableNetwork'NonNullableEnumCartesBancaires
            | val GHC.Classes.== "diners" -> SubscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableCard'NonNullableNetwork'NonNullableEnumDiners
            | val GHC.Classes.== "discover" -> SubscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableCard'NonNullableNetwork'NonNullableEnumDiscover
            | val GHC.Classes.== "eftpos_au" -> SubscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableCard'NonNullableNetwork'NonNullableEnumEftposAu
            | val GHC.Classes.== "interac" -> SubscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableCard'NonNullableNetwork'NonNullableEnumInterac
            | val GHC.Classes.== "jcb" -> SubscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableCard'NonNullableNetwork'NonNullableEnumJcb
            | val GHC.Classes.== "mastercard" -> SubscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableCard'NonNullableNetwork'NonNullableEnumMastercard
            | val GHC.Classes.== "unionpay" -> SubscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableCard'NonNullableNetwork'NonNullableEnumUnionpay
            | val GHC.Classes.== "unknown" -> SubscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableCard'NonNullableNetwork'NonNullableEnumUnknown
            | val GHC.Classes.== "visa" -> SubscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableCard'NonNullableNetwork'NonNullableEnumVisa
            | GHC.Base.otherwise -> SubscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableCard'NonNullableNetwork'NonNullableOther val
      )

-- | Defines the enum schema located at @components.schemas.subscription.properties.payment_settings.anyOf.properties.payment_method_options.anyOf.properties.card.anyOf.properties.request_three_d_secure@ in the specification.
--
-- We strongly recommend that you rely on our SCA Engine to automatically prompt your customers for authentication based on risk level and [other requirements](https:\/\/stripe.com\/docs\/strong-customer-authentication). However, if you wish to request 3D Secure based on logic from your own fraud engine, provide this option. Read our guide on [manually requesting 3D Secure](https:\/\/stripe.com\/docs\/payments\/3d-secure\#manual-three-ds) for more information on how this configuration interacts with Radar and our SCA Engine.
data SubscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableCard'NonNullableRequestThreeDSecure'NonNullable
  = -- | This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
    SubscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableCard'NonNullableRequestThreeDSecure'NonNullableOther Data.Aeson.Types.Internal.Value
  | -- | This constructor can be used to send values to the server which are not present in the specification yet.
    SubscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableCard'NonNullableRequestThreeDSecure'NonNullableTyped Data.Text.Internal.Text
  | -- | Represents the JSON value @"any"@
    SubscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableCard'NonNullableRequestThreeDSecure'NonNullableEnumAny
  | -- | Represents the JSON value @"automatic"@
    SubscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableCard'NonNullableRequestThreeDSecure'NonNullableEnumAutomatic
  deriving (GHC.Show.Show, GHC.Classes.Eq)

instance Data.Aeson.Types.ToJSON.ToJSON SubscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableCard'NonNullableRequestThreeDSecure'NonNullable where
  toJSON (SubscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableCard'NonNullableRequestThreeDSecure'NonNullableOther val) = val
  toJSON (SubscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableCard'NonNullableRequestThreeDSecure'NonNullableTyped val) = Data.Aeson.Types.ToJSON.toJSON val
  toJSON (SubscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableCard'NonNullableRequestThreeDSecure'NonNullableEnumAny) = "any"
  toJSON (SubscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableCard'NonNullableRequestThreeDSecure'NonNullableEnumAutomatic) = "automatic"

instance Data.Aeson.Types.FromJSON.FromJSON SubscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableCard'NonNullableRequestThreeDSecure'NonNullable where
  parseJSON val =
    GHC.Base.pure
      ( if
            | val GHC.Classes.== "any" -> SubscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableCard'NonNullableRequestThreeDSecure'NonNullableEnumAny
            | val GHC.Classes.== "automatic" -> SubscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableCard'NonNullableRequestThreeDSecure'NonNullableEnumAutomatic
            | GHC.Base.otherwise -> SubscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableCard'NonNullableRequestThreeDSecure'NonNullableOther val
      )

-- | Defines the object schema located at @components.schemas.subscription.properties.payment_settings.anyOf.properties.payment_method_options.anyOf.properties.customer_balance.anyOf@ in the specification.
--
-- This sub-hash contains details about the Bank transfer payment method options to pass to invoices created by the subscription.
data SubscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableCustomerBalance'NonNullable = SubscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableCustomerBalance'NonNullable
  { -- | bank_transfer:
    subscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableCustomerBalance'NonNullableBankTransfer :: (GHC.Maybe.Maybe InvoicePaymentMethodOptionsCustomerBalanceBankTransfer),
    -- | funding_type: The funding method type to be used when there are not enough funds in the customer balance. Permitted values include: \`bank_transfer\`.
    subscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableCustomerBalance'NonNullableFundingType :: (GHC.Maybe.Maybe (StripeAPI.Common.Nullable SubscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableCustomerBalance'NonNullableFundingType'NonNullable))
  }
  deriving
    ( GHC.Show.Show,
      GHC.Classes.Eq
    )

instance Data.Aeson.Types.ToJSON.ToJSON SubscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableCustomerBalance'NonNullable where
  toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("bank_transfer" Data.Aeson.Types.ToJSON..=)) (subscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableCustomerBalance'NonNullableBankTransfer obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("funding_type" Data.Aeson.Types.ToJSON..=)) (subscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableCustomerBalance'NonNullableFundingType obj) : GHC.Base.mempty))
  toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("bank_transfer" Data.Aeson.Types.ToJSON..=)) (subscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableCustomerBalance'NonNullableBankTransfer obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("funding_type" Data.Aeson.Types.ToJSON..=)) (subscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableCustomerBalance'NonNullableFundingType obj) : GHC.Base.mempty)))

instance Data.Aeson.Types.FromJSON.FromJSON SubscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableCustomerBalance'NonNullable where
  parseJSON = Data.Aeson.Types.FromJSON.withObject "SubscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableCustomerBalance'NonNullable" (\obj -> (GHC.Base.pure SubscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableCustomerBalance'NonNullable GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "bank_transfer")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "funding_type"))

-- | Create a new 'SubscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableCustomerBalance'NonNullable' with all required fields.
mkSubscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableCustomerBalance'NonNullable :: SubscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableCustomerBalance'NonNullable
mkSubscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableCustomerBalance'NonNullable =
  SubscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableCustomerBalance'NonNullable
    { subscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableCustomerBalance'NonNullableBankTransfer = GHC.Maybe.Nothing,
      subscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableCustomerBalance'NonNullableFundingType = GHC.Maybe.Nothing
    }

-- | Defines the enum schema located at @components.schemas.subscription.properties.payment_settings.anyOf.properties.payment_method_options.anyOf.properties.customer_balance.anyOf.properties.funding_type@ in the specification.
--
-- The funding method type to be used when there are not enough funds in the customer balance. Permitted values include: \`bank_transfer\`.
data SubscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableCustomerBalance'NonNullableFundingType'NonNullable
  = -- | This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
    SubscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableCustomerBalance'NonNullableFundingType'NonNullableOther Data.Aeson.Types.Internal.Value
  | -- | This constructor can be used to send values to the server which are not present in the specification yet.
    SubscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableCustomerBalance'NonNullableFundingType'NonNullableTyped Data.Text.Internal.Text
  | -- | Represents the JSON value @"bank_transfer"@
    SubscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableCustomerBalance'NonNullableFundingType'NonNullableEnumBankTransfer
  deriving (GHC.Show.Show, GHC.Classes.Eq)

instance Data.Aeson.Types.ToJSON.ToJSON SubscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableCustomerBalance'NonNullableFundingType'NonNullable where
  toJSON (SubscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableCustomerBalance'NonNullableFundingType'NonNullableOther val) = val
  toJSON (SubscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableCustomerBalance'NonNullableFundingType'NonNullableTyped val) = Data.Aeson.Types.ToJSON.toJSON val
  toJSON (SubscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableCustomerBalance'NonNullableFundingType'NonNullableEnumBankTransfer) = "bank_transfer"

instance Data.Aeson.Types.FromJSON.FromJSON SubscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableCustomerBalance'NonNullableFundingType'NonNullable where
  parseJSON val =
    GHC.Base.pure
      ( if
            | val GHC.Classes.== "bank_transfer" -> SubscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableCustomerBalance'NonNullableFundingType'NonNullableEnumBankTransfer
            | GHC.Base.otherwise -> SubscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableCustomerBalance'NonNullableFundingType'NonNullableOther val
      )

-- | Defines the object schema located at @components.schemas.subscription.properties.payment_settings.anyOf.properties.payment_method_options.anyOf.properties.us_bank_account.anyOf@ in the specification.
--
-- This sub-hash contains details about the ACH direct debit payment method options to pass to invoices created by the subscription.
data SubscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableUsBankAccount'NonNullable = SubscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableUsBankAccount'NonNullable
  { -- | financial_connections:
    subscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableUsBankAccount'NonNullableFinancialConnections :: (GHC.Maybe.Maybe InvoicePaymentMethodOptionsUsBankAccountLinkedAccountOptions),
    -- | verification_method: Bank account verification method.
    subscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableUsBankAccount'NonNullableVerificationMethod :: (GHC.Maybe.Maybe SubscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableUsBankAccount'NonNullableVerificationMethod')
  }
  deriving
    ( GHC.Show.Show,
      GHC.Classes.Eq
    )

instance Data.Aeson.Types.ToJSON.ToJSON SubscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableUsBankAccount'NonNullable where
  toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("financial_connections" Data.Aeson.Types.ToJSON..=)) (subscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableUsBankAccount'NonNullableFinancialConnections obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("verification_method" Data.Aeson.Types.ToJSON..=)) (subscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableUsBankAccount'NonNullableVerificationMethod obj) : GHC.Base.mempty))
  toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("financial_connections" Data.Aeson.Types.ToJSON..=)) (subscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableUsBankAccount'NonNullableFinancialConnections obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("verification_method" Data.Aeson.Types.ToJSON..=)) (subscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableUsBankAccount'NonNullableVerificationMethod obj) : GHC.Base.mempty)))

instance Data.Aeson.Types.FromJSON.FromJSON SubscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableUsBankAccount'NonNullable where
  parseJSON = Data.Aeson.Types.FromJSON.withObject "SubscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableUsBankAccount'NonNullable" (\obj -> (GHC.Base.pure SubscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableUsBankAccount'NonNullable GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "financial_connections")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "verification_method"))

-- | Create a new 'SubscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableUsBankAccount'NonNullable' with all required fields.
mkSubscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableUsBankAccount'NonNullable :: SubscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableUsBankAccount'NonNullable
mkSubscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableUsBankAccount'NonNullable =
  SubscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableUsBankAccount'NonNullable
    { subscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableUsBankAccount'NonNullableFinancialConnections = GHC.Maybe.Nothing,
      subscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableUsBankAccount'NonNullableVerificationMethod = GHC.Maybe.Nothing
    }

-- | Defines the enum schema located at @components.schemas.subscription.properties.payment_settings.anyOf.properties.payment_method_options.anyOf.properties.us_bank_account.anyOf.properties.verification_method@ in the specification.
--
-- Bank account verification method.
data SubscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableUsBankAccount'NonNullableVerificationMethod'
  = -- | This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
    SubscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableUsBankAccount'NonNullableVerificationMethod'Other Data.Aeson.Types.Internal.Value
  | -- | This constructor can be used to send values to the server which are not present in the specification yet.
    SubscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableUsBankAccount'NonNullableVerificationMethod'Typed Data.Text.Internal.Text
  | -- | Represents the JSON value @"automatic"@
    SubscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableUsBankAccount'NonNullableVerificationMethod'EnumAutomatic
  | -- | Represents the JSON value @"instant"@
    SubscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableUsBankAccount'NonNullableVerificationMethod'EnumInstant
  | -- | Represents the JSON value @"microdeposits"@
    SubscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableUsBankAccount'NonNullableVerificationMethod'EnumMicrodeposits
  deriving (GHC.Show.Show, GHC.Classes.Eq)

instance Data.Aeson.Types.ToJSON.ToJSON SubscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableUsBankAccount'NonNullableVerificationMethod' where
  toJSON (SubscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableUsBankAccount'NonNullableVerificationMethod'Other val) = val
  toJSON (SubscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableUsBankAccount'NonNullableVerificationMethod'Typed val) = Data.Aeson.Types.ToJSON.toJSON val
  toJSON (SubscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableUsBankAccount'NonNullableVerificationMethod'EnumAutomatic) = "automatic"
  toJSON (SubscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableUsBankAccount'NonNullableVerificationMethod'EnumInstant) = "instant"
  toJSON (SubscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableUsBankAccount'NonNullableVerificationMethod'EnumMicrodeposits) = "microdeposits"

instance Data.Aeson.Types.FromJSON.FromJSON SubscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableUsBankAccount'NonNullableVerificationMethod' where
  parseJSON val =
    GHC.Base.pure
      ( if
            | val GHC.Classes.== "automatic" -> SubscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableUsBankAccount'NonNullableVerificationMethod'EnumAutomatic
            | val GHC.Classes.== "instant" -> SubscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableUsBankAccount'NonNullableVerificationMethod'EnumInstant
            | val GHC.Classes.== "microdeposits" -> SubscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableUsBankAccount'NonNullableVerificationMethod'EnumMicrodeposits
            | GHC.Base.otherwise -> SubscriptionPaymentSettings'NonNullablePaymentMethodOptions'NonNullableUsBankAccount'NonNullableVerificationMethod'Other val
      )

-- | Defines the enum schema located at @components.schemas.subscription.properties.payment_settings.anyOf.properties.payment_method_types.items@ in the specification.
data SubscriptionPaymentSettings'NonNullablePaymentMethodTypes'NonNullable
  = -- | This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
    SubscriptionPaymentSettings'NonNullablePaymentMethodTypes'NonNullableOther Data.Aeson.Types.Internal.Value
  | -- | This constructor can be used to send values to the server which are not present in the specification yet.
    SubscriptionPaymentSettings'NonNullablePaymentMethodTypes'NonNullableTyped Data.Text.Internal.Text
  | -- | Represents the JSON value @"ach_credit_transfer"@
    SubscriptionPaymentSettings'NonNullablePaymentMethodTypes'NonNullableEnumAchCreditTransfer
  | -- | Represents the JSON value @"ach_debit"@
    SubscriptionPaymentSettings'NonNullablePaymentMethodTypes'NonNullableEnumAchDebit
  | -- | Represents the JSON value @"acss_debit"@
    SubscriptionPaymentSettings'NonNullablePaymentMethodTypes'NonNullableEnumAcssDebit
  | -- | Represents the JSON value @"au_becs_debit"@
    SubscriptionPaymentSettings'NonNullablePaymentMethodTypes'NonNullableEnumAuBecsDebit
  | -- | Represents the JSON value @"bacs_debit"@
    SubscriptionPaymentSettings'NonNullablePaymentMethodTypes'NonNullableEnumBacsDebit
  | -- | Represents the JSON value @"bancontact"@
    SubscriptionPaymentSettings'NonNullablePaymentMethodTypes'NonNullableEnumBancontact
  | -- | Represents the JSON value @"boleto"@
    SubscriptionPaymentSettings'NonNullablePaymentMethodTypes'NonNullableEnumBoleto
  | -- | Represents the JSON value @"card"@
    SubscriptionPaymentSettings'NonNullablePaymentMethodTypes'NonNullableEnumCard
  | -- | Represents the JSON value @"cashapp"@
    SubscriptionPaymentSettings'NonNullablePaymentMethodTypes'NonNullableEnumCashapp
  | -- | Represents the JSON value @"customer_balance"@
    SubscriptionPaymentSettings'NonNullablePaymentMethodTypes'NonNullableEnumCustomerBalance
  | -- | Represents the JSON value @"fpx"@
    SubscriptionPaymentSettings'NonNullablePaymentMethodTypes'NonNullableEnumFpx
  | -- | Represents the JSON value @"giropay"@
    SubscriptionPaymentSettings'NonNullablePaymentMethodTypes'NonNullableEnumGiropay
  | -- | Represents the JSON value @"grabpay"@
    SubscriptionPaymentSettings'NonNullablePaymentMethodTypes'NonNullableEnumGrabpay
  | -- | Represents the JSON value @"ideal"@
    SubscriptionPaymentSettings'NonNullablePaymentMethodTypes'NonNullableEnumIdeal
  | -- | Represents the JSON value @"konbini"@
    SubscriptionPaymentSettings'NonNullablePaymentMethodTypes'NonNullableEnumKonbini
  | -- | Represents the JSON value @"link"@
    SubscriptionPaymentSettings'NonNullablePaymentMethodTypes'NonNullableEnumLink
  | -- | Represents the JSON value @"paynow"@
    SubscriptionPaymentSettings'NonNullablePaymentMethodTypes'NonNullableEnumPaynow
  | -- | Represents the JSON value @"paypal"@
    SubscriptionPaymentSettings'NonNullablePaymentMethodTypes'NonNullableEnumPaypal
  | -- | Represents the JSON value @"promptpay"@
    SubscriptionPaymentSettings'NonNullablePaymentMethodTypes'NonNullableEnumPromptpay
  | -- | Represents the JSON value @"sepa_debit"@
    SubscriptionPaymentSettings'NonNullablePaymentMethodTypes'NonNullableEnumSepaDebit
  | -- | Represents the JSON value @"sofort"@
    SubscriptionPaymentSettings'NonNullablePaymentMethodTypes'NonNullableEnumSofort
  | -- | Represents the JSON value @"us_bank_account"@
    SubscriptionPaymentSettings'NonNullablePaymentMethodTypes'NonNullableEnumUsBankAccount
  | -- | Represents the JSON value @"wechat_pay"@
    SubscriptionPaymentSettings'NonNullablePaymentMethodTypes'NonNullableEnumWechatPay
  deriving (GHC.Show.Show, GHC.Classes.Eq)

instance Data.Aeson.Types.ToJSON.ToJSON SubscriptionPaymentSettings'NonNullablePaymentMethodTypes'NonNullable where
  toJSON (SubscriptionPaymentSettings'NonNullablePaymentMethodTypes'NonNullableOther val) = val
  toJSON (SubscriptionPaymentSettings'NonNullablePaymentMethodTypes'NonNullableTyped val) = Data.Aeson.Types.ToJSON.toJSON val
  toJSON (SubscriptionPaymentSettings'NonNullablePaymentMethodTypes'NonNullableEnumAchCreditTransfer) = "ach_credit_transfer"
  toJSON (SubscriptionPaymentSettings'NonNullablePaymentMethodTypes'NonNullableEnumAchDebit) = "ach_debit"
  toJSON (SubscriptionPaymentSettings'NonNullablePaymentMethodTypes'NonNullableEnumAcssDebit) = "acss_debit"
  toJSON (SubscriptionPaymentSettings'NonNullablePaymentMethodTypes'NonNullableEnumAuBecsDebit) = "au_becs_debit"
  toJSON (SubscriptionPaymentSettings'NonNullablePaymentMethodTypes'NonNullableEnumBacsDebit) = "bacs_debit"
  toJSON (SubscriptionPaymentSettings'NonNullablePaymentMethodTypes'NonNullableEnumBancontact) = "bancontact"
  toJSON (SubscriptionPaymentSettings'NonNullablePaymentMethodTypes'NonNullableEnumBoleto) = "boleto"
  toJSON (SubscriptionPaymentSettings'NonNullablePaymentMethodTypes'NonNullableEnumCard) = "card"
  toJSON (SubscriptionPaymentSettings'NonNullablePaymentMethodTypes'NonNullableEnumCashapp) = "cashapp"
  toJSON (SubscriptionPaymentSettings'NonNullablePaymentMethodTypes'NonNullableEnumCustomerBalance) = "customer_balance"
  toJSON (SubscriptionPaymentSettings'NonNullablePaymentMethodTypes'NonNullableEnumFpx) = "fpx"
  toJSON (SubscriptionPaymentSettings'NonNullablePaymentMethodTypes'NonNullableEnumGiropay) = "giropay"
  toJSON (SubscriptionPaymentSettings'NonNullablePaymentMethodTypes'NonNullableEnumGrabpay) = "grabpay"
  toJSON (SubscriptionPaymentSettings'NonNullablePaymentMethodTypes'NonNullableEnumIdeal) = "ideal"
  toJSON (SubscriptionPaymentSettings'NonNullablePaymentMethodTypes'NonNullableEnumKonbini) = "konbini"
  toJSON (SubscriptionPaymentSettings'NonNullablePaymentMethodTypes'NonNullableEnumLink) = "link"
  toJSON (SubscriptionPaymentSettings'NonNullablePaymentMethodTypes'NonNullableEnumPaynow) = "paynow"
  toJSON (SubscriptionPaymentSettings'NonNullablePaymentMethodTypes'NonNullableEnumPaypal) = "paypal"
  toJSON (SubscriptionPaymentSettings'NonNullablePaymentMethodTypes'NonNullableEnumPromptpay) = "promptpay"
  toJSON (SubscriptionPaymentSettings'NonNullablePaymentMethodTypes'NonNullableEnumSepaDebit) = "sepa_debit"
  toJSON (SubscriptionPaymentSettings'NonNullablePaymentMethodTypes'NonNullableEnumSofort) = "sofort"
  toJSON (SubscriptionPaymentSettings'NonNullablePaymentMethodTypes'NonNullableEnumUsBankAccount) = "us_bank_account"
  toJSON (SubscriptionPaymentSettings'NonNullablePaymentMethodTypes'NonNullableEnumWechatPay) = "wechat_pay"

instance Data.Aeson.Types.FromJSON.FromJSON SubscriptionPaymentSettings'NonNullablePaymentMethodTypes'NonNullable where
  parseJSON val =
    GHC.Base.pure
      ( if
            | val GHC.Classes.== "ach_credit_transfer" -> SubscriptionPaymentSettings'NonNullablePaymentMethodTypes'NonNullableEnumAchCreditTransfer
            | val GHC.Classes.== "ach_debit" -> SubscriptionPaymentSettings'NonNullablePaymentMethodTypes'NonNullableEnumAchDebit
            | val GHC.Classes.== "acss_debit" -> SubscriptionPaymentSettings'NonNullablePaymentMethodTypes'NonNullableEnumAcssDebit
            | val GHC.Classes.== "au_becs_debit" -> SubscriptionPaymentSettings'NonNullablePaymentMethodTypes'NonNullableEnumAuBecsDebit
            | val GHC.Classes.== "bacs_debit" -> SubscriptionPaymentSettings'NonNullablePaymentMethodTypes'NonNullableEnumBacsDebit
            | val GHC.Classes.== "bancontact" -> SubscriptionPaymentSettings'NonNullablePaymentMethodTypes'NonNullableEnumBancontact
            | val GHC.Classes.== "boleto" -> SubscriptionPaymentSettings'NonNullablePaymentMethodTypes'NonNullableEnumBoleto
            | val GHC.Classes.== "card" -> SubscriptionPaymentSettings'NonNullablePaymentMethodTypes'NonNullableEnumCard
            | val GHC.Classes.== "cashapp" -> SubscriptionPaymentSettings'NonNullablePaymentMethodTypes'NonNullableEnumCashapp
            | val GHC.Classes.== "customer_balance" -> SubscriptionPaymentSettings'NonNullablePaymentMethodTypes'NonNullableEnumCustomerBalance
            | val GHC.Classes.== "fpx" -> SubscriptionPaymentSettings'NonNullablePaymentMethodTypes'NonNullableEnumFpx
            | val GHC.Classes.== "giropay" -> SubscriptionPaymentSettings'NonNullablePaymentMethodTypes'NonNullableEnumGiropay
            | val GHC.Classes.== "grabpay" -> SubscriptionPaymentSettings'NonNullablePaymentMethodTypes'NonNullableEnumGrabpay
            | val GHC.Classes.== "ideal" -> SubscriptionPaymentSettings'NonNullablePaymentMethodTypes'NonNullableEnumIdeal
            | val GHC.Classes.== "konbini" -> SubscriptionPaymentSettings'NonNullablePaymentMethodTypes'NonNullableEnumKonbini
            | val GHC.Classes.== "link" -> SubscriptionPaymentSettings'NonNullablePaymentMethodTypes'NonNullableEnumLink
            | val GHC.Classes.== "paynow" -> SubscriptionPaymentSettings'NonNullablePaymentMethodTypes'NonNullableEnumPaynow
            | val GHC.Classes.== "paypal" -> SubscriptionPaymentSettings'NonNullablePaymentMethodTypes'NonNullableEnumPaypal
            | val GHC.Classes.== "promptpay" -> SubscriptionPaymentSettings'NonNullablePaymentMethodTypes'NonNullableEnumPromptpay
            | val GHC.Classes.== "sepa_debit" -> SubscriptionPaymentSettings'NonNullablePaymentMethodTypes'NonNullableEnumSepaDebit
            | val GHC.Classes.== "sofort" -> SubscriptionPaymentSettings'NonNullablePaymentMethodTypes'NonNullableEnumSofort
            | val GHC.Classes.== "us_bank_account" -> SubscriptionPaymentSettings'NonNullablePaymentMethodTypes'NonNullableEnumUsBankAccount
            | val GHC.Classes.== "wechat_pay" -> SubscriptionPaymentSettings'NonNullablePaymentMethodTypes'NonNullableEnumWechatPay
            | GHC.Base.otherwise -> SubscriptionPaymentSettings'NonNullablePaymentMethodTypes'NonNullableOther val
      )

-- | Defines the enum schema located at @components.schemas.subscription.properties.payment_settings.anyOf.properties.save_default_payment_method@ in the specification.
--
-- Either \`off\`, or \`on_subscription\`. With \`on_subscription\` Stripe updates \`subscription.default_payment_method\` when a subscription payment succeeds.
data SubscriptionPaymentSettings'NonNullableSaveDefaultPaymentMethod'NonNullable
  = -- | This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
    SubscriptionPaymentSettings'NonNullableSaveDefaultPaymentMethod'NonNullableOther Data.Aeson.Types.Internal.Value
  | -- | This constructor can be used to send values to the server which are not present in the specification yet.
    SubscriptionPaymentSettings'NonNullableSaveDefaultPaymentMethod'NonNullableTyped Data.Text.Internal.Text
  | -- | Represents the JSON value @"off"@
    SubscriptionPaymentSettings'NonNullableSaveDefaultPaymentMethod'NonNullableEnumOff
  | -- | Represents the JSON value @"on_subscription"@
    SubscriptionPaymentSettings'NonNullableSaveDefaultPaymentMethod'NonNullableEnumOnSubscription
  deriving (GHC.Show.Show, GHC.Classes.Eq)

instance Data.Aeson.Types.ToJSON.ToJSON SubscriptionPaymentSettings'NonNullableSaveDefaultPaymentMethod'NonNullable where
  toJSON (SubscriptionPaymentSettings'NonNullableSaveDefaultPaymentMethod'NonNullableOther val) = val
  toJSON (SubscriptionPaymentSettings'NonNullableSaveDefaultPaymentMethod'NonNullableTyped val) = Data.Aeson.Types.ToJSON.toJSON val
  toJSON (SubscriptionPaymentSettings'NonNullableSaveDefaultPaymentMethod'NonNullableEnumOff) = "off"
  toJSON (SubscriptionPaymentSettings'NonNullableSaveDefaultPaymentMethod'NonNullableEnumOnSubscription) = "on_subscription"

instance Data.Aeson.Types.FromJSON.FromJSON SubscriptionPaymentSettings'NonNullableSaveDefaultPaymentMethod'NonNullable where
  parseJSON val =
    GHC.Base.pure
      ( if
            | val GHC.Classes.== "off" -> SubscriptionPaymentSettings'NonNullableSaveDefaultPaymentMethod'NonNullableEnumOff
            | val GHC.Classes.== "on_subscription" -> SubscriptionPaymentSettings'NonNullableSaveDefaultPaymentMethod'NonNullableEnumOnSubscription
            | GHC.Base.otherwise -> SubscriptionPaymentSettings'NonNullableSaveDefaultPaymentMethod'NonNullableOther val
      )

-- | Defines the object schema located at @components.schemas.subscription.properties.pending_invoice_item_interval.anyOf@ in the specification.
--
-- Specifies an interval for how often to bill for any pending invoice items. It is analogous to calling [Create an invoice](https:\\\/\\\/stripe.com\\\/docs\\\/api\\\#create_invoice) for the given subscription at the specified interval.
data SubscriptionPendingInvoiceItemInterval'NonNullable = SubscriptionPendingInvoiceItemInterval'NonNullable
  { -- | interval: Specifies invoicing frequency. Either \`day\`, \`week\`, \`month\` or \`year\`.
    subscriptionPendingInvoiceItemInterval'NonNullableInterval :: (GHC.Maybe.Maybe SubscriptionPendingInvoiceItemInterval'NonNullableInterval'),
    -- | interval_count: The number of intervals between invoices. For example, \`interval=month\` and \`interval_count=3\` bills every 3 months. Maximum of one year interval allowed (1 year, 12 months, or 52 weeks).
    subscriptionPendingInvoiceItemInterval'NonNullableIntervalCount :: (GHC.Maybe.Maybe GHC.Types.Int)
  }
  deriving
    ( GHC.Show.Show,
      GHC.Classes.Eq
    )

instance Data.Aeson.Types.ToJSON.ToJSON SubscriptionPendingInvoiceItemInterval'NonNullable where
  toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("interval" Data.Aeson.Types.ToJSON..=)) (subscriptionPendingInvoiceItemInterval'NonNullableInterval obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("interval_count" Data.Aeson.Types.ToJSON..=)) (subscriptionPendingInvoiceItemInterval'NonNullableIntervalCount obj) : GHC.Base.mempty))
  toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("interval" Data.Aeson.Types.ToJSON..=)) (subscriptionPendingInvoiceItemInterval'NonNullableInterval obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("interval_count" Data.Aeson.Types.ToJSON..=)) (subscriptionPendingInvoiceItemInterval'NonNullableIntervalCount obj) : GHC.Base.mempty)))

instance Data.Aeson.Types.FromJSON.FromJSON SubscriptionPendingInvoiceItemInterval'NonNullable where
  parseJSON = Data.Aeson.Types.FromJSON.withObject "SubscriptionPendingInvoiceItemInterval'NonNullable" (\obj -> (GHC.Base.pure SubscriptionPendingInvoiceItemInterval'NonNullable GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "interval")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "interval_count"))

-- | Create a new 'SubscriptionPendingInvoiceItemInterval'NonNullable' with all required fields.
mkSubscriptionPendingInvoiceItemInterval'NonNullable :: SubscriptionPendingInvoiceItemInterval'NonNullable
mkSubscriptionPendingInvoiceItemInterval'NonNullable =
  SubscriptionPendingInvoiceItemInterval'NonNullable
    { subscriptionPendingInvoiceItemInterval'NonNullableInterval = GHC.Maybe.Nothing,
      subscriptionPendingInvoiceItemInterval'NonNullableIntervalCount = GHC.Maybe.Nothing
    }

-- | Defines the enum schema located at @components.schemas.subscription.properties.pending_invoice_item_interval.anyOf.properties.interval@ in the specification.
--
-- Specifies invoicing frequency. Either \`day\`, \`week\`, \`month\` or \`year\`.
data SubscriptionPendingInvoiceItemInterval'NonNullableInterval'
  = -- | This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
    SubscriptionPendingInvoiceItemInterval'NonNullableInterval'Other Data.Aeson.Types.Internal.Value
  | -- | This constructor can be used to send values to the server which are not present in the specification yet.
    SubscriptionPendingInvoiceItemInterval'NonNullableInterval'Typed Data.Text.Internal.Text
  | -- | Represents the JSON value @"day"@
    SubscriptionPendingInvoiceItemInterval'NonNullableInterval'EnumDay
  | -- | Represents the JSON value @"month"@
    SubscriptionPendingInvoiceItemInterval'NonNullableInterval'EnumMonth
  | -- | Represents the JSON value @"week"@
    SubscriptionPendingInvoiceItemInterval'NonNullableInterval'EnumWeek
  | -- | Represents the JSON value @"year"@
    SubscriptionPendingInvoiceItemInterval'NonNullableInterval'EnumYear
  deriving (GHC.Show.Show, GHC.Classes.Eq)

instance Data.Aeson.Types.ToJSON.ToJSON SubscriptionPendingInvoiceItemInterval'NonNullableInterval' where
  toJSON (SubscriptionPendingInvoiceItemInterval'NonNullableInterval'Other val) = val
  toJSON (SubscriptionPendingInvoiceItemInterval'NonNullableInterval'Typed val) = Data.Aeson.Types.ToJSON.toJSON val
  toJSON (SubscriptionPendingInvoiceItemInterval'NonNullableInterval'EnumDay) = "day"
  toJSON (SubscriptionPendingInvoiceItemInterval'NonNullableInterval'EnumMonth) = "month"
  toJSON (SubscriptionPendingInvoiceItemInterval'NonNullableInterval'EnumWeek) = "week"
  toJSON (SubscriptionPendingInvoiceItemInterval'NonNullableInterval'EnumYear) = "year"

instance Data.Aeson.Types.FromJSON.FromJSON SubscriptionPendingInvoiceItemInterval'NonNullableInterval' where
  parseJSON val =
    GHC.Base.pure
      ( if
            | val GHC.Classes.== "day" -> SubscriptionPendingInvoiceItemInterval'NonNullableInterval'EnumDay
            | val GHC.Classes.== "month" -> SubscriptionPendingInvoiceItemInterval'NonNullableInterval'EnumMonth
            | val GHC.Classes.== "week" -> SubscriptionPendingInvoiceItemInterval'NonNullableInterval'EnumWeek
            | val GHC.Classes.== "year" -> SubscriptionPendingInvoiceItemInterval'NonNullableInterval'EnumYear
            | GHC.Base.otherwise -> SubscriptionPendingInvoiceItemInterval'NonNullableInterval'Other val
      )

-- | Defines the oneOf schema located at @components.schemas.subscription.properties.pending_setup_intent.anyOf@ in the specification.
--
-- You can use this [SetupIntent](https:\/\/stripe.com\/docs\/api\/setup_intents) to collect user authentication when creating a subscription without immediate payment or updating a subscription\'s payment method, allowing you to optimize for off-session payments. Learn more in the [SCA Migration Guide](https:\/\/stripe.com\/docs\/billing\/migration\/strong-customer-authentication\#scenario-2).
data SubscriptionPendingSetupIntent'NonNullableVariants
  = SubscriptionPendingSetupIntent'NonNullableText Data.Text.Internal.Text
  | SubscriptionPendingSetupIntent'NonNullableSetupIntent SetupIntent
  deriving (GHC.Show.Show, GHC.Classes.Eq)

instance Data.Aeson.Types.ToJSON.ToJSON SubscriptionPendingSetupIntent'NonNullableVariants where
  toJSON (SubscriptionPendingSetupIntent'NonNullableText a) = Data.Aeson.Types.ToJSON.toJSON a
  toJSON (SubscriptionPendingSetupIntent'NonNullableSetupIntent a) = Data.Aeson.Types.ToJSON.toJSON a

instance Data.Aeson.Types.FromJSON.FromJSON SubscriptionPendingSetupIntent'NonNullableVariants where
  parseJSON val = case (SubscriptionPendingSetupIntent'NonNullableText Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((SubscriptionPendingSetupIntent'NonNullableSetupIntent Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> Data.Aeson.Types.Internal.Error "No variant matched") of
    Data.Aeson.Types.Internal.Success a -> GHC.Base.pure a
    Data.Aeson.Types.Internal.Error a -> Control.Monad.Fail.fail a

-- | Defines the object schema located at @components.schemas.subscription.properties.pending_update.anyOf@ in the specification.
--
-- If specified, [pending updates](https:\\\/\\\/stripe.com\\\/docs\\\/billing\\\/subscriptions\\\/pending-updates) that will be applied to the subscription once the \\\`latest_invoice\\\` has been paid.
data SubscriptionPendingUpdate'NonNullable = SubscriptionPendingUpdate'NonNullable
  { -- | billing_cycle_anchor: If the update is applied, determines the date of the first full invoice, and, for plans with \`month\` or \`year\` intervals, the day of the month for subsequent invoices. The timestamp is in UTC format.
    subscriptionPendingUpdate'NonNullableBillingCycleAnchor :: (GHC.Maybe.Maybe (StripeAPI.Common.Nullable GHC.Types.Int)),
    -- | expires_at: The point after which the changes reflected by this update will be discarded and no longer applied.
    subscriptionPendingUpdate'NonNullableExpiresAt :: (GHC.Maybe.Maybe GHC.Types.Int),
    -- | subscription_items: List of subscription items, each with an attached plan, that will be set if the update is applied.
    subscriptionPendingUpdate'NonNullableSubscriptionItems :: (GHC.Maybe.Maybe (StripeAPI.Common.Nullable ([SubscriptionItem]))),
    -- | trial_end: Unix timestamp representing the end of the trial period the customer will get before being charged for the first time, if the update is applied.
    subscriptionPendingUpdate'NonNullableTrialEnd :: (GHC.Maybe.Maybe (StripeAPI.Common.Nullable GHC.Types.Int)),
    -- | trial_from_plan: Indicates if a plan\'s \`trial_period_days\` should be applied to the subscription. Setting \`trial_end\` per subscription is preferred, and this defaults to \`false\`. Setting this flag to \`true\` together with \`trial_end\` is not allowed. See [Using trial periods on subscriptions](https:\/\/stripe.com\/docs\/billing\/subscriptions\/trials) to learn more.
    subscriptionPendingUpdate'NonNullableTrialFromPlan :: (GHC.Maybe.Maybe (StripeAPI.Common.Nullable GHC.Types.Bool))
  }
  deriving
    ( GHC.Show.Show,
      GHC.Classes.Eq
    )

instance Data.Aeson.Types.ToJSON.ToJSON SubscriptionPendingUpdate'NonNullable where
  toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("billing_cycle_anchor" Data.Aeson.Types.ToJSON..=)) (subscriptionPendingUpdate'NonNullableBillingCycleAnchor obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("expires_at" Data.Aeson.Types.ToJSON..=)) (subscriptionPendingUpdate'NonNullableExpiresAt obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("subscription_items" Data.Aeson.Types.ToJSON..=)) (subscriptionPendingUpdate'NonNullableSubscriptionItems obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("trial_end" Data.Aeson.Types.ToJSON..=)) (subscriptionPendingUpdate'NonNullableTrialEnd obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("trial_from_plan" Data.Aeson.Types.ToJSON..=)) (subscriptionPendingUpdate'NonNullableTrialFromPlan obj) : GHC.Base.mempty))
  toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("billing_cycle_anchor" Data.Aeson.Types.ToJSON..=)) (subscriptionPendingUpdate'NonNullableBillingCycleAnchor obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("expires_at" Data.Aeson.Types.ToJSON..=)) (subscriptionPendingUpdate'NonNullableExpiresAt obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("subscription_items" Data.Aeson.Types.ToJSON..=)) (subscriptionPendingUpdate'NonNullableSubscriptionItems obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("trial_end" Data.Aeson.Types.ToJSON..=)) (subscriptionPendingUpdate'NonNullableTrialEnd obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("trial_from_plan" Data.Aeson.Types.ToJSON..=)) (subscriptionPendingUpdate'NonNullableTrialFromPlan obj) : GHC.Base.mempty)))

instance Data.Aeson.Types.FromJSON.FromJSON SubscriptionPendingUpdate'NonNullable where
  parseJSON = Data.Aeson.Types.FromJSON.withObject "SubscriptionPendingUpdate'NonNullable" (\obj -> ((((GHC.Base.pure SubscriptionPendingUpdate'NonNullable GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "billing_cycle_anchor")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "expires_at")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "subscription_items")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "trial_end")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "trial_from_plan"))

-- | Create a new 'SubscriptionPendingUpdate'NonNullable' with all required fields.
mkSubscriptionPendingUpdate'NonNullable :: SubscriptionPendingUpdate'NonNullable
mkSubscriptionPendingUpdate'NonNullable =
  SubscriptionPendingUpdate'NonNullable
    { subscriptionPendingUpdate'NonNullableBillingCycleAnchor = GHC.Maybe.Nothing,
      subscriptionPendingUpdate'NonNullableExpiresAt = GHC.Maybe.Nothing,
      subscriptionPendingUpdate'NonNullableSubscriptionItems = GHC.Maybe.Nothing,
      subscriptionPendingUpdate'NonNullableTrialEnd = GHC.Maybe.Nothing,
      subscriptionPendingUpdate'NonNullableTrialFromPlan = GHC.Maybe.Nothing
    }

-- | Defines the oneOf schema located at @components.schemas.subscription.properties.schedule.anyOf@ in the specification.
--
-- The schedule attached to the subscription
data SubscriptionSchedule'NonNullableVariants
  = SubscriptionSchedule'NonNullableText Data.Text.Internal.Text
  | SubscriptionSchedule'NonNullableSubscriptionSchedule SubscriptionSchedule
  deriving (GHC.Show.Show, GHC.Classes.Eq)

instance Data.Aeson.Types.ToJSON.ToJSON SubscriptionSchedule'NonNullableVariants where
  toJSON (SubscriptionSchedule'NonNullableText a) = Data.Aeson.Types.ToJSON.toJSON a
  toJSON (SubscriptionSchedule'NonNullableSubscriptionSchedule a) = Data.Aeson.Types.ToJSON.toJSON a

instance Data.Aeson.Types.FromJSON.FromJSON SubscriptionSchedule'NonNullableVariants where
  parseJSON val = case (SubscriptionSchedule'NonNullableText Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((SubscriptionSchedule'NonNullableSubscriptionSchedule Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> Data.Aeson.Types.Internal.Error "No variant matched") of
    Data.Aeson.Types.Internal.Success a -> GHC.Base.pure a
    Data.Aeson.Types.Internal.Error a -> Control.Monad.Fail.fail a

-- | Defines the enum schema located at @components.schemas.subscription.properties.status@ in the specification.
--
-- Possible values are \`incomplete\`, \`incomplete_expired\`, \`trialing\`, \`active\`, \`past_due\`, \`canceled\`, or \`unpaid\`.
--
-- For \`collection_method=charge_automatically\` a subscription moves into \`incomplete\` if the initial payment attempt fails. A subscription in this state can only have metadata and default_source updated. Once the first invoice is paid, the subscription moves into an \`active\` state. If the first invoice is not paid within 23 hours, the subscription transitions to \`incomplete_expired\`. This is a terminal state, the open invoice will be voided and no further invoices will be generated.
--
-- A subscription that is currently in a trial period is \`trialing\` and moves to \`active\` when the trial period is over.
--
-- If subscription \`collection_method=charge_automatically\`, it becomes \`past_due\` when payment is required but cannot be paid (due to failed payment or awaiting additional user actions). Once Stripe has exhausted all payment retry attempts, the subscription will become \`canceled\` or \`unpaid\` (depending on your subscriptions settings).
--
-- If subscription \`collection_method=send_invoice\` it becomes \`past_due\` when its invoice is not paid by the due date, and \`canceled\` or \`unpaid\` if it is still not paid by an additional deadline after that. Note that when a subscription has a status of \`unpaid\`, no subsequent invoices will be attempted (invoices will be created, but then immediately automatically closed). After receiving updated payment information from a customer, you may choose to reopen and pay their closed invoices.
data SubscriptionStatus'
  = -- | This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
    SubscriptionStatus'Other Data.Aeson.Types.Internal.Value
  | -- | This constructor can be used to send values to the server which are not present in the specification yet.
    SubscriptionStatus'Typed Data.Text.Internal.Text
  | -- | Represents the JSON value @"active"@
    SubscriptionStatus'EnumActive
  | -- | Represents the JSON value @"canceled"@
    SubscriptionStatus'EnumCanceled
  | -- | Represents the JSON value @"incomplete"@
    SubscriptionStatus'EnumIncomplete
  | -- | Represents the JSON value @"incomplete_expired"@
    SubscriptionStatus'EnumIncompleteExpired
  | -- | Represents the JSON value @"past_due"@
    SubscriptionStatus'EnumPastDue
  | -- | Represents the JSON value @"paused"@
    SubscriptionStatus'EnumPaused
  | -- | Represents the JSON value @"trialing"@
    SubscriptionStatus'EnumTrialing
  | -- | Represents the JSON value @"unpaid"@
    SubscriptionStatus'EnumUnpaid
  deriving (GHC.Show.Show, GHC.Classes.Eq)

instance Data.Aeson.Types.ToJSON.ToJSON SubscriptionStatus' where
  toJSON (SubscriptionStatus'Other val) = val
  toJSON (SubscriptionStatus'Typed val) = Data.Aeson.Types.ToJSON.toJSON val
  toJSON (SubscriptionStatus'EnumActive) = "active"
  toJSON (SubscriptionStatus'EnumCanceled) = "canceled"
  toJSON (SubscriptionStatus'EnumIncomplete) = "incomplete"
  toJSON (SubscriptionStatus'EnumIncompleteExpired) = "incomplete_expired"
  toJSON (SubscriptionStatus'EnumPastDue) = "past_due"
  toJSON (SubscriptionStatus'EnumPaused) = "paused"
  toJSON (SubscriptionStatus'EnumTrialing) = "trialing"
  toJSON (SubscriptionStatus'EnumUnpaid) = "unpaid"

instance Data.Aeson.Types.FromJSON.FromJSON SubscriptionStatus' where
  parseJSON val =
    GHC.Base.pure
      ( if
            | val GHC.Classes.== "active" -> SubscriptionStatus'EnumActive
            | val GHC.Classes.== "canceled" -> SubscriptionStatus'EnumCanceled
            | val GHC.Classes.== "incomplete" -> SubscriptionStatus'EnumIncomplete
            | val GHC.Classes.== "incomplete_expired" -> SubscriptionStatus'EnumIncompleteExpired
            | val GHC.Classes.== "past_due" -> SubscriptionStatus'EnumPastDue
            | val GHC.Classes.== "paused" -> SubscriptionStatus'EnumPaused
            | val GHC.Classes.== "trialing" -> SubscriptionStatus'EnumTrialing
            | val GHC.Classes.== "unpaid" -> SubscriptionStatus'EnumUnpaid
            | GHC.Base.otherwise -> SubscriptionStatus'Other val
      )

-- | Defines the oneOf schema located at @components.schemas.subscription.properties.test_clock.anyOf@ in the specification.
--
-- ID of the test clock this subscription belongs to.
data SubscriptionTestClock'NonNullableVariants
  = SubscriptionTestClock'NonNullableText Data.Text.Internal.Text
  | SubscriptionTestClock'NonNullableTestHelpers'testClock TestHelpers'testClock
  deriving (GHC.Show.Show, GHC.Classes.Eq)

instance Data.Aeson.Types.ToJSON.ToJSON SubscriptionTestClock'NonNullableVariants where
  toJSON (SubscriptionTestClock'NonNullableText a) = Data.Aeson.Types.ToJSON.toJSON a
  toJSON (SubscriptionTestClock'NonNullableTestHelpers'testClock a) = Data.Aeson.Types.ToJSON.toJSON a

instance Data.Aeson.Types.FromJSON.FromJSON SubscriptionTestClock'NonNullableVariants where
  parseJSON val = case (SubscriptionTestClock'NonNullableText Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((SubscriptionTestClock'NonNullableTestHelpers'testClock Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> Data.Aeson.Types.Internal.Error "No variant matched") of
    Data.Aeson.Types.Internal.Success a -> GHC.Base.pure a
    Data.Aeson.Types.Internal.Error a -> Control.Monad.Fail.fail a

-- | Defines the object schema located at @components.schemas.subscription.properties.transfer_data.anyOf@ in the specification.
--
-- The account (if any) the subscription\\\'s payments will be attributed to for tax reporting, and where funds from each payment will be transferred to for each of the subscription\\\'s invoices.
data SubscriptionTransferData'NonNullable = SubscriptionTransferData'NonNullable
  { -- | amount_percent: A non-negative decimal between 0 and 100, with at most two decimal places. This represents the percentage of the subscription invoice total that will be transferred to the destination account. By default, the entire amount is transferred to the destination.
    subscriptionTransferData'NonNullableAmountPercent :: (GHC.Maybe.Maybe (StripeAPI.Common.Nullable GHC.Types.Double)),
    -- | destination: The account where funds from the payment will be transferred to upon payment success.
    subscriptionTransferData'NonNullableDestination :: (GHC.Maybe.Maybe SubscriptionTransferData'NonNullableDestination'Variants)
  }
  deriving
    ( GHC.Show.Show,
      GHC.Classes.Eq
    )

instance Data.Aeson.Types.ToJSON.ToJSON SubscriptionTransferData'NonNullable where
  toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("amount_percent" Data.Aeson.Types.ToJSON..=)) (subscriptionTransferData'NonNullableAmountPercent obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("destination" Data.Aeson.Types.ToJSON..=)) (subscriptionTransferData'NonNullableDestination obj) : GHC.Base.mempty))
  toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("amount_percent" Data.Aeson.Types.ToJSON..=)) (subscriptionTransferData'NonNullableAmountPercent obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("destination" Data.Aeson.Types.ToJSON..=)) (subscriptionTransferData'NonNullableDestination obj) : GHC.Base.mempty)))

instance Data.Aeson.Types.FromJSON.FromJSON SubscriptionTransferData'NonNullable where
  parseJSON = Data.Aeson.Types.FromJSON.withObject "SubscriptionTransferData'NonNullable" (\obj -> (GHC.Base.pure SubscriptionTransferData'NonNullable GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "amount_percent")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "destination"))

-- | Create a new 'SubscriptionTransferData'NonNullable' with all required fields.
mkSubscriptionTransferData'NonNullable :: SubscriptionTransferData'NonNullable
mkSubscriptionTransferData'NonNullable =
  SubscriptionTransferData'NonNullable
    { subscriptionTransferData'NonNullableAmountPercent = GHC.Maybe.Nothing,
      subscriptionTransferData'NonNullableDestination = GHC.Maybe.Nothing
    }

-- | Defines the oneOf schema located at @components.schemas.subscription.properties.transfer_data.anyOf.properties.destination.anyOf@ in the specification.
--
-- The account where funds from the payment will be transferred to upon payment success.
data SubscriptionTransferData'NonNullableDestination'Variants
  = SubscriptionTransferData'NonNullableDestination'Text Data.Text.Internal.Text
  | SubscriptionTransferData'NonNullableDestination'Account Account
  deriving (GHC.Show.Show, GHC.Classes.Eq)

instance Data.Aeson.Types.ToJSON.ToJSON SubscriptionTransferData'NonNullableDestination'Variants where
  toJSON (SubscriptionTransferData'NonNullableDestination'Text a) = Data.Aeson.Types.ToJSON.toJSON a
  toJSON (SubscriptionTransferData'NonNullableDestination'Account a) = Data.Aeson.Types.ToJSON.toJSON a

instance Data.Aeson.Types.FromJSON.FromJSON SubscriptionTransferData'NonNullableDestination'Variants where
  parseJSON val = case (SubscriptionTransferData'NonNullableDestination'Text Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((SubscriptionTransferData'NonNullableDestination'Account Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> Data.Aeson.Types.Internal.Error "No variant matched") of
    Data.Aeson.Types.Internal.Success a -> GHC.Base.pure a
    Data.Aeson.Types.Internal.Error a -> Control.Monad.Fail.fail a

-- | Defines the object schema located at @components.schemas.subscription.properties.trial_settings.anyOf@ in the specification.
--
-- Settings related to subscription trials.
data SubscriptionTrialSettings'NonNullable = SubscriptionTrialSettings'NonNullable
  { -- | end_behavior: Defines how a subscription behaves when a free trial ends.
    subscriptionTrialSettings'NonNullableEndBehavior :: (GHC.Maybe.Maybe SubscriptionsTrialsResourceEndBehavior)
  }
  deriving
    ( GHC.Show.Show,
      GHC.Classes.Eq
    )

instance Data.Aeson.Types.ToJSON.ToJSON SubscriptionTrialSettings'NonNullable where
  toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("end_behavior" Data.Aeson.Types.ToJSON..=)) (subscriptionTrialSettings'NonNullableEndBehavior obj) : GHC.Base.mempty))
  toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("end_behavior" Data.Aeson.Types.ToJSON..=)) (subscriptionTrialSettings'NonNullableEndBehavior obj) : GHC.Base.mempty)))

instance Data.Aeson.Types.FromJSON.FromJSON SubscriptionTrialSettings'NonNullable where
  parseJSON = Data.Aeson.Types.FromJSON.withObject "SubscriptionTrialSettings'NonNullable" (\obj -> GHC.Base.pure SubscriptionTrialSettings'NonNullable GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "end_behavior"))

-- | Create a new 'SubscriptionTrialSettings'NonNullable' with all required fields.
mkSubscriptionTrialSettings'NonNullable :: SubscriptionTrialSettings'NonNullable
mkSubscriptionTrialSettings'NonNullable = SubscriptionTrialSettings'NonNullable {subscriptionTrialSettings'NonNullableEndBehavior = GHC.Maybe.Nothing}
