{-# LANGUAGE MultiWayIf #-}
-- CHANGE WITH CAUTION: This is a generated code file generated by https://github.com/Haskell-OpenAPI-Code-Generator/Haskell-OpenAPI-Client-Code-Generator.
{-# LANGUAGE OverloadedStrings #-}

-- | Contains the types generated from the schema Subscription
module StripeAPI.Types.Subscription where

import qualified Control.Monad.Fail
import qualified Data.Aeson
import qualified Data.Aeson as Data.Aeson.Encoding.Internal
import qualified Data.Aeson as Data.Aeson.Types
import qualified Data.Aeson as Data.Aeson.Types.FromJSON
import qualified Data.Aeson as Data.Aeson.Types.Internal
import qualified Data.Aeson as Data.Aeson.Types.ToJSON
import qualified Data.ByteString.Char8
import qualified Data.ByteString.Char8 as Data.ByteString.Internal
import qualified Data.Functor
import qualified Data.Scientific
import qualified Data.Text
import qualified Data.Text.Internal
import qualified Data.Time.Calendar as Data.Time.Calendar.Days
import qualified Data.Time.LocalTime as Data.Time.LocalTime.Internal.ZonedTime
import qualified GHC.Base
import qualified GHC.Classes
import qualified GHC.Int
import qualified GHC.Show
import qualified GHC.Types
import qualified StripeAPI.Common
import StripeAPI.TypeAlias
import {-# SOURCE #-} StripeAPI.Types.Account
import {-# SOURCE #-} StripeAPI.Types.AlipayAccount
import {-# SOURCE #-} StripeAPI.Types.BankAccount
import {-# SOURCE #-} StripeAPI.Types.BitcoinReceiver
import {-# SOURCE #-} StripeAPI.Types.Card
import {-# SOURCE #-} StripeAPI.Types.Coupon
import {-# SOURCE #-} StripeAPI.Types.Customer
import {-# SOURCE #-} StripeAPI.Types.DeletedCustomer
import {-# SOURCE #-} StripeAPI.Types.Discount
import {-# SOURCE #-} StripeAPI.Types.Invoice
import {-# SOURCE #-} StripeAPI.Types.PaymentMethod
import {-# SOURCE #-} StripeAPI.Types.PromotionCode
import {-# SOURCE #-} StripeAPI.Types.SetupIntent
import {-# SOURCE #-} StripeAPI.Types.Source
import {-# SOURCE #-} StripeAPI.Types.SubscriptionAutomaticTax
import {-# SOURCE #-} StripeAPI.Types.SubscriptionBillingThresholds
import {-# SOURCE #-} StripeAPI.Types.SubscriptionItem
import {-# SOURCE #-} StripeAPI.Types.SubscriptionPendingInvoiceItemInterval
import {-# SOURCE #-} StripeAPI.Types.SubscriptionSchedule
import {-# SOURCE #-} StripeAPI.Types.SubscriptionTransferData
import {-# SOURCE #-} StripeAPI.Types.SubscriptionsResourcePauseCollection
import {-# SOURCE #-} StripeAPI.Types.SubscriptionsResourcePendingUpdate
import {-# SOURCE #-} StripeAPI.Types.TaxRate
import qualified Prelude as GHC.Integer.Type
import qualified Prelude as GHC.Maybe

-- | Defines the object schema located at @components.schemas.subscription@ in the specification.
--
-- Subscriptions allow you to charge a customer on a recurring basis.
--
-- Related guide: [Creating Subscriptions](https:\/\/stripe.com\/docs\/billing\/subscriptions\/creating).
data Subscription = Subscription
  { -- | application_fee_percent: A non-negative decimal between 0 and 100, with at most two decimal places. This represents the percentage of the subscription invoice subtotal that will be transferred to the application owner\'s Stripe account.
    subscriptionApplicationFeePercent :: (GHC.Maybe.Maybe GHC.Types.Double),
    -- | automatic_tax:
    subscriptionAutomaticTax :: SubscriptionAutomaticTax,
    -- | billing_cycle_anchor: Determines the date of the first full invoice, and, for plans with \`month\` or \`year\` intervals, the day of the month for subsequent invoices.
    subscriptionBillingCycleAnchor :: GHC.Types.Int,
    -- | billing_thresholds: Define thresholds at which an invoice will be sent, and the subscription advanced to a new billing period
    subscriptionBillingThresholds :: (GHC.Maybe.Maybe SubscriptionBillingThresholds'),
    -- | cancel_at: A date in the future at which the subscription will automatically get canceled
    subscriptionCancelAt :: (GHC.Maybe.Maybe GHC.Types.Int),
    -- | cancel_at_period_end: If the subscription has been canceled with the \`at_period_end\` flag set to \`true\`, \`cancel_at_period_end\` on the subscription will be true. You can use this attribute to determine whether a subscription that has a status of active is scheduled to be canceled at the end of the current period.
    subscriptionCancelAtPeriodEnd :: GHC.Types.Bool,
    -- | canceled_at: If the subscription has been canceled, the date of that cancellation. If the subscription was canceled with \`cancel_at_period_end\`, \`canceled_at\` will reflect the time of the most recent update request, not the end of the subscription period when the subscription is automatically moved to a canceled state.
    subscriptionCanceledAt :: (GHC.Maybe.Maybe GHC.Types.Int),
    -- | collection_method: Either \`charge_automatically\`, or \`send_invoice\`. When charging automatically, Stripe will attempt to pay this subscription at the end of the cycle using the default source attached to the customer. When sending an invoice, Stripe will email your customer an invoice with payment instructions.
    subscriptionCollectionMethod :: (GHC.Maybe.Maybe SubscriptionCollectionMethod'),
    -- | created: Time at which the object was created. Measured in seconds since the Unix epoch.
    subscriptionCreated :: GHC.Types.Int,
    -- | current_period_end: End of the current period that the subscription has been invoiced for. At the end of this period, a new invoice will be created.
    subscriptionCurrentPeriodEnd :: GHC.Types.Int,
    -- | current_period_start: Start of the current period that the subscription has been invoiced for.
    subscriptionCurrentPeriodStart :: GHC.Types.Int,
    -- | customer: ID of the customer who owns the subscription.
    subscriptionCustomer :: SubscriptionCustomer'Variants,
    -- | days_until_due: Number of days a customer has to pay invoices generated by this subscription. This value will be \`null\` for subscriptions where \`collection_method=charge_automatically\`.
    subscriptionDaysUntilDue :: (GHC.Maybe.Maybe GHC.Types.Int),
    -- | default_payment_method: ID of the default payment method for the subscription. It must belong to the customer associated with the subscription. This takes precedence over \`default_source\`. If neither are set, invoices will use the customer\'s [invoice_settings.default_payment_method](https:\/\/stripe.com\/docs\/api\/customers\/object\#customer_object-invoice_settings-default_payment_method) or [default_source](https:\/\/stripe.com\/docs\/api\/customers\/object\#customer_object-default_source).
    subscriptionDefaultPaymentMethod :: (GHC.Maybe.Maybe SubscriptionDefaultPaymentMethod'Variants),
    -- | default_source: ID of the default payment source for the subscription. It must belong to the customer associated with the subscription and be in a chargeable state. If \`default_payment_method\` is also set, \`default_payment_method\` will take precedence. If neither are set, invoices will use the customer\'s [invoice_settings.default_payment_method](https:\/\/stripe.com\/docs\/api\/customers\/object\#customer_object-invoice_settings-default_payment_method) or [default_source](https:\/\/stripe.com\/docs\/api\/customers\/object\#customer_object-default_source).
    subscriptionDefaultSource :: (GHC.Maybe.Maybe SubscriptionDefaultSource'Variants),
    -- | default_tax_rates: The tax rates that will apply to any subscription item that does not have \`tax_rates\` set. Invoices created will have their \`default_tax_rates\` populated from the subscription.
    subscriptionDefaultTaxRates :: (GHC.Maybe.Maybe ([TaxRate])),
    -- | discount: Describes the current discount applied to this subscription, if there is one. When billing, a discount applied to a subscription overrides a discount applied on a customer-wide basis.
    subscriptionDiscount :: (GHC.Maybe.Maybe SubscriptionDiscount'),
    -- | ended_at: If the subscription has ended, the date the subscription ended.
    subscriptionEndedAt :: (GHC.Maybe.Maybe GHC.Types.Int),
    -- | id: Unique identifier for the object.
    --
    -- Constraints:
    --
    -- * Maximum length of 5000
    subscriptionId :: Data.Text.Internal.Text,
    -- | items: List of subscription items, each with an attached price.
    subscriptionItems :: SubscriptionItems',
    -- | latest_invoice: The most recent invoice this subscription has generated.
    subscriptionLatestInvoice :: (GHC.Maybe.Maybe SubscriptionLatestInvoice'Variants),
    -- | livemode: Has the value \`true\` if the object exists in live mode or the value \`false\` if the object exists in test mode.
    subscriptionLivemode :: GHC.Types.Bool,
    -- | metadata: Set of [key-value pairs](https:\/\/stripe.com\/docs\/api\/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format.
    subscriptionMetadata :: Data.Aeson.Types.Internal.Object,
    -- | next_pending_invoice_item_invoice: Specifies the approximate timestamp on which any pending invoice items will be billed according to the schedule provided at \`pending_invoice_item_interval\`.
    subscriptionNextPendingInvoiceItemInvoice :: (GHC.Maybe.Maybe GHC.Types.Int),
    -- | pause_collection: If specified, payment collection for this subscription will be paused.
    subscriptionPauseCollection :: (GHC.Maybe.Maybe SubscriptionPauseCollection'),
    -- | pending_invoice_item_interval: Specifies an interval for how often to bill for any pending invoice items. It is analogous to calling [Create an invoice](https:\/\/stripe.com\/docs\/api\#create_invoice) for the given subscription at the specified interval.
    subscriptionPendingInvoiceItemInterval :: (GHC.Maybe.Maybe SubscriptionPendingInvoiceItemInterval'),
    -- | pending_setup_intent: You can use this [SetupIntent](https:\/\/stripe.com\/docs\/api\/setup_intents) to collect user authentication when creating a subscription without immediate payment or updating a subscription\'s payment method, allowing you to optimize for off-session payments. Learn more in the [SCA Migration Guide](https:\/\/stripe.com\/docs\/billing\/migration\/strong-customer-authentication\#scenario-2).
    subscriptionPendingSetupIntent :: (GHC.Maybe.Maybe SubscriptionPendingSetupIntent'Variants),
    -- | pending_update: If specified, [pending updates](https:\/\/stripe.com\/docs\/billing\/subscriptions\/pending-updates) that will be applied to the subscription once the \`latest_invoice\` has been paid.
    subscriptionPendingUpdate :: (GHC.Maybe.Maybe SubscriptionPendingUpdate'),
    -- | schedule: The schedule attached to the subscription
    subscriptionSchedule :: (GHC.Maybe.Maybe SubscriptionSchedule'Variants),
    -- | start_date: Date when the subscription was first created. The date might differ from the \`created\` date due to backdating.
    subscriptionStartDate :: GHC.Types.Int,
    -- | status: Possible values are \`incomplete\`, \`incomplete_expired\`, \`trialing\`, \`active\`, \`past_due\`, \`canceled\`, or \`unpaid\`.
    --
    -- For \`collection_method=charge_automatically\` a subscription moves into \`incomplete\` if the initial payment attempt fails. A subscription in this state can only have metadata and default_source updated. Once the first invoice is paid, the subscription moves into an \`active\` state. If the first invoice is not paid within 23 hours, the subscription transitions to \`incomplete_expired\`. This is a terminal state, the open invoice will be voided and no further invoices will be generated.
    --
    -- A subscription that is currently in a trial period is \`trialing\` and moves to \`active\` when the trial period is over.
    --
    -- If subscription \`collection_method=charge_automatically\` it becomes \`past_due\` when payment to renew it fails and \`canceled\` or \`unpaid\` (depending on your subscriptions settings) when Stripe has exhausted all payment retry attempts.
    --
    -- If subscription \`collection_method=send_invoice\` it becomes \`past_due\` when its invoice is not paid by the due date, and \`canceled\` or \`unpaid\` if it is still not paid by an additional deadline after that. Note that when a subscription has a status of \`unpaid\`, no subsequent invoices will be attempted (invoices will be created, but then immediately automatically closed). After receiving updated payment information from a customer, you may choose to reopen and pay their closed invoices.
    subscriptionStatus :: SubscriptionStatus',
    -- | transfer_data: The account (if any) the subscription\'s payments will be attributed to for tax reporting, and where funds from each payment will be transferred to for each of the subscription\'s invoices.
    subscriptionTransferData :: (GHC.Maybe.Maybe SubscriptionTransferData'),
    -- | trial_end: If the subscription has a trial, the end of that trial.
    subscriptionTrialEnd :: (GHC.Maybe.Maybe GHC.Types.Int),
    -- | trial_start: If the subscription has a trial, the beginning of that trial.
    subscriptionTrialStart :: (GHC.Maybe.Maybe GHC.Types.Int)
  }
  deriving
    ( GHC.Show.Show,
      GHC.Classes.Eq
    )

instance Data.Aeson.Types.ToJSON.ToJSON Subscription where
  toJSON obj = Data.Aeson.Types.Internal.object ("application_fee_percent" Data.Aeson.Types.ToJSON..= subscriptionApplicationFeePercent obj : "automatic_tax" Data.Aeson.Types.ToJSON..= subscriptionAutomaticTax obj : "billing_cycle_anchor" Data.Aeson.Types.ToJSON..= subscriptionBillingCycleAnchor obj : "billing_thresholds" Data.Aeson.Types.ToJSON..= subscriptionBillingThresholds obj : "cancel_at" Data.Aeson.Types.ToJSON..= subscriptionCancelAt obj : "cancel_at_period_end" Data.Aeson.Types.ToJSON..= subscriptionCancelAtPeriodEnd obj : "canceled_at" Data.Aeson.Types.ToJSON..= subscriptionCanceledAt obj : "collection_method" Data.Aeson.Types.ToJSON..= subscriptionCollectionMethod obj : "created" Data.Aeson.Types.ToJSON..= subscriptionCreated obj : "current_period_end" Data.Aeson.Types.ToJSON..= subscriptionCurrentPeriodEnd obj : "current_period_start" Data.Aeson.Types.ToJSON..= subscriptionCurrentPeriodStart obj : "customer" Data.Aeson.Types.ToJSON..= subscriptionCustomer obj : "days_until_due" Data.Aeson.Types.ToJSON..= subscriptionDaysUntilDue obj : "default_payment_method" Data.Aeson.Types.ToJSON..= subscriptionDefaultPaymentMethod obj : "default_source" Data.Aeson.Types.ToJSON..= subscriptionDefaultSource obj : "default_tax_rates" Data.Aeson.Types.ToJSON..= subscriptionDefaultTaxRates obj : "discount" Data.Aeson.Types.ToJSON..= subscriptionDiscount obj : "ended_at" Data.Aeson.Types.ToJSON..= subscriptionEndedAt obj : "id" Data.Aeson.Types.ToJSON..= subscriptionId obj : "items" Data.Aeson.Types.ToJSON..= subscriptionItems obj : "latest_invoice" Data.Aeson.Types.ToJSON..= subscriptionLatestInvoice obj : "livemode" Data.Aeson.Types.ToJSON..= subscriptionLivemode obj : "metadata" Data.Aeson.Types.ToJSON..= subscriptionMetadata obj : "next_pending_invoice_item_invoice" Data.Aeson.Types.ToJSON..= subscriptionNextPendingInvoiceItemInvoice obj : "pause_collection" Data.Aeson.Types.ToJSON..= subscriptionPauseCollection obj : "pending_invoice_item_interval" Data.Aeson.Types.ToJSON..= subscriptionPendingInvoiceItemInterval obj : "pending_setup_intent" Data.Aeson.Types.ToJSON..= subscriptionPendingSetupIntent obj : "pending_update" Data.Aeson.Types.ToJSON..= subscriptionPendingUpdate obj : "schedule" Data.Aeson.Types.ToJSON..= subscriptionSchedule obj : "start_date" Data.Aeson.Types.ToJSON..= subscriptionStartDate obj : "status" Data.Aeson.Types.ToJSON..= subscriptionStatus obj : "transfer_data" Data.Aeson.Types.ToJSON..= subscriptionTransferData obj : "trial_end" Data.Aeson.Types.ToJSON..= subscriptionTrialEnd obj : "trial_start" Data.Aeson.Types.ToJSON..= subscriptionTrialStart obj : "object" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "subscription" : GHC.Base.mempty)
  toEncoding obj = Data.Aeson.Encoding.Internal.pairs (("application_fee_percent" Data.Aeson.Types.ToJSON..= subscriptionApplicationFeePercent obj) GHC.Base.<> (("automatic_tax" Data.Aeson.Types.ToJSON..= subscriptionAutomaticTax obj) GHC.Base.<> (("billing_cycle_anchor" Data.Aeson.Types.ToJSON..= subscriptionBillingCycleAnchor obj) GHC.Base.<> (("billing_thresholds" Data.Aeson.Types.ToJSON..= subscriptionBillingThresholds obj) GHC.Base.<> (("cancel_at" Data.Aeson.Types.ToJSON..= subscriptionCancelAt obj) GHC.Base.<> (("cancel_at_period_end" Data.Aeson.Types.ToJSON..= subscriptionCancelAtPeriodEnd obj) GHC.Base.<> (("canceled_at" Data.Aeson.Types.ToJSON..= subscriptionCanceledAt obj) GHC.Base.<> (("collection_method" Data.Aeson.Types.ToJSON..= subscriptionCollectionMethod obj) GHC.Base.<> (("created" Data.Aeson.Types.ToJSON..= subscriptionCreated obj) GHC.Base.<> (("current_period_end" Data.Aeson.Types.ToJSON..= subscriptionCurrentPeriodEnd obj) GHC.Base.<> (("current_period_start" Data.Aeson.Types.ToJSON..= subscriptionCurrentPeriodStart obj) GHC.Base.<> (("customer" Data.Aeson.Types.ToJSON..= subscriptionCustomer obj) GHC.Base.<> (("days_until_due" Data.Aeson.Types.ToJSON..= subscriptionDaysUntilDue obj) GHC.Base.<> (("default_payment_method" Data.Aeson.Types.ToJSON..= subscriptionDefaultPaymentMethod obj) GHC.Base.<> (("default_source" Data.Aeson.Types.ToJSON..= subscriptionDefaultSource obj) GHC.Base.<> (("default_tax_rates" Data.Aeson.Types.ToJSON..= subscriptionDefaultTaxRates obj) GHC.Base.<> (("discount" Data.Aeson.Types.ToJSON..= subscriptionDiscount obj) GHC.Base.<> (("ended_at" Data.Aeson.Types.ToJSON..= subscriptionEndedAt obj) GHC.Base.<> (("id" Data.Aeson.Types.ToJSON..= subscriptionId obj) GHC.Base.<> (("items" Data.Aeson.Types.ToJSON..= subscriptionItems obj) GHC.Base.<> (("latest_invoice" Data.Aeson.Types.ToJSON..= subscriptionLatestInvoice obj) GHC.Base.<> (("livemode" Data.Aeson.Types.ToJSON..= subscriptionLivemode obj) GHC.Base.<> (("metadata" Data.Aeson.Types.ToJSON..= subscriptionMetadata obj) GHC.Base.<> (("next_pending_invoice_item_invoice" Data.Aeson.Types.ToJSON..= subscriptionNextPendingInvoiceItemInvoice obj) GHC.Base.<> (("pause_collection" Data.Aeson.Types.ToJSON..= subscriptionPauseCollection obj) GHC.Base.<> (("pending_invoice_item_interval" Data.Aeson.Types.ToJSON..= subscriptionPendingInvoiceItemInterval obj) GHC.Base.<> (("pending_setup_intent" Data.Aeson.Types.ToJSON..= subscriptionPendingSetupIntent obj) GHC.Base.<> (("pending_update" Data.Aeson.Types.ToJSON..= subscriptionPendingUpdate obj) GHC.Base.<> (("schedule" Data.Aeson.Types.ToJSON..= subscriptionSchedule obj) GHC.Base.<> (("start_date" Data.Aeson.Types.ToJSON..= subscriptionStartDate obj) GHC.Base.<> (("status" Data.Aeson.Types.ToJSON..= subscriptionStatus obj) GHC.Base.<> (("transfer_data" Data.Aeson.Types.ToJSON..= subscriptionTransferData obj) GHC.Base.<> (("trial_end" Data.Aeson.Types.ToJSON..= subscriptionTrialEnd obj) GHC.Base.<> (("trial_start" Data.Aeson.Types.ToJSON..= subscriptionTrialStart obj) GHC.Base.<> ("object" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "subscription")))))))))))))))))))))))))))))))))))

instance Data.Aeson.Types.FromJSON.FromJSON Subscription where
  parseJSON = Data.Aeson.Types.FromJSON.withObject "Subscription" (\obj -> (((((((((((((((((((((((((((((((((GHC.Base.pure Subscription GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "application_fee_percent")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "automatic_tax")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "billing_cycle_anchor")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "billing_thresholds")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "cancel_at")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "cancel_at_period_end")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "canceled_at")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "collection_method")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "created")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "current_period_end")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "current_period_start")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "customer")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "days_until_due")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "default_payment_method")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "default_source")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "default_tax_rates")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "discount")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "ended_at")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "items")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "latest_invoice")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "livemode")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "metadata")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "next_pending_invoice_item_invoice")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "pause_collection")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "pending_invoice_item_interval")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "pending_setup_intent")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "pending_update")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "schedule")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "start_date")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "status")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "transfer_data")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "trial_end")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "trial_start"))

-- | Create a new 'Subscription' with all required fields.
mkSubscription ::
  -- | 'subscriptionAutomaticTax'
  SubscriptionAutomaticTax ->
  -- | 'subscriptionBillingCycleAnchor'
  GHC.Types.Int ->
  -- | 'subscriptionCancelAtPeriodEnd'
  GHC.Types.Bool ->
  -- | 'subscriptionCreated'
  GHC.Types.Int ->
  -- | 'subscriptionCurrentPeriodEnd'
  GHC.Types.Int ->
  -- | 'subscriptionCurrentPeriodStart'
  GHC.Types.Int ->
  -- | 'subscriptionCustomer'
  SubscriptionCustomer'Variants ->
  -- | 'subscriptionId'
  Data.Text.Internal.Text ->
  -- | 'subscriptionItems'
  SubscriptionItems' ->
  -- | 'subscriptionLivemode'
  GHC.Types.Bool ->
  -- | 'subscriptionMetadata'
  Data.Aeson.Types.Internal.Object ->
  -- | 'subscriptionStartDate'
  GHC.Types.Int ->
  -- | 'subscriptionStatus'
  SubscriptionStatus' ->
  Subscription
mkSubscription subscriptionAutomaticTax subscriptionBillingCycleAnchor subscriptionCancelAtPeriodEnd subscriptionCreated subscriptionCurrentPeriodEnd subscriptionCurrentPeriodStart subscriptionCustomer subscriptionId subscriptionItems subscriptionLivemode subscriptionMetadata subscriptionStartDate subscriptionStatus =
  Subscription
    { subscriptionApplicationFeePercent = GHC.Maybe.Nothing,
      subscriptionAutomaticTax = subscriptionAutomaticTax,
      subscriptionBillingCycleAnchor = subscriptionBillingCycleAnchor,
      subscriptionBillingThresholds = GHC.Maybe.Nothing,
      subscriptionCancelAt = GHC.Maybe.Nothing,
      subscriptionCancelAtPeriodEnd = subscriptionCancelAtPeriodEnd,
      subscriptionCanceledAt = GHC.Maybe.Nothing,
      subscriptionCollectionMethod = GHC.Maybe.Nothing,
      subscriptionCreated = subscriptionCreated,
      subscriptionCurrentPeriodEnd = subscriptionCurrentPeriodEnd,
      subscriptionCurrentPeriodStart = subscriptionCurrentPeriodStart,
      subscriptionCustomer = subscriptionCustomer,
      subscriptionDaysUntilDue = GHC.Maybe.Nothing,
      subscriptionDefaultPaymentMethod = GHC.Maybe.Nothing,
      subscriptionDefaultSource = GHC.Maybe.Nothing,
      subscriptionDefaultTaxRates = GHC.Maybe.Nothing,
      subscriptionDiscount = GHC.Maybe.Nothing,
      subscriptionEndedAt = GHC.Maybe.Nothing,
      subscriptionId = subscriptionId,
      subscriptionItems = subscriptionItems,
      subscriptionLatestInvoice = GHC.Maybe.Nothing,
      subscriptionLivemode = subscriptionLivemode,
      subscriptionMetadata = subscriptionMetadata,
      subscriptionNextPendingInvoiceItemInvoice = GHC.Maybe.Nothing,
      subscriptionPauseCollection = GHC.Maybe.Nothing,
      subscriptionPendingInvoiceItemInterval = GHC.Maybe.Nothing,
      subscriptionPendingSetupIntent = GHC.Maybe.Nothing,
      subscriptionPendingUpdate = GHC.Maybe.Nothing,
      subscriptionSchedule = GHC.Maybe.Nothing,
      subscriptionStartDate = subscriptionStartDate,
      subscriptionStatus = subscriptionStatus,
      subscriptionTransferData = GHC.Maybe.Nothing,
      subscriptionTrialEnd = GHC.Maybe.Nothing,
      subscriptionTrialStart = GHC.Maybe.Nothing
    }

-- | Defines the object schema located at @components.schemas.subscription.properties.billing_thresholds.anyOf@ in the specification.
--
-- Define thresholds at which an invoice will be sent, and the subscription advanced to a new billing period
data SubscriptionBillingThresholds' = SubscriptionBillingThresholds'
  { -- | amount_gte: Monetary threshold that triggers the subscription to create an invoice
    subscriptionBillingThresholds'AmountGte :: (GHC.Maybe.Maybe GHC.Types.Int),
    -- | reset_billing_cycle_anchor: Indicates if the \`billing_cycle_anchor\` should be reset when a threshold is reached. If true, \`billing_cycle_anchor\` will be updated to the date\/time the threshold was last reached; otherwise, the value will remain unchanged. This value may not be \`true\` if the subscription contains items with plans that have \`aggregate_usage=last_ever\`.
    subscriptionBillingThresholds'ResetBillingCycleAnchor :: (GHC.Maybe.Maybe GHC.Types.Bool)
  }
  deriving
    ( GHC.Show.Show,
      GHC.Classes.Eq
    )

instance Data.Aeson.Types.ToJSON.ToJSON SubscriptionBillingThresholds' where
  toJSON obj = Data.Aeson.Types.Internal.object ("amount_gte" Data.Aeson.Types.ToJSON..= subscriptionBillingThresholds'AmountGte obj : "reset_billing_cycle_anchor" Data.Aeson.Types.ToJSON..= subscriptionBillingThresholds'ResetBillingCycleAnchor obj : GHC.Base.mempty)
  toEncoding obj = Data.Aeson.Encoding.Internal.pairs (("amount_gte" Data.Aeson.Types.ToJSON..= subscriptionBillingThresholds'AmountGte obj) GHC.Base.<> ("reset_billing_cycle_anchor" Data.Aeson.Types.ToJSON..= subscriptionBillingThresholds'ResetBillingCycleAnchor obj))

instance Data.Aeson.Types.FromJSON.FromJSON SubscriptionBillingThresholds' where
  parseJSON = Data.Aeson.Types.FromJSON.withObject "SubscriptionBillingThresholds'" (\obj -> (GHC.Base.pure SubscriptionBillingThresholds' GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "amount_gte")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "reset_billing_cycle_anchor"))

-- | Create a new 'SubscriptionBillingThresholds'' with all required fields.
mkSubscriptionBillingThresholds' :: SubscriptionBillingThresholds'
mkSubscriptionBillingThresholds' =
  SubscriptionBillingThresholds'
    { subscriptionBillingThresholds'AmountGte = GHC.Maybe.Nothing,
      subscriptionBillingThresholds'ResetBillingCycleAnchor = GHC.Maybe.Nothing
    }

-- | Defines the enum schema located at @components.schemas.subscription.properties.collection_method@ in the specification.
--
-- Either \`charge_automatically\`, or \`send_invoice\`. When charging automatically, Stripe will attempt to pay this subscription at the end of the cycle using the default source attached to the customer. When sending an invoice, Stripe will email your customer an invoice with payment instructions.
data SubscriptionCollectionMethod'
  = -- | This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
    SubscriptionCollectionMethod'Other Data.Aeson.Types.Internal.Value
  | -- | This constructor can be used to send values to the server which are not present in the specification yet.
    SubscriptionCollectionMethod'Typed Data.Text.Internal.Text
  | -- | Represents the JSON value @"charge_automatically"@
    SubscriptionCollectionMethod'EnumChargeAutomatically
  | -- | Represents the JSON value @"send_invoice"@
    SubscriptionCollectionMethod'EnumSendInvoice
  deriving (GHC.Show.Show, GHC.Classes.Eq)

instance Data.Aeson.Types.ToJSON.ToJSON SubscriptionCollectionMethod' where
  toJSON (SubscriptionCollectionMethod'Other val) = val
  toJSON (SubscriptionCollectionMethod'Typed val) = Data.Aeson.Types.ToJSON.toJSON val
  toJSON (SubscriptionCollectionMethod'EnumChargeAutomatically) = "charge_automatically"
  toJSON (SubscriptionCollectionMethod'EnumSendInvoice) = "send_invoice"

instance Data.Aeson.Types.FromJSON.FromJSON SubscriptionCollectionMethod' where
  parseJSON val =
    GHC.Base.pure
      ( if
            | val GHC.Classes.== "charge_automatically" -> SubscriptionCollectionMethod'EnumChargeAutomatically
            | val GHC.Classes.== "send_invoice" -> SubscriptionCollectionMethod'EnumSendInvoice
            | GHC.Base.otherwise -> SubscriptionCollectionMethod'Other val
      )

-- | Defines the oneOf schema located at @components.schemas.subscription.properties.customer.anyOf@ in the specification.
--
-- ID of the customer who owns the subscription.
data SubscriptionCustomer'Variants
  = SubscriptionCustomer'Text Data.Text.Internal.Text
  | SubscriptionCustomer'Customer Customer
  | SubscriptionCustomer'DeletedCustomer DeletedCustomer
  deriving (GHC.Show.Show, GHC.Classes.Eq)

instance Data.Aeson.Types.ToJSON.ToJSON SubscriptionCustomer'Variants where
  toJSON (SubscriptionCustomer'Text a) = Data.Aeson.Types.ToJSON.toJSON a
  toJSON (SubscriptionCustomer'Customer a) = Data.Aeson.Types.ToJSON.toJSON a
  toJSON (SubscriptionCustomer'DeletedCustomer a) = Data.Aeson.Types.ToJSON.toJSON a

instance Data.Aeson.Types.FromJSON.FromJSON SubscriptionCustomer'Variants where
  parseJSON val = case (SubscriptionCustomer'Text Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((SubscriptionCustomer'Customer Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((SubscriptionCustomer'DeletedCustomer Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> Data.Aeson.Types.Internal.Error "No variant matched")) of
    Data.Aeson.Types.Internal.Success a -> GHC.Base.pure a
    Data.Aeson.Types.Internal.Error a -> Control.Monad.Fail.fail a

-- | Defines the oneOf schema located at @components.schemas.subscription.properties.default_payment_method.anyOf@ in the specification.
--
-- ID of the default payment method for the subscription. It must belong to the customer associated with the subscription. This takes precedence over \`default_source\`. If neither are set, invoices will use the customer\'s [invoice_settings.default_payment_method](https:\/\/stripe.com\/docs\/api\/customers\/object\#customer_object-invoice_settings-default_payment_method) or [default_source](https:\/\/stripe.com\/docs\/api\/customers\/object\#customer_object-default_source).
data SubscriptionDefaultPaymentMethod'Variants
  = SubscriptionDefaultPaymentMethod'Text Data.Text.Internal.Text
  | SubscriptionDefaultPaymentMethod'PaymentMethod PaymentMethod
  deriving (GHC.Show.Show, GHC.Classes.Eq)

instance Data.Aeson.Types.ToJSON.ToJSON SubscriptionDefaultPaymentMethod'Variants where
  toJSON (SubscriptionDefaultPaymentMethod'Text a) = Data.Aeson.Types.ToJSON.toJSON a
  toJSON (SubscriptionDefaultPaymentMethod'PaymentMethod a) = Data.Aeson.Types.ToJSON.toJSON a

instance Data.Aeson.Types.FromJSON.FromJSON SubscriptionDefaultPaymentMethod'Variants where
  parseJSON val = case (SubscriptionDefaultPaymentMethod'Text Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((SubscriptionDefaultPaymentMethod'PaymentMethod Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> Data.Aeson.Types.Internal.Error "No variant matched") of
    Data.Aeson.Types.Internal.Success a -> GHC.Base.pure a
    Data.Aeson.Types.Internal.Error a -> Control.Monad.Fail.fail a

-- | Defines the oneOf schema located at @components.schemas.subscription.properties.default_source.anyOf@ in the specification.
--
-- ID of the default payment source for the subscription. It must belong to the customer associated with the subscription and be in a chargeable state. If \`default_payment_method\` is also set, \`default_payment_method\` will take precedence. If neither are set, invoices will use the customer\'s [invoice_settings.default_payment_method](https:\/\/stripe.com\/docs\/api\/customers\/object\#customer_object-invoice_settings-default_payment_method) or [default_source](https:\/\/stripe.com\/docs\/api\/customers\/object\#customer_object-default_source).
data SubscriptionDefaultSource'Variants
  = SubscriptionDefaultSource'Text Data.Text.Internal.Text
  | SubscriptionDefaultSource'AlipayAccount AlipayAccount
  | SubscriptionDefaultSource'BankAccount BankAccount
  | SubscriptionDefaultSource'BitcoinReceiver BitcoinReceiver
  | SubscriptionDefaultSource'Card Card
  | SubscriptionDefaultSource'Source Source
  deriving (GHC.Show.Show, GHC.Classes.Eq)

instance Data.Aeson.Types.ToJSON.ToJSON SubscriptionDefaultSource'Variants where
  toJSON (SubscriptionDefaultSource'Text a) = Data.Aeson.Types.ToJSON.toJSON a
  toJSON (SubscriptionDefaultSource'AlipayAccount a) = Data.Aeson.Types.ToJSON.toJSON a
  toJSON (SubscriptionDefaultSource'BankAccount a) = Data.Aeson.Types.ToJSON.toJSON a
  toJSON (SubscriptionDefaultSource'BitcoinReceiver a) = Data.Aeson.Types.ToJSON.toJSON a
  toJSON (SubscriptionDefaultSource'Card a) = Data.Aeson.Types.ToJSON.toJSON a
  toJSON (SubscriptionDefaultSource'Source a) = Data.Aeson.Types.ToJSON.toJSON a

instance Data.Aeson.Types.FromJSON.FromJSON SubscriptionDefaultSource'Variants where
  parseJSON val = case (SubscriptionDefaultSource'Text Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((SubscriptionDefaultSource'AlipayAccount Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((SubscriptionDefaultSource'BankAccount Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((SubscriptionDefaultSource'BitcoinReceiver Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((SubscriptionDefaultSource'Card Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((SubscriptionDefaultSource'Source Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> Data.Aeson.Types.Internal.Error "No variant matched"))))) of
    Data.Aeson.Types.Internal.Success a -> GHC.Base.pure a
    Data.Aeson.Types.Internal.Error a -> Control.Monad.Fail.fail a

-- | Defines the object schema located at @components.schemas.subscription.properties.discount.anyOf@ in the specification.
--
-- Describes the current discount applied to this subscription, if there is one. When billing, a discount applied to a subscription overrides a discount applied on a customer-wide basis.
data SubscriptionDiscount' = SubscriptionDiscount'
  { -- | checkout_session: The Checkout session that this coupon is applied to, if it is applied to a particular session in payment mode. Will not be present for subscription mode.
    --
    -- Constraints:
    --
    -- * Maximum length of 5000
    subscriptionDiscount'CheckoutSession :: (GHC.Maybe.Maybe Data.Text.Internal.Text),
    -- | coupon: A coupon contains information about a percent-off or amount-off discount you
    -- might want to apply to a customer. Coupons may be applied to [invoices](https:\/\/stripe.com\/docs\/api\#invoices) or
    -- [orders](https:\/\/stripe.com\/docs\/api\#create_order-coupon). Coupons do not work with conventional one-off [charges](https:\/\/stripe.com\/docs\/api\#create_charge).
    subscriptionDiscount'Coupon :: (GHC.Maybe.Maybe Coupon),
    -- | customer: The ID of the customer associated with this discount.
    subscriptionDiscount'Customer :: (GHC.Maybe.Maybe SubscriptionDiscount'Customer'Variants),
    -- | end: If the coupon has a duration of \`repeating\`, the date that this discount will end. If the coupon has a duration of \`once\` or \`forever\`, this attribute will be null.
    subscriptionDiscount'End :: (GHC.Maybe.Maybe GHC.Types.Int),
    -- | id: The ID of the discount object. Discounts cannot be fetched by ID. Use \`expand[]=discounts\` in API calls to expand discount IDs in an array.
    --
    -- Constraints:
    --
    -- * Maximum length of 5000
    subscriptionDiscount'Id :: (GHC.Maybe.Maybe Data.Text.Internal.Text),
    -- | invoice: The invoice that the discount\'s coupon was applied to, if it was applied directly to a particular invoice.
    --
    -- Constraints:
    --
    -- * Maximum length of 5000
    subscriptionDiscount'Invoice :: (GHC.Maybe.Maybe Data.Text.Internal.Text),
    -- | invoice_item: The invoice item \`id\` (or invoice line item \`id\` for invoice line items of type=\'subscription\') that the discount\'s coupon was applied to, if it was applied directly to a particular invoice item or invoice line item.
    --
    -- Constraints:
    --
    -- * Maximum length of 5000
    subscriptionDiscount'InvoiceItem :: (GHC.Maybe.Maybe Data.Text.Internal.Text),
    -- | promotion_code: The promotion code applied to create this discount.
    subscriptionDiscount'PromotionCode :: (GHC.Maybe.Maybe SubscriptionDiscount'PromotionCode'Variants),
    -- | start: Date that the coupon was applied.
    subscriptionDiscount'Start :: (GHC.Maybe.Maybe GHC.Types.Int),
    -- | subscription: The subscription that this coupon is applied to, if it is applied to a particular subscription.
    --
    -- Constraints:
    --
    -- * Maximum length of 5000
    subscriptionDiscount'Subscription :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  }
  deriving
    ( GHC.Show.Show,
      GHC.Classes.Eq
    )

instance Data.Aeson.Types.ToJSON.ToJSON SubscriptionDiscount' where
  toJSON obj = Data.Aeson.Types.Internal.object ("checkout_session" Data.Aeson.Types.ToJSON..= subscriptionDiscount'CheckoutSession obj : "coupon" Data.Aeson.Types.ToJSON..= subscriptionDiscount'Coupon obj : "customer" Data.Aeson.Types.ToJSON..= subscriptionDiscount'Customer obj : "end" Data.Aeson.Types.ToJSON..= subscriptionDiscount'End obj : "id" Data.Aeson.Types.ToJSON..= subscriptionDiscount'Id obj : "invoice" Data.Aeson.Types.ToJSON..= subscriptionDiscount'Invoice obj : "invoice_item" Data.Aeson.Types.ToJSON..= subscriptionDiscount'InvoiceItem obj : "promotion_code" Data.Aeson.Types.ToJSON..= subscriptionDiscount'PromotionCode obj : "start" Data.Aeson.Types.ToJSON..= subscriptionDiscount'Start obj : "subscription" Data.Aeson.Types.ToJSON..= subscriptionDiscount'Subscription obj : "object" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "discount" : GHC.Base.mempty)
  toEncoding obj = Data.Aeson.Encoding.Internal.pairs (("checkout_session" Data.Aeson.Types.ToJSON..= subscriptionDiscount'CheckoutSession obj) GHC.Base.<> (("coupon" Data.Aeson.Types.ToJSON..= subscriptionDiscount'Coupon obj) GHC.Base.<> (("customer" Data.Aeson.Types.ToJSON..= subscriptionDiscount'Customer obj) GHC.Base.<> (("end" Data.Aeson.Types.ToJSON..= subscriptionDiscount'End obj) GHC.Base.<> (("id" Data.Aeson.Types.ToJSON..= subscriptionDiscount'Id obj) GHC.Base.<> (("invoice" Data.Aeson.Types.ToJSON..= subscriptionDiscount'Invoice obj) GHC.Base.<> (("invoice_item" Data.Aeson.Types.ToJSON..= subscriptionDiscount'InvoiceItem obj) GHC.Base.<> (("promotion_code" Data.Aeson.Types.ToJSON..= subscriptionDiscount'PromotionCode obj) GHC.Base.<> (("start" Data.Aeson.Types.ToJSON..= subscriptionDiscount'Start obj) GHC.Base.<> (("subscription" Data.Aeson.Types.ToJSON..= subscriptionDiscount'Subscription obj) GHC.Base.<> ("object" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "discount")))))))))))

instance Data.Aeson.Types.FromJSON.FromJSON SubscriptionDiscount' where
  parseJSON = Data.Aeson.Types.FromJSON.withObject "SubscriptionDiscount'" (\obj -> (((((((((GHC.Base.pure SubscriptionDiscount' GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "checkout_session")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "coupon")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "customer")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "end")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "invoice")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "invoice_item")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "promotion_code")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "start")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "subscription"))

-- | Create a new 'SubscriptionDiscount'' with all required fields.
mkSubscriptionDiscount' :: SubscriptionDiscount'
mkSubscriptionDiscount' =
  SubscriptionDiscount'
    { subscriptionDiscount'CheckoutSession = GHC.Maybe.Nothing,
      subscriptionDiscount'Coupon = GHC.Maybe.Nothing,
      subscriptionDiscount'Customer = GHC.Maybe.Nothing,
      subscriptionDiscount'End = GHC.Maybe.Nothing,
      subscriptionDiscount'Id = GHC.Maybe.Nothing,
      subscriptionDiscount'Invoice = GHC.Maybe.Nothing,
      subscriptionDiscount'InvoiceItem = GHC.Maybe.Nothing,
      subscriptionDiscount'PromotionCode = GHC.Maybe.Nothing,
      subscriptionDiscount'Start = GHC.Maybe.Nothing,
      subscriptionDiscount'Subscription = GHC.Maybe.Nothing
    }

-- | Defines the oneOf schema located at @components.schemas.subscription.properties.discount.anyOf.properties.customer.anyOf@ in the specification.
--
-- The ID of the customer associated with this discount.
data SubscriptionDiscount'Customer'Variants
  = SubscriptionDiscount'Customer'Text Data.Text.Internal.Text
  | SubscriptionDiscount'Customer'Customer Customer
  | SubscriptionDiscount'Customer'DeletedCustomer DeletedCustomer
  deriving (GHC.Show.Show, GHC.Classes.Eq)

instance Data.Aeson.Types.ToJSON.ToJSON SubscriptionDiscount'Customer'Variants where
  toJSON (SubscriptionDiscount'Customer'Text a) = Data.Aeson.Types.ToJSON.toJSON a
  toJSON (SubscriptionDiscount'Customer'Customer a) = Data.Aeson.Types.ToJSON.toJSON a
  toJSON (SubscriptionDiscount'Customer'DeletedCustomer a) = Data.Aeson.Types.ToJSON.toJSON a

instance Data.Aeson.Types.FromJSON.FromJSON SubscriptionDiscount'Customer'Variants where
  parseJSON val = case (SubscriptionDiscount'Customer'Text Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((SubscriptionDiscount'Customer'Customer Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((SubscriptionDiscount'Customer'DeletedCustomer Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> Data.Aeson.Types.Internal.Error "No variant matched")) of
    Data.Aeson.Types.Internal.Success a -> GHC.Base.pure a
    Data.Aeson.Types.Internal.Error a -> Control.Monad.Fail.fail a

-- | Defines the oneOf schema located at @components.schemas.subscription.properties.discount.anyOf.properties.promotion_code.anyOf@ in the specification.
--
-- The promotion code applied to create this discount.
data SubscriptionDiscount'PromotionCode'Variants
  = SubscriptionDiscount'PromotionCode'Text Data.Text.Internal.Text
  | SubscriptionDiscount'PromotionCode'PromotionCode PromotionCode
  deriving (GHC.Show.Show, GHC.Classes.Eq)

instance Data.Aeson.Types.ToJSON.ToJSON SubscriptionDiscount'PromotionCode'Variants where
  toJSON (SubscriptionDiscount'PromotionCode'Text a) = Data.Aeson.Types.ToJSON.toJSON a
  toJSON (SubscriptionDiscount'PromotionCode'PromotionCode a) = Data.Aeson.Types.ToJSON.toJSON a

instance Data.Aeson.Types.FromJSON.FromJSON SubscriptionDiscount'PromotionCode'Variants where
  parseJSON val = case (SubscriptionDiscount'PromotionCode'Text Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((SubscriptionDiscount'PromotionCode'PromotionCode Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> Data.Aeson.Types.Internal.Error "No variant matched") of
    Data.Aeson.Types.Internal.Success a -> GHC.Base.pure a
    Data.Aeson.Types.Internal.Error a -> Control.Monad.Fail.fail a

-- | Defines the object schema located at @components.schemas.subscription.properties.items@ in the specification.
--
-- List of subscription items, each with an attached price.
data SubscriptionItems' = SubscriptionItems'
  { -- | data: Details about each object.
    subscriptionItems'Data :: ([SubscriptionItem]),
    -- | has_more: True if this list has another page of items after this one that can be fetched.
    subscriptionItems'HasMore :: GHC.Types.Bool,
    -- | url: The URL where this list can be accessed.
    --
    -- Constraints:
    --
    -- * Maximum length of 5000
    subscriptionItems'Url :: Data.Text.Internal.Text
  }
  deriving
    ( GHC.Show.Show,
      GHC.Classes.Eq
    )

instance Data.Aeson.Types.ToJSON.ToJSON SubscriptionItems' where
  toJSON obj = Data.Aeson.Types.Internal.object ("data" Data.Aeson.Types.ToJSON..= subscriptionItems'Data obj : "has_more" Data.Aeson.Types.ToJSON..= subscriptionItems'HasMore obj : "url" Data.Aeson.Types.ToJSON..= subscriptionItems'Url obj : "object" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "list" : GHC.Base.mempty)
  toEncoding obj = Data.Aeson.Encoding.Internal.pairs (("data" Data.Aeson.Types.ToJSON..= subscriptionItems'Data obj) GHC.Base.<> (("has_more" Data.Aeson.Types.ToJSON..= subscriptionItems'HasMore obj) GHC.Base.<> (("url" Data.Aeson.Types.ToJSON..= subscriptionItems'Url obj) GHC.Base.<> ("object" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "list"))))

instance Data.Aeson.Types.FromJSON.FromJSON SubscriptionItems' where
  parseJSON = Data.Aeson.Types.FromJSON.withObject "SubscriptionItems'" (\obj -> ((GHC.Base.pure SubscriptionItems' GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "data")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "has_more")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "url"))

-- | Create a new 'SubscriptionItems'' with all required fields.
mkSubscriptionItems' ::
  -- | 'subscriptionItems'Data'
  [SubscriptionItem] ->
  -- | 'subscriptionItems'HasMore'
  GHC.Types.Bool ->
  -- | 'subscriptionItems'Url'
  Data.Text.Internal.Text ->
  SubscriptionItems'
mkSubscriptionItems' subscriptionItems'Data subscriptionItems'HasMore subscriptionItems'Url =
  SubscriptionItems'
    { subscriptionItems'Data = subscriptionItems'Data,
      subscriptionItems'HasMore = subscriptionItems'HasMore,
      subscriptionItems'Url = subscriptionItems'Url
    }

-- | Defines the oneOf schema located at @components.schemas.subscription.properties.latest_invoice.anyOf@ in the specification.
--
-- The most recent invoice this subscription has generated.
data SubscriptionLatestInvoice'Variants
  = SubscriptionLatestInvoice'Text Data.Text.Internal.Text
  | SubscriptionLatestInvoice'Invoice Invoice
  deriving (GHC.Show.Show, GHC.Classes.Eq)

instance Data.Aeson.Types.ToJSON.ToJSON SubscriptionLatestInvoice'Variants where
  toJSON (SubscriptionLatestInvoice'Text a) = Data.Aeson.Types.ToJSON.toJSON a
  toJSON (SubscriptionLatestInvoice'Invoice a) = Data.Aeson.Types.ToJSON.toJSON a

instance Data.Aeson.Types.FromJSON.FromJSON SubscriptionLatestInvoice'Variants where
  parseJSON val = case (SubscriptionLatestInvoice'Text Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((SubscriptionLatestInvoice'Invoice Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> Data.Aeson.Types.Internal.Error "No variant matched") of
    Data.Aeson.Types.Internal.Success a -> GHC.Base.pure a
    Data.Aeson.Types.Internal.Error a -> Control.Monad.Fail.fail a

-- | Defines the object schema located at @components.schemas.subscription.properties.pause_collection.anyOf@ in the specification.
--
-- If specified, payment collection for this subscription will be paused.
data SubscriptionPauseCollection' = SubscriptionPauseCollection'
  { -- | behavior: The payment collection behavior for this subscription while paused. One of \`keep_as_draft\`, \`mark_uncollectible\`, or \`void\`.
    subscriptionPauseCollection'Behavior :: (GHC.Maybe.Maybe SubscriptionPauseCollection'Behavior'),
    -- | resumes_at: The time after which the subscription will resume collecting payments.
    subscriptionPauseCollection'ResumesAt :: (GHC.Maybe.Maybe GHC.Types.Int)
  }
  deriving
    ( GHC.Show.Show,
      GHC.Classes.Eq
    )

instance Data.Aeson.Types.ToJSON.ToJSON SubscriptionPauseCollection' where
  toJSON obj = Data.Aeson.Types.Internal.object ("behavior" Data.Aeson.Types.ToJSON..= subscriptionPauseCollection'Behavior obj : "resumes_at" Data.Aeson.Types.ToJSON..= subscriptionPauseCollection'ResumesAt obj : GHC.Base.mempty)
  toEncoding obj = Data.Aeson.Encoding.Internal.pairs (("behavior" Data.Aeson.Types.ToJSON..= subscriptionPauseCollection'Behavior obj) GHC.Base.<> ("resumes_at" Data.Aeson.Types.ToJSON..= subscriptionPauseCollection'ResumesAt obj))

instance Data.Aeson.Types.FromJSON.FromJSON SubscriptionPauseCollection' where
  parseJSON = Data.Aeson.Types.FromJSON.withObject "SubscriptionPauseCollection'" (\obj -> (GHC.Base.pure SubscriptionPauseCollection' GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "behavior")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "resumes_at"))

-- | Create a new 'SubscriptionPauseCollection'' with all required fields.
mkSubscriptionPauseCollection' :: SubscriptionPauseCollection'
mkSubscriptionPauseCollection' =
  SubscriptionPauseCollection'
    { subscriptionPauseCollection'Behavior = GHC.Maybe.Nothing,
      subscriptionPauseCollection'ResumesAt = GHC.Maybe.Nothing
    }

-- | Defines the enum schema located at @components.schemas.subscription.properties.pause_collection.anyOf.properties.behavior@ in the specification.
--
-- The payment collection behavior for this subscription while paused. One of \`keep_as_draft\`, \`mark_uncollectible\`, or \`void\`.
data SubscriptionPauseCollection'Behavior'
  = -- | This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
    SubscriptionPauseCollection'Behavior'Other Data.Aeson.Types.Internal.Value
  | -- | This constructor can be used to send values to the server which are not present in the specification yet.
    SubscriptionPauseCollection'Behavior'Typed Data.Text.Internal.Text
  | -- | Represents the JSON value @"keep_as_draft"@
    SubscriptionPauseCollection'Behavior'EnumKeepAsDraft
  | -- | Represents the JSON value @"mark_uncollectible"@
    SubscriptionPauseCollection'Behavior'EnumMarkUncollectible
  | -- | Represents the JSON value @"void"@
    SubscriptionPauseCollection'Behavior'EnumVoid
  deriving (GHC.Show.Show, GHC.Classes.Eq)

instance Data.Aeson.Types.ToJSON.ToJSON SubscriptionPauseCollection'Behavior' where
  toJSON (SubscriptionPauseCollection'Behavior'Other val) = val
  toJSON (SubscriptionPauseCollection'Behavior'Typed val) = Data.Aeson.Types.ToJSON.toJSON val
  toJSON (SubscriptionPauseCollection'Behavior'EnumKeepAsDraft) = "keep_as_draft"
  toJSON (SubscriptionPauseCollection'Behavior'EnumMarkUncollectible) = "mark_uncollectible"
  toJSON (SubscriptionPauseCollection'Behavior'EnumVoid) = "void"

instance Data.Aeson.Types.FromJSON.FromJSON SubscriptionPauseCollection'Behavior' where
  parseJSON val =
    GHC.Base.pure
      ( if
            | val GHC.Classes.== "keep_as_draft" -> SubscriptionPauseCollection'Behavior'EnumKeepAsDraft
            | val GHC.Classes.== "mark_uncollectible" -> SubscriptionPauseCollection'Behavior'EnumMarkUncollectible
            | val GHC.Classes.== "void" -> SubscriptionPauseCollection'Behavior'EnumVoid
            | GHC.Base.otherwise -> SubscriptionPauseCollection'Behavior'Other val
      )

-- | Defines the object schema located at @components.schemas.subscription.properties.pending_invoice_item_interval.anyOf@ in the specification.
--
-- Specifies an interval for how often to bill for any pending invoice items. It is analogous to calling [Create an invoice](https:\\\/\\\/stripe.com\\\/docs\\\/api\\\#create_invoice) for the given subscription at the specified interval.
data SubscriptionPendingInvoiceItemInterval' = SubscriptionPendingInvoiceItemInterval'
  { -- | interval: Specifies invoicing frequency. Either \`day\`, \`week\`, \`month\` or \`year\`.
    subscriptionPendingInvoiceItemInterval'Interval :: (GHC.Maybe.Maybe SubscriptionPendingInvoiceItemInterval'Interval'),
    -- | interval_count: The number of intervals between invoices. For example, \`interval=month\` and \`interval_count=3\` bills every 3 months. Maximum of one year interval allowed (1 year, 12 months, or 52 weeks).
    subscriptionPendingInvoiceItemInterval'IntervalCount :: (GHC.Maybe.Maybe GHC.Types.Int)
  }
  deriving
    ( GHC.Show.Show,
      GHC.Classes.Eq
    )

instance Data.Aeson.Types.ToJSON.ToJSON SubscriptionPendingInvoiceItemInterval' where
  toJSON obj = Data.Aeson.Types.Internal.object ("interval" Data.Aeson.Types.ToJSON..= subscriptionPendingInvoiceItemInterval'Interval obj : "interval_count" Data.Aeson.Types.ToJSON..= subscriptionPendingInvoiceItemInterval'IntervalCount obj : GHC.Base.mempty)
  toEncoding obj = Data.Aeson.Encoding.Internal.pairs (("interval" Data.Aeson.Types.ToJSON..= subscriptionPendingInvoiceItemInterval'Interval obj) GHC.Base.<> ("interval_count" Data.Aeson.Types.ToJSON..= subscriptionPendingInvoiceItemInterval'IntervalCount obj))

instance Data.Aeson.Types.FromJSON.FromJSON SubscriptionPendingInvoiceItemInterval' where
  parseJSON = Data.Aeson.Types.FromJSON.withObject "SubscriptionPendingInvoiceItemInterval'" (\obj -> (GHC.Base.pure SubscriptionPendingInvoiceItemInterval' GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "interval")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "interval_count"))

-- | Create a new 'SubscriptionPendingInvoiceItemInterval'' with all required fields.
mkSubscriptionPendingInvoiceItemInterval' :: SubscriptionPendingInvoiceItemInterval'
mkSubscriptionPendingInvoiceItemInterval' =
  SubscriptionPendingInvoiceItemInterval'
    { subscriptionPendingInvoiceItemInterval'Interval = GHC.Maybe.Nothing,
      subscriptionPendingInvoiceItemInterval'IntervalCount = GHC.Maybe.Nothing
    }

-- | Defines the enum schema located at @components.schemas.subscription.properties.pending_invoice_item_interval.anyOf.properties.interval@ in the specification.
--
-- Specifies invoicing frequency. Either \`day\`, \`week\`, \`month\` or \`year\`.
data SubscriptionPendingInvoiceItemInterval'Interval'
  = -- | This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
    SubscriptionPendingInvoiceItemInterval'Interval'Other Data.Aeson.Types.Internal.Value
  | -- | This constructor can be used to send values to the server which are not present in the specification yet.
    SubscriptionPendingInvoiceItemInterval'Interval'Typed Data.Text.Internal.Text
  | -- | Represents the JSON value @"day"@
    SubscriptionPendingInvoiceItemInterval'Interval'EnumDay
  | -- | Represents the JSON value @"month"@
    SubscriptionPendingInvoiceItemInterval'Interval'EnumMonth
  | -- | Represents the JSON value @"week"@
    SubscriptionPendingInvoiceItemInterval'Interval'EnumWeek
  | -- | Represents the JSON value @"year"@
    SubscriptionPendingInvoiceItemInterval'Interval'EnumYear
  deriving (GHC.Show.Show, GHC.Classes.Eq)

instance Data.Aeson.Types.ToJSON.ToJSON SubscriptionPendingInvoiceItemInterval'Interval' where
  toJSON (SubscriptionPendingInvoiceItemInterval'Interval'Other val) = val
  toJSON (SubscriptionPendingInvoiceItemInterval'Interval'Typed val) = Data.Aeson.Types.ToJSON.toJSON val
  toJSON (SubscriptionPendingInvoiceItemInterval'Interval'EnumDay) = "day"
  toJSON (SubscriptionPendingInvoiceItemInterval'Interval'EnumMonth) = "month"
  toJSON (SubscriptionPendingInvoiceItemInterval'Interval'EnumWeek) = "week"
  toJSON (SubscriptionPendingInvoiceItemInterval'Interval'EnumYear) = "year"

instance Data.Aeson.Types.FromJSON.FromJSON SubscriptionPendingInvoiceItemInterval'Interval' where
  parseJSON val =
    GHC.Base.pure
      ( if
            | val GHC.Classes.== "day" -> SubscriptionPendingInvoiceItemInterval'Interval'EnumDay
            | val GHC.Classes.== "month" -> SubscriptionPendingInvoiceItemInterval'Interval'EnumMonth
            | val GHC.Classes.== "week" -> SubscriptionPendingInvoiceItemInterval'Interval'EnumWeek
            | val GHC.Classes.== "year" -> SubscriptionPendingInvoiceItemInterval'Interval'EnumYear
            | GHC.Base.otherwise -> SubscriptionPendingInvoiceItemInterval'Interval'Other val
      )

-- | Defines the oneOf schema located at @components.schemas.subscription.properties.pending_setup_intent.anyOf@ in the specification.
--
-- You can use this [SetupIntent](https:\/\/stripe.com\/docs\/api\/setup_intents) to collect user authentication when creating a subscription without immediate payment or updating a subscription\'s payment method, allowing you to optimize for off-session payments. Learn more in the [SCA Migration Guide](https:\/\/stripe.com\/docs\/billing\/migration\/strong-customer-authentication\#scenario-2).
data SubscriptionPendingSetupIntent'Variants
  = SubscriptionPendingSetupIntent'Text Data.Text.Internal.Text
  | SubscriptionPendingSetupIntent'SetupIntent SetupIntent
  deriving (GHC.Show.Show, GHC.Classes.Eq)

instance Data.Aeson.Types.ToJSON.ToJSON SubscriptionPendingSetupIntent'Variants where
  toJSON (SubscriptionPendingSetupIntent'Text a) = Data.Aeson.Types.ToJSON.toJSON a
  toJSON (SubscriptionPendingSetupIntent'SetupIntent a) = Data.Aeson.Types.ToJSON.toJSON a

instance Data.Aeson.Types.FromJSON.FromJSON SubscriptionPendingSetupIntent'Variants where
  parseJSON val = case (SubscriptionPendingSetupIntent'Text Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((SubscriptionPendingSetupIntent'SetupIntent Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> Data.Aeson.Types.Internal.Error "No variant matched") of
    Data.Aeson.Types.Internal.Success a -> GHC.Base.pure a
    Data.Aeson.Types.Internal.Error a -> Control.Monad.Fail.fail a

-- | Defines the object schema located at @components.schemas.subscription.properties.pending_update.anyOf@ in the specification.
--
-- If specified, [pending updates](https:\\\/\\\/stripe.com\\\/docs\\\/billing\\\/subscriptions\\\/pending-updates) that will be applied to the subscription once the \\\`latest_invoice\\\` has been paid.
data SubscriptionPendingUpdate' = SubscriptionPendingUpdate'
  { -- | billing_cycle_anchor: If the update is applied, determines the date of the first full invoice, and, for plans with \`month\` or \`year\` intervals, the day of the month for subsequent invoices.
    subscriptionPendingUpdate'BillingCycleAnchor :: (GHC.Maybe.Maybe GHC.Types.Int),
    -- | expires_at: The point after which the changes reflected by this update will be discarded and no longer applied.
    subscriptionPendingUpdate'ExpiresAt :: (GHC.Maybe.Maybe GHC.Types.Int),
    -- | subscription_items: List of subscription items, each with an attached plan, that will be set if the update is applied.
    subscriptionPendingUpdate'SubscriptionItems :: (GHC.Maybe.Maybe ([SubscriptionItem])),
    -- | trial_end: Unix timestamp representing the end of the trial period the customer will get before being charged for the first time, if the update is applied.
    subscriptionPendingUpdate'TrialEnd :: (GHC.Maybe.Maybe GHC.Types.Int),
    -- | trial_from_plan: Indicates if a plan\'s \`trial_period_days\` should be applied to the subscription. Setting \`trial_end\` per subscription is preferred, and this defaults to \`false\`. Setting this flag to \`true\` together with \`trial_end\` is not allowed.
    subscriptionPendingUpdate'TrialFromPlan :: (GHC.Maybe.Maybe GHC.Types.Bool)
  }
  deriving
    ( GHC.Show.Show,
      GHC.Classes.Eq
    )

instance Data.Aeson.Types.ToJSON.ToJSON SubscriptionPendingUpdate' where
  toJSON obj = Data.Aeson.Types.Internal.object ("billing_cycle_anchor" Data.Aeson.Types.ToJSON..= subscriptionPendingUpdate'BillingCycleAnchor obj : "expires_at" Data.Aeson.Types.ToJSON..= subscriptionPendingUpdate'ExpiresAt obj : "subscription_items" Data.Aeson.Types.ToJSON..= subscriptionPendingUpdate'SubscriptionItems obj : "trial_end" Data.Aeson.Types.ToJSON..= subscriptionPendingUpdate'TrialEnd obj : "trial_from_plan" Data.Aeson.Types.ToJSON..= subscriptionPendingUpdate'TrialFromPlan obj : GHC.Base.mempty)
  toEncoding obj = Data.Aeson.Encoding.Internal.pairs (("billing_cycle_anchor" Data.Aeson.Types.ToJSON..= subscriptionPendingUpdate'BillingCycleAnchor obj) GHC.Base.<> (("expires_at" Data.Aeson.Types.ToJSON..= subscriptionPendingUpdate'ExpiresAt obj) GHC.Base.<> (("subscription_items" Data.Aeson.Types.ToJSON..= subscriptionPendingUpdate'SubscriptionItems obj) GHC.Base.<> (("trial_end" Data.Aeson.Types.ToJSON..= subscriptionPendingUpdate'TrialEnd obj) GHC.Base.<> ("trial_from_plan" Data.Aeson.Types.ToJSON..= subscriptionPendingUpdate'TrialFromPlan obj)))))

instance Data.Aeson.Types.FromJSON.FromJSON SubscriptionPendingUpdate' where
  parseJSON = Data.Aeson.Types.FromJSON.withObject "SubscriptionPendingUpdate'" (\obj -> ((((GHC.Base.pure SubscriptionPendingUpdate' GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "billing_cycle_anchor")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "expires_at")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "subscription_items")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "trial_end")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "trial_from_plan"))

-- | Create a new 'SubscriptionPendingUpdate'' with all required fields.
mkSubscriptionPendingUpdate' :: SubscriptionPendingUpdate'
mkSubscriptionPendingUpdate' =
  SubscriptionPendingUpdate'
    { subscriptionPendingUpdate'BillingCycleAnchor = GHC.Maybe.Nothing,
      subscriptionPendingUpdate'ExpiresAt = GHC.Maybe.Nothing,
      subscriptionPendingUpdate'SubscriptionItems = GHC.Maybe.Nothing,
      subscriptionPendingUpdate'TrialEnd = GHC.Maybe.Nothing,
      subscriptionPendingUpdate'TrialFromPlan = GHC.Maybe.Nothing
    }

-- | Defines the oneOf schema located at @components.schemas.subscription.properties.schedule.anyOf@ in the specification.
--
-- The schedule attached to the subscription
data SubscriptionSchedule'Variants
  = SubscriptionSchedule'Text Data.Text.Internal.Text
  | SubscriptionSchedule'SubscriptionSchedule SubscriptionSchedule
  deriving (GHC.Show.Show, GHC.Classes.Eq)

instance Data.Aeson.Types.ToJSON.ToJSON SubscriptionSchedule'Variants where
  toJSON (SubscriptionSchedule'Text a) = Data.Aeson.Types.ToJSON.toJSON a
  toJSON (SubscriptionSchedule'SubscriptionSchedule a) = Data.Aeson.Types.ToJSON.toJSON a

instance Data.Aeson.Types.FromJSON.FromJSON SubscriptionSchedule'Variants where
  parseJSON val = case (SubscriptionSchedule'Text Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((SubscriptionSchedule'SubscriptionSchedule Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> Data.Aeson.Types.Internal.Error "No variant matched") of
    Data.Aeson.Types.Internal.Success a -> GHC.Base.pure a
    Data.Aeson.Types.Internal.Error a -> Control.Monad.Fail.fail a

-- | Defines the enum schema located at @components.schemas.subscription.properties.status@ in the specification.
--
-- Possible values are \`incomplete\`, \`incomplete_expired\`, \`trialing\`, \`active\`, \`past_due\`, \`canceled\`, or \`unpaid\`.
--
-- For \`collection_method=charge_automatically\` a subscription moves into \`incomplete\` if the initial payment attempt fails. A subscription in this state can only have metadata and default_source updated. Once the first invoice is paid, the subscription moves into an \`active\` state. If the first invoice is not paid within 23 hours, the subscription transitions to \`incomplete_expired\`. This is a terminal state, the open invoice will be voided and no further invoices will be generated.
--
-- A subscription that is currently in a trial period is \`trialing\` and moves to \`active\` when the trial period is over.
--
-- If subscription \`collection_method=charge_automatically\` it becomes \`past_due\` when payment to renew it fails and \`canceled\` or \`unpaid\` (depending on your subscriptions settings) when Stripe has exhausted all payment retry attempts.
--
-- If subscription \`collection_method=send_invoice\` it becomes \`past_due\` when its invoice is not paid by the due date, and \`canceled\` or \`unpaid\` if it is still not paid by an additional deadline after that. Note that when a subscription has a status of \`unpaid\`, no subsequent invoices will be attempted (invoices will be created, but then immediately automatically closed). After receiving updated payment information from a customer, you may choose to reopen and pay their closed invoices.
data SubscriptionStatus'
  = -- | This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
    SubscriptionStatus'Other Data.Aeson.Types.Internal.Value
  | -- | This constructor can be used to send values to the server which are not present in the specification yet.
    SubscriptionStatus'Typed Data.Text.Internal.Text
  | -- | Represents the JSON value @"active"@
    SubscriptionStatus'EnumActive
  | -- | Represents the JSON value @"canceled"@
    SubscriptionStatus'EnumCanceled
  | -- | Represents the JSON value @"incomplete"@
    SubscriptionStatus'EnumIncomplete
  | -- | Represents the JSON value @"incomplete_expired"@
    SubscriptionStatus'EnumIncompleteExpired
  | -- | Represents the JSON value @"past_due"@
    SubscriptionStatus'EnumPastDue
  | -- | Represents the JSON value @"trialing"@
    SubscriptionStatus'EnumTrialing
  | -- | Represents the JSON value @"unpaid"@
    SubscriptionStatus'EnumUnpaid
  deriving (GHC.Show.Show, GHC.Classes.Eq)

instance Data.Aeson.Types.ToJSON.ToJSON SubscriptionStatus' where
  toJSON (SubscriptionStatus'Other val) = val
  toJSON (SubscriptionStatus'Typed val) = Data.Aeson.Types.ToJSON.toJSON val
  toJSON (SubscriptionStatus'EnumActive) = "active"
  toJSON (SubscriptionStatus'EnumCanceled) = "canceled"
  toJSON (SubscriptionStatus'EnumIncomplete) = "incomplete"
  toJSON (SubscriptionStatus'EnumIncompleteExpired) = "incomplete_expired"
  toJSON (SubscriptionStatus'EnumPastDue) = "past_due"
  toJSON (SubscriptionStatus'EnumTrialing) = "trialing"
  toJSON (SubscriptionStatus'EnumUnpaid) = "unpaid"

instance Data.Aeson.Types.FromJSON.FromJSON SubscriptionStatus' where
  parseJSON val =
    GHC.Base.pure
      ( if
            | val GHC.Classes.== "active" -> SubscriptionStatus'EnumActive
            | val GHC.Classes.== "canceled" -> SubscriptionStatus'EnumCanceled
            | val GHC.Classes.== "incomplete" -> SubscriptionStatus'EnumIncomplete
            | val GHC.Classes.== "incomplete_expired" -> SubscriptionStatus'EnumIncompleteExpired
            | val GHC.Classes.== "past_due" -> SubscriptionStatus'EnumPastDue
            | val GHC.Classes.== "trialing" -> SubscriptionStatus'EnumTrialing
            | val GHC.Classes.== "unpaid" -> SubscriptionStatus'EnumUnpaid
            | GHC.Base.otherwise -> SubscriptionStatus'Other val
      )

-- | Defines the object schema located at @components.schemas.subscription.properties.transfer_data.anyOf@ in the specification.
--
-- The account (if any) the subscription\\\'s payments will be attributed to for tax reporting, and where funds from each payment will be transferred to for each of the subscription\\\'s invoices.
data SubscriptionTransferData' = SubscriptionTransferData'
  { -- | amount_percent: A non-negative decimal between 0 and 100, with at most two decimal places. This represents the percentage of the subscription invoice subtotal that will be transferred to the destination account. By default, the entire amount is transferred to the destination.
    subscriptionTransferData'AmountPercent :: (GHC.Maybe.Maybe GHC.Types.Double),
    -- | destination: The account where funds from the payment will be transferred to upon payment success.
    subscriptionTransferData'Destination :: (GHC.Maybe.Maybe SubscriptionTransferData'Destination'Variants)
  }
  deriving
    ( GHC.Show.Show,
      GHC.Classes.Eq
    )

instance Data.Aeson.Types.ToJSON.ToJSON SubscriptionTransferData' where
  toJSON obj = Data.Aeson.Types.Internal.object ("amount_percent" Data.Aeson.Types.ToJSON..= subscriptionTransferData'AmountPercent obj : "destination" Data.Aeson.Types.ToJSON..= subscriptionTransferData'Destination obj : GHC.Base.mempty)
  toEncoding obj = Data.Aeson.Encoding.Internal.pairs (("amount_percent" Data.Aeson.Types.ToJSON..= subscriptionTransferData'AmountPercent obj) GHC.Base.<> ("destination" Data.Aeson.Types.ToJSON..= subscriptionTransferData'Destination obj))

instance Data.Aeson.Types.FromJSON.FromJSON SubscriptionTransferData' where
  parseJSON = Data.Aeson.Types.FromJSON.withObject "SubscriptionTransferData'" (\obj -> (GHC.Base.pure SubscriptionTransferData' GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "amount_percent")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "destination"))

-- | Create a new 'SubscriptionTransferData'' with all required fields.
mkSubscriptionTransferData' :: SubscriptionTransferData'
mkSubscriptionTransferData' =
  SubscriptionTransferData'
    { subscriptionTransferData'AmountPercent = GHC.Maybe.Nothing,
      subscriptionTransferData'Destination = GHC.Maybe.Nothing
    }

-- | Defines the oneOf schema located at @components.schemas.subscription.properties.transfer_data.anyOf.properties.destination.anyOf@ in the specification.
--
-- The account where funds from the payment will be transferred to upon payment success.
data SubscriptionTransferData'Destination'Variants
  = SubscriptionTransferData'Destination'Text Data.Text.Internal.Text
  | SubscriptionTransferData'Destination'Account Account
  deriving (GHC.Show.Show, GHC.Classes.Eq)

instance Data.Aeson.Types.ToJSON.ToJSON SubscriptionTransferData'Destination'Variants where
  toJSON (SubscriptionTransferData'Destination'Text a) = Data.Aeson.Types.ToJSON.toJSON a
  toJSON (SubscriptionTransferData'Destination'Account a) = Data.Aeson.Types.ToJSON.toJSON a

instance Data.Aeson.Types.FromJSON.FromJSON SubscriptionTransferData'Destination'Variants where
  parseJSON val = case (SubscriptionTransferData'Destination'Text Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((SubscriptionTransferData'Destination'Account Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> Data.Aeson.Types.Internal.Error "No variant matched") of
    Data.Aeson.Types.Internal.Success a -> GHC.Base.pure a
    Data.Aeson.Types.Internal.Error a -> Control.Monad.Fail.fail a
