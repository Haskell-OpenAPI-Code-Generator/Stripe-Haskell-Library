{-# LANGUAGE MultiWayIf #-}
-- CHANGE WITH CAUTION: This is a generated code file generated by https://github.com/Haskell-OpenAPI-Code-Generator/Haskell-OpenAPI-Client-Code-Generator.
{-# LANGUAGE OverloadedStrings #-}

-- | Contains the types generated from the schema Tax_Calculation
module StripeAPI.Types.Tax_Calculation where

import qualified Control.Monad.Fail
import qualified Data.Aeson
import qualified Data.Aeson as Data.Aeson.Encoding.Internal
import qualified Data.Aeson as Data.Aeson.Types
import qualified Data.Aeson as Data.Aeson.Types.FromJSON
import qualified Data.Aeson as Data.Aeson.Types.Internal
import qualified Data.Aeson as Data.Aeson.Types.ToJSON
import qualified Data.ByteString
import qualified Data.ByteString as Data.ByteString.Internal
import qualified Data.Foldable
import qualified Data.Functor
import qualified Data.Maybe
import qualified Data.Scientific
import qualified Data.Text
import qualified Data.Text as Data.Text.Internal
import qualified Data.Time.Calendar as Data.Time.Calendar.Days
import qualified Data.Time.LocalTime as Data.Time.LocalTime.Internal.ZonedTime
import qualified GHC.Base
import qualified GHC.Classes
import qualified GHC.Int
import qualified GHC.Show
import qualified GHC.Types
import qualified StripeAPI.Common
import StripeAPI.TypeAlias
import {-# SOURCE #-} StripeAPI.Types.TaxProductResourceCustomerDetails
import {-# SOURCE #-} StripeAPI.Types.TaxProductResourceLineItemTaxBreakdown
import {-# SOURCE #-} StripeAPI.Types.TaxProductResourceTaxBreakdown
import {-# SOURCE #-} StripeAPI.Types.TaxProductResourceTaxCalculationShippingCost
import {-# SOURCE #-} StripeAPI.Types.Tax_CalculationLineItem
import qualified Prelude as GHC.Integer.Type
import qualified Prelude as GHC.Maybe

-- | Defines the object schema located at @components.schemas.tax.calculation@ in the specification.
--
-- A Tax Calculation allows you to calculate the tax to collect from your customer.
--
-- Related guide: [Calculate tax in your custom payment flow](https:\/\/stripe.com\/docs\/tax\/custom)
data Tax'calculation = Tax'calculation
  { -- | amount_total: Total after taxes.
    tax'calculationAmountTotal :: GHC.Types.Int,
    -- | currency: Three-letter [ISO currency code](https:\/\/www.iso.org\/iso-4217-currency-codes.html), in lowercase. Must be a [supported currency](https:\/\/stripe.com\/docs\/currencies).
    --
    -- Constraints:
    --
    -- * Maximum length of 5000
    tax'calculationCurrency :: Data.Text.Internal.Text,
    -- | customer: The ID of an existing [Customer](https:\/\/stripe.com\/docs\/api\/customers\/object) used for the resource.
    --
    -- Constraints:
    --
    -- * Maximum length of 5000
    tax'calculationCustomer :: (GHC.Maybe.Maybe (StripeAPI.Common.Nullable Data.Text.Internal.Text)),
    -- | customer_details:
    tax'calculationCustomerDetails :: TaxProductResourceCustomerDetails,
    -- | expires_at: Timestamp of date at which the tax calculation will expire.
    tax'calculationExpiresAt :: (GHC.Maybe.Maybe (StripeAPI.Common.Nullable GHC.Types.Int)),
    -- | id: Unique identifier for the calculation.
    --
    -- Constraints:
    --
    -- * Maximum length of 5000
    tax'calculationId :: (GHC.Maybe.Maybe (StripeAPI.Common.Nullable Data.Text.Internal.Text)),
    -- | line_items: The list of items the customer is purchasing.
    tax'calculationLineItems :: (GHC.Maybe.Maybe (StripeAPI.Common.Nullable Tax'calculationLineItems'NonNullable)),
    -- | livemode: Has the value \`true\` if the object exists in live mode or the value \`false\` if the object exists in test mode.
    tax'calculationLivemode :: GHC.Types.Bool,
    -- | shipping_cost: The shipping cost details for the calculation.
    tax'calculationShippingCost :: (GHC.Maybe.Maybe (StripeAPI.Common.Nullable Tax'calculationShippingCost'NonNullable)),
    -- | tax_amount_exclusive: The amount of tax to be collected on top of the line item prices.
    tax'calculationTaxAmountExclusive :: GHC.Types.Int,
    -- | tax_amount_inclusive: The amount of tax already included in the line item prices.
    tax'calculationTaxAmountInclusive :: GHC.Types.Int,
    -- | tax_breakdown: Breakdown of individual tax amounts that add up to the total.
    tax'calculationTaxBreakdown :: ([TaxProductResourceTaxBreakdown]),
    -- | tax_date: Timestamp of date at which the tax rules and rates in effect applies for the calculation.
    tax'calculationTaxDate :: GHC.Types.Int
  }
  deriving
    ( GHC.Show.Show,
      GHC.Classes.Eq
    )

instance Data.Aeson.Types.ToJSON.ToJSON Tax'calculation where
  toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["amount_total" Data.Aeson.Types.ToJSON..= tax'calculationAmountTotal obj] : ["currency" Data.Aeson.Types.ToJSON..= tax'calculationCurrency obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("customer" Data.Aeson.Types.ToJSON..=)) (tax'calculationCustomer obj) : ["customer_details" Data.Aeson.Types.ToJSON..= tax'calculationCustomerDetails obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("expires_at" Data.Aeson.Types.ToJSON..=)) (tax'calculationExpiresAt obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("id" Data.Aeson.Types.ToJSON..=)) (tax'calculationId obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("line_items" Data.Aeson.Types.ToJSON..=)) (tax'calculationLineItems obj) : ["livemode" Data.Aeson.Types.ToJSON..= tax'calculationLivemode obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("shipping_cost" Data.Aeson.Types.ToJSON..=)) (tax'calculationShippingCost obj) : ["tax_amount_exclusive" Data.Aeson.Types.ToJSON..= tax'calculationTaxAmountExclusive obj] : ["tax_amount_inclusive" Data.Aeson.Types.ToJSON..= tax'calculationTaxAmountInclusive obj] : ["tax_breakdown" Data.Aeson.Types.ToJSON..= tax'calculationTaxBreakdown obj] : ["tax_date" Data.Aeson.Types.ToJSON..= tax'calculationTaxDate obj] : ["object" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "tax.calculation"] : GHC.Base.mempty))
  toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["amount_total" Data.Aeson.Types.ToJSON..= tax'calculationAmountTotal obj] : ["currency" Data.Aeson.Types.ToJSON..= tax'calculationCurrency obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("customer" Data.Aeson.Types.ToJSON..=)) (tax'calculationCustomer obj) : ["customer_details" Data.Aeson.Types.ToJSON..= tax'calculationCustomerDetails obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("expires_at" Data.Aeson.Types.ToJSON..=)) (tax'calculationExpiresAt obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("id" Data.Aeson.Types.ToJSON..=)) (tax'calculationId obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("line_items" Data.Aeson.Types.ToJSON..=)) (tax'calculationLineItems obj) : ["livemode" Data.Aeson.Types.ToJSON..= tax'calculationLivemode obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("shipping_cost" Data.Aeson.Types.ToJSON..=)) (tax'calculationShippingCost obj) : ["tax_amount_exclusive" Data.Aeson.Types.ToJSON..= tax'calculationTaxAmountExclusive obj] : ["tax_amount_inclusive" Data.Aeson.Types.ToJSON..= tax'calculationTaxAmountInclusive obj] : ["tax_breakdown" Data.Aeson.Types.ToJSON..= tax'calculationTaxBreakdown obj] : ["tax_date" Data.Aeson.Types.ToJSON..= tax'calculationTaxDate obj] : ["object" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "tax.calculation"] : GHC.Base.mempty)))

instance Data.Aeson.Types.FromJSON.FromJSON Tax'calculation where
  parseJSON = Data.Aeson.Types.FromJSON.withObject "Tax'calculation" (\obj -> ((((((((((((GHC.Base.pure Tax'calculation GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "amount_total")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "currency")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "customer")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "customer_details")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "expires_at")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "line_items")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "livemode")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "shipping_cost")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "tax_amount_exclusive")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "tax_amount_inclusive")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "tax_breakdown")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "tax_date"))

-- | Create a new 'Tax'calculation' with all required fields.
mkTax'calculation ::
  -- | 'tax'calculationAmountTotal'
  GHC.Types.Int ->
  -- | 'tax'calculationCurrency'
  Data.Text.Internal.Text ->
  -- | 'tax'calculationCustomerDetails'
  TaxProductResourceCustomerDetails ->
  -- | 'tax'calculationLivemode'
  GHC.Types.Bool ->
  -- | 'tax'calculationTaxAmountExclusive'
  GHC.Types.Int ->
  -- | 'tax'calculationTaxAmountInclusive'
  GHC.Types.Int ->
  -- | 'tax'calculationTaxBreakdown'
  [TaxProductResourceTaxBreakdown] ->
  -- | 'tax'calculationTaxDate'
  GHC.Types.Int ->
  Tax'calculation
mkTax'calculation tax'calculationAmountTotal tax'calculationCurrency tax'calculationCustomerDetails tax'calculationLivemode tax'calculationTaxAmountExclusive tax'calculationTaxAmountInclusive tax'calculationTaxBreakdown tax'calculationTaxDate =
  Tax'calculation
    { tax'calculationAmountTotal = tax'calculationAmountTotal,
      tax'calculationCurrency = tax'calculationCurrency,
      tax'calculationCustomer = GHC.Maybe.Nothing,
      tax'calculationCustomerDetails = tax'calculationCustomerDetails,
      tax'calculationExpiresAt = GHC.Maybe.Nothing,
      tax'calculationId = GHC.Maybe.Nothing,
      tax'calculationLineItems = GHC.Maybe.Nothing,
      tax'calculationLivemode = tax'calculationLivemode,
      tax'calculationShippingCost = GHC.Maybe.Nothing,
      tax'calculationTaxAmountExclusive = tax'calculationTaxAmountExclusive,
      tax'calculationTaxAmountInclusive = tax'calculationTaxAmountInclusive,
      tax'calculationTaxBreakdown = tax'calculationTaxBreakdown,
      tax'calculationTaxDate = tax'calculationTaxDate
    }

-- | Defines the object schema located at @components.schemas.tax.calculation.properties.line_items@ in the specification.
--
-- The list of items the customer is purchasing.
data Tax'calculationLineItems'NonNullable = Tax'calculationLineItems'NonNullable
  { -- | data: Details about each object.
    tax'calculationLineItems'NonNullableData :: ([Tax'calculationLineItem]),
    -- | has_more: True if this list has another page of items after this one that can be fetched.
    tax'calculationLineItems'NonNullableHasMore :: GHC.Types.Bool,
    -- | url: The URL where this list can be accessed.
    --
    -- Constraints:
    --
    -- * Maximum length of 5000
    -- * Must match pattern \'^\/v1\/tax\/calculations\/[^\/]+\/line_items\'
    tax'calculationLineItems'NonNullableUrl :: Data.Text.Internal.Text
  }
  deriving
    ( GHC.Show.Show,
      GHC.Classes.Eq
    )

instance Data.Aeson.Types.ToJSON.ToJSON Tax'calculationLineItems'NonNullable where
  toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["data" Data.Aeson.Types.ToJSON..= tax'calculationLineItems'NonNullableData obj] : ["has_more" Data.Aeson.Types.ToJSON..= tax'calculationLineItems'NonNullableHasMore obj] : ["url" Data.Aeson.Types.ToJSON..= tax'calculationLineItems'NonNullableUrl obj] : ["object" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "list"] : GHC.Base.mempty))
  toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["data" Data.Aeson.Types.ToJSON..= tax'calculationLineItems'NonNullableData obj] : ["has_more" Data.Aeson.Types.ToJSON..= tax'calculationLineItems'NonNullableHasMore obj] : ["url" Data.Aeson.Types.ToJSON..= tax'calculationLineItems'NonNullableUrl obj] : ["object" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "list"] : GHC.Base.mempty)))

instance Data.Aeson.Types.FromJSON.FromJSON Tax'calculationLineItems'NonNullable where
  parseJSON = Data.Aeson.Types.FromJSON.withObject "Tax'calculationLineItems'NonNullable" (\obj -> ((GHC.Base.pure Tax'calculationLineItems'NonNullable GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "data")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "has_more")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "url"))

-- | Create a new 'Tax'calculationLineItems'NonNullable' with all required fields.
mkTax'calculationLineItems'NonNullable ::
  -- | 'tax'calculationLineItems'NonNullableData'
  [Tax'calculationLineItem] ->
  -- | 'tax'calculationLineItems'NonNullableHasMore'
  GHC.Types.Bool ->
  -- | 'tax'calculationLineItems'NonNullableUrl'
  Data.Text.Internal.Text ->
  Tax'calculationLineItems'NonNullable
mkTax'calculationLineItems'NonNullable tax'calculationLineItems'NonNullableData tax'calculationLineItems'NonNullableHasMore tax'calculationLineItems'NonNullableUrl =
  Tax'calculationLineItems'NonNullable
    { tax'calculationLineItems'NonNullableData = tax'calculationLineItems'NonNullableData,
      tax'calculationLineItems'NonNullableHasMore = tax'calculationLineItems'NonNullableHasMore,
      tax'calculationLineItems'NonNullableUrl = tax'calculationLineItems'NonNullableUrl
    }

-- | Defines the object schema located at @components.schemas.tax.calculation.properties.shipping_cost.anyOf@ in the specification.
--
-- The shipping cost details for the calculation.
data Tax'calculationShippingCost'NonNullable = Tax'calculationShippingCost'NonNullable
  { -- | amount: The shipping amount in integer cents. If \`tax_behavior=inclusive\`, then this amount includes taxes. Otherwise, taxes were calculated on top of this amount.
    tax'calculationShippingCost'NonNullableAmount :: (GHC.Maybe.Maybe GHC.Types.Int),
    -- | amount_tax: The amount of tax calculated for shipping, in integer cents.
    tax'calculationShippingCost'NonNullableAmountTax :: (GHC.Maybe.Maybe GHC.Types.Int),
    -- | shipping_rate: The ID of an existing [ShippingRate](https:\/\/stripe.com\/docs\/api\/shipping_rates\/object).
    --
    -- Constraints:
    --
    -- * Maximum length of 5000
    tax'calculationShippingCost'NonNullableShippingRate :: (GHC.Maybe.Maybe Data.Text.Internal.Text),
    -- | tax_behavior: Specifies whether the \`amount\` includes taxes. If \`tax_behavior=inclusive\`, then the amount includes taxes.
    tax'calculationShippingCost'NonNullableTaxBehavior :: (GHC.Maybe.Maybe Tax'calculationShippingCost'NonNullableTaxBehavior'),
    -- | tax_breakdown: Detailed account of taxes relevant to shipping cost.
    tax'calculationShippingCost'NonNullableTaxBreakdown :: (GHC.Maybe.Maybe ([TaxProductResourceLineItemTaxBreakdown])),
    -- | tax_code: The [tax code](https:\/\/stripe.com\/docs\/tax\/tax-categories) ID used for shipping.
    --
    -- Constraints:
    --
    -- * Maximum length of 5000
    tax'calculationShippingCost'NonNullableTaxCode :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  }
  deriving
    ( GHC.Show.Show,
      GHC.Classes.Eq
    )

instance Data.Aeson.Types.ToJSON.ToJSON Tax'calculationShippingCost'NonNullable where
  toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("amount" Data.Aeson.Types.ToJSON..=)) (tax'calculationShippingCost'NonNullableAmount obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("amount_tax" Data.Aeson.Types.ToJSON..=)) (tax'calculationShippingCost'NonNullableAmountTax obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("shipping_rate" Data.Aeson.Types.ToJSON..=)) (tax'calculationShippingCost'NonNullableShippingRate obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("tax_behavior" Data.Aeson.Types.ToJSON..=)) (tax'calculationShippingCost'NonNullableTaxBehavior obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("tax_breakdown" Data.Aeson.Types.ToJSON..=)) (tax'calculationShippingCost'NonNullableTaxBreakdown obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("tax_code" Data.Aeson.Types.ToJSON..=)) (tax'calculationShippingCost'NonNullableTaxCode obj) : GHC.Base.mempty))
  toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("amount" Data.Aeson.Types.ToJSON..=)) (tax'calculationShippingCost'NonNullableAmount obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("amount_tax" Data.Aeson.Types.ToJSON..=)) (tax'calculationShippingCost'NonNullableAmountTax obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("shipping_rate" Data.Aeson.Types.ToJSON..=)) (tax'calculationShippingCost'NonNullableShippingRate obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("tax_behavior" Data.Aeson.Types.ToJSON..=)) (tax'calculationShippingCost'NonNullableTaxBehavior obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("tax_breakdown" Data.Aeson.Types.ToJSON..=)) (tax'calculationShippingCost'NonNullableTaxBreakdown obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("tax_code" Data.Aeson.Types.ToJSON..=)) (tax'calculationShippingCost'NonNullableTaxCode obj) : GHC.Base.mempty)))

instance Data.Aeson.Types.FromJSON.FromJSON Tax'calculationShippingCost'NonNullable where
  parseJSON = Data.Aeson.Types.FromJSON.withObject "Tax'calculationShippingCost'NonNullable" (\obj -> (((((GHC.Base.pure Tax'calculationShippingCost'NonNullable GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "amount")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "amount_tax")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "shipping_rate")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "tax_behavior")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "tax_breakdown")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "tax_code"))

-- | Create a new 'Tax'calculationShippingCost'NonNullable' with all required fields.
mkTax'calculationShippingCost'NonNullable :: Tax'calculationShippingCost'NonNullable
mkTax'calculationShippingCost'NonNullable =
  Tax'calculationShippingCost'NonNullable
    { tax'calculationShippingCost'NonNullableAmount = GHC.Maybe.Nothing,
      tax'calculationShippingCost'NonNullableAmountTax = GHC.Maybe.Nothing,
      tax'calculationShippingCost'NonNullableShippingRate = GHC.Maybe.Nothing,
      tax'calculationShippingCost'NonNullableTaxBehavior = GHC.Maybe.Nothing,
      tax'calculationShippingCost'NonNullableTaxBreakdown = GHC.Maybe.Nothing,
      tax'calculationShippingCost'NonNullableTaxCode = GHC.Maybe.Nothing
    }

-- | Defines the enum schema located at @components.schemas.tax.calculation.properties.shipping_cost.anyOf.properties.tax_behavior@ in the specification.
--
-- Specifies whether the \`amount\` includes taxes. If \`tax_behavior=inclusive\`, then the amount includes taxes.
data Tax'calculationShippingCost'NonNullableTaxBehavior'
  = -- | This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
    Tax'calculationShippingCost'NonNullableTaxBehavior'Other Data.Aeson.Types.Internal.Value
  | -- | This constructor can be used to send values to the server which are not present in the specification yet.
    Tax'calculationShippingCost'NonNullableTaxBehavior'Typed Data.Text.Internal.Text
  | -- | Represents the JSON value @"exclusive"@
    Tax'calculationShippingCost'NonNullableTaxBehavior'EnumExclusive
  | -- | Represents the JSON value @"inclusive"@
    Tax'calculationShippingCost'NonNullableTaxBehavior'EnumInclusive
  deriving (GHC.Show.Show, GHC.Classes.Eq)

instance Data.Aeson.Types.ToJSON.ToJSON Tax'calculationShippingCost'NonNullableTaxBehavior' where
  toJSON (Tax'calculationShippingCost'NonNullableTaxBehavior'Other val) = val
  toJSON (Tax'calculationShippingCost'NonNullableTaxBehavior'Typed val) = Data.Aeson.Types.ToJSON.toJSON val
  toJSON (Tax'calculationShippingCost'NonNullableTaxBehavior'EnumExclusive) = "exclusive"
  toJSON (Tax'calculationShippingCost'NonNullableTaxBehavior'EnumInclusive) = "inclusive"

instance Data.Aeson.Types.FromJSON.FromJSON Tax'calculationShippingCost'NonNullableTaxBehavior' where
  parseJSON val =
    GHC.Base.pure
      ( if
            | val GHC.Classes.== "exclusive" -> Tax'calculationShippingCost'NonNullableTaxBehavior'EnumExclusive
            | val GHC.Classes.== "inclusive" -> Tax'calculationShippingCost'NonNullableTaxBehavior'EnumInclusive
            | GHC.Base.otherwise -> Tax'calculationShippingCost'NonNullableTaxBehavior'Other val
      )
