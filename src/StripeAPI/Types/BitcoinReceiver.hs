{-# LANGUAGE MultiWayIf #-}
-- CHANGE WITH CAUTION: This is a generated code file generated by https://github.com/Haskell-OpenAPI-Code-Generator/Haskell-OpenAPI-Client-Code-Generator.
{-# LANGUAGE OverloadedStrings #-}

-- | Contains the types generated from the schema BitcoinReceiver
module StripeAPI.Types.BitcoinReceiver where

import qualified Control.Monad.Fail
import qualified Data.Aeson
import qualified Data.Aeson as Data.Aeson.Encoding.Internal
import qualified Data.Aeson as Data.Aeson.Types
import qualified Data.Aeson as Data.Aeson.Types.FromJSON
import qualified Data.Aeson as Data.Aeson.Types.Internal
import qualified Data.Aeson as Data.Aeson.Types.ToJSON
import qualified Data.ByteString.Char8
import qualified Data.ByteString.Char8 as Data.ByteString.Internal
import qualified Data.Foldable
import qualified Data.Functor
import qualified Data.Maybe
import qualified Data.Scientific
import qualified Data.Text
import qualified Data.Text.Internal
import qualified Data.Time.Calendar as Data.Time.Calendar.Days
import qualified Data.Time.LocalTime as Data.Time.LocalTime.Internal.ZonedTime
import qualified GHC.Base
import qualified GHC.Classes
import qualified GHC.Int
import qualified GHC.Show
import qualified GHC.Types
import qualified StripeAPI.Common
import StripeAPI.TypeAlias
import {-# SOURCE #-} StripeAPI.Types.BitcoinTransaction
import qualified Prelude as GHC.Integer.Type
import qualified Prelude as GHC.Maybe

-- | Defines the object schema located at @components.schemas.bitcoin_receiver@ in the specification.
data BitcoinReceiver = BitcoinReceiver
  { -- | active: True when this bitcoin receiver has received a non-zero amount of bitcoin.
    bitcoinReceiverActive :: GHC.Types.Bool,
    -- | amount: The amount of \`currency\` that you are collecting as payment.
    bitcoinReceiverAmount :: GHC.Types.Int,
    -- | amount_received: The amount of \`currency\` to which \`bitcoin_amount_received\` has been converted.
    bitcoinReceiverAmountReceived :: GHC.Types.Int,
    -- | bitcoin_amount: The amount of bitcoin that the customer should send to fill the receiver. The \`bitcoin_amount\` is denominated in Satoshi: there are 10^8 Satoshi in one bitcoin.
    bitcoinReceiverBitcoinAmount :: GHC.Types.Int,
    -- | bitcoin_amount_received: The amount of bitcoin that has been sent by the customer to this receiver.
    bitcoinReceiverBitcoinAmountReceived :: GHC.Types.Int,
    -- | bitcoin_uri: This URI can be displayed to the customer as a clickable link (to activate their bitcoin client) or as a QR code (for mobile wallets).
    --
    -- Constraints:
    --
    -- * Maximum length of 5000
    bitcoinReceiverBitcoinUri :: Data.Text.Internal.Text,
    -- | created: Time at which the object was created. Measured in seconds since the Unix epoch.
    bitcoinReceiverCreated :: GHC.Types.Int,
    -- | currency: Three-letter [ISO code for the currency](https:\/\/stripe.com\/docs\/currencies) to which the bitcoin will be converted.
    bitcoinReceiverCurrency :: Data.Text.Internal.Text,
    -- | customer: The customer ID of the bitcoin receiver.
    --
    -- Constraints:
    --
    -- * Maximum length of 5000
    bitcoinReceiverCustomer :: (GHC.Maybe.Maybe (StripeAPI.Common.Nullable Data.Text.Internal.Text)),
    -- | description: An arbitrary string attached to the object. Often useful for displaying to users.
    --
    -- Constraints:
    --
    -- * Maximum length of 5000
    bitcoinReceiverDescription :: (GHC.Maybe.Maybe (StripeAPI.Common.Nullable Data.Text.Internal.Text)),
    -- | email: The customer\'s email address, set by the API call that creates the receiver.
    --
    -- Constraints:
    --
    -- * Maximum length of 5000
    bitcoinReceiverEmail :: (GHC.Maybe.Maybe (StripeAPI.Common.Nullable Data.Text.Internal.Text)),
    -- | filled: This flag is initially false and updates to true when the customer sends the \`bitcoin_amount\` to this receiver.
    bitcoinReceiverFilled :: GHC.Types.Bool,
    -- | id: Unique identifier for the object.
    --
    -- Constraints:
    --
    -- * Maximum length of 5000
    bitcoinReceiverId :: Data.Text.Internal.Text,
    -- | inbound_address: A bitcoin address that is specific to this receiver. The customer can send bitcoin to this address to fill the receiver.
    --
    -- Constraints:
    --
    -- * Maximum length of 5000
    bitcoinReceiverInboundAddress :: Data.Text.Internal.Text,
    -- | livemode: Has the value \`true\` if the object exists in live mode or the value \`false\` if the object exists in test mode.
    bitcoinReceiverLivemode :: GHC.Types.Bool,
    -- | metadata: Set of [key-value pairs](https:\/\/stripe.com\/docs\/api\/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format.
    bitcoinReceiverMetadata :: (GHC.Maybe.Maybe (StripeAPI.Common.Nullable Data.Aeson.Types.Internal.Object)),
    -- | payment: The ID of the payment created from the receiver, if any. Hidden when viewing the receiver with a publishable key.
    --
    -- Constraints:
    --
    -- * Maximum length of 5000
    bitcoinReceiverPayment :: (GHC.Maybe.Maybe (StripeAPI.Common.Nullable Data.Text.Internal.Text)),
    -- | refund_address: The refund address of this bitcoin receiver.
    --
    -- Constraints:
    --
    -- * Maximum length of 5000
    bitcoinReceiverRefundAddress :: (GHC.Maybe.Maybe (StripeAPI.Common.Nullable Data.Text.Internal.Text)),
    -- | transactions: A list with one entry for each time that the customer sent bitcoin to the receiver. Hidden when viewing the receiver with a publishable key.
    bitcoinReceiverTransactions :: (GHC.Maybe.Maybe BitcoinReceiverTransactions'),
    -- | uncaptured_funds: This receiver contains uncaptured funds that can be used for a payment or refunded.
    bitcoinReceiverUncapturedFunds :: GHC.Types.Bool,
    -- | used_for_payment: Indicate if this source is used for payment.
    bitcoinReceiverUsedForPayment :: (GHC.Maybe.Maybe (StripeAPI.Common.Nullable GHC.Types.Bool))
  }
  deriving
    ( GHC.Show.Show,
      GHC.Classes.Eq
    )

instance Data.Aeson.Types.ToJSON.ToJSON BitcoinReceiver where
  toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["active" Data.Aeson.Types.ToJSON..= bitcoinReceiverActive obj] : ["amount" Data.Aeson.Types.ToJSON..= bitcoinReceiverAmount obj] : ["amount_received" Data.Aeson.Types.ToJSON..= bitcoinReceiverAmountReceived obj] : ["bitcoin_amount" Data.Aeson.Types.ToJSON..= bitcoinReceiverBitcoinAmount obj] : ["bitcoin_amount_received" Data.Aeson.Types.ToJSON..= bitcoinReceiverBitcoinAmountReceived obj] : ["bitcoin_uri" Data.Aeson.Types.ToJSON..= bitcoinReceiverBitcoinUri obj] : ["created" Data.Aeson.Types.ToJSON..= bitcoinReceiverCreated obj] : ["currency" Data.Aeson.Types.ToJSON..= bitcoinReceiverCurrency obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("customer" Data.Aeson.Types.ToJSON..=)) (bitcoinReceiverCustomer obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("description" Data.Aeson.Types.ToJSON..=)) (bitcoinReceiverDescription obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("email" Data.Aeson.Types.ToJSON..=)) (bitcoinReceiverEmail obj) : ["filled" Data.Aeson.Types.ToJSON..= bitcoinReceiverFilled obj] : ["id" Data.Aeson.Types.ToJSON..= bitcoinReceiverId obj] : ["inbound_address" Data.Aeson.Types.ToJSON..= bitcoinReceiverInboundAddress obj] : ["livemode" Data.Aeson.Types.ToJSON..= bitcoinReceiverLivemode obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("metadata" Data.Aeson.Types.ToJSON..=)) (bitcoinReceiverMetadata obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("payment" Data.Aeson.Types.ToJSON..=)) (bitcoinReceiverPayment obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("refund_address" Data.Aeson.Types.ToJSON..=)) (bitcoinReceiverRefundAddress obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("transactions" Data.Aeson.Types.ToJSON..=)) (bitcoinReceiverTransactions obj) : ["uncaptured_funds" Data.Aeson.Types.ToJSON..= bitcoinReceiverUncapturedFunds obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("used_for_payment" Data.Aeson.Types.ToJSON..=)) (bitcoinReceiverUsedForPayment obj) : ["object" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "bitcoin_receiver"] : GHC.Base.mempty))
  toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["active" Data.Aeson.Types.ToJSON..= bitcoinReceiverActive obj] : ["amount" Data.Aeson.Types.ToJSON..= bitcoinReceiverAmount obj] : ["amount_received" Data.Aeson.Types.ToJSON..= bitcoinReceiverAmountReceived obj] : ["bitcoin_amount" Data.Aeson.Types.ToJSON..= bitcoinReceiverBitcoinAmount obj] : ["bitcoin_amount_received" Data.Aeson.Types.ToJSON..= bitcoinReceiverBitcoinAmountReceived obj] : ["bitcoin_uri" Data.Aeson.Types.ToJSON..= bitcoinReceiverBitcoinUri obj] : ["created" Data.Aeson.Types.ToJSON..= bitcoinReceiverCreated obj] : ["currency" Data.Aeson.Types.ToJSON..= bitcoinReceiverCurrency obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("customer" Data.Aeson.Types.ToJSON..=)) (bitcoinReceiverCustomer obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("description" Data.Aeson.Types.ToJSON..=)) (bitcoinReceiverDescription obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("email" Data.Aeson.Types.ToJSON..=)) (bitcoinReceiverEmail obj) : ["filled" Data.Aeson.Types.ToJSON..= bitcoinReceiverFilled obj] : ["id" Data.Aeson.Types.ToJSON..= bitcoinReceiverId obj] : ["inbound_address" Data.Aeson.Types.ToJSON..= bitcoinReceiverInboundAddress obj] : ["livemode" Data.Aeson.Types.ToJSON..= bitcoinReceiverLivemode obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("metadata" Data.Aeson.Types.ToJSON..=)) (bitcoinReceiverMetadata obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("payment" Data.Aeson.Types.ToJSON..=)) (bitcoinReceiverPayment obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("refund_address" Data.Aeson.Types.ToJSON..=)) (bitcoinReceiverRefundAddress obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("transactions" Data.Aeson.Types.ToJSON..=)) (bitcoinReceiverTransactions obj) : ["uncaptured_funds" Data.Aeson.Types.ToJSON..= bitcoinReceiverUncapturedFunds obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("used_for_payment" Data.Aeson.Types.ToJSON..=)) (bitcoinReceiverUsedForPayment obj) : ["object" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "bitcoin_receiver"] : GHC.Base.mempty)))

instance Data.Aeson.Types.FromJSON.FromJSON BitcoinReceiver where
  parseJSON = Data.Aeson.Types.FromJSON.withObject "BitcoinReceiver" (\obj -> ((((((((((((((((((((GHC.Base.pure BitcoinReceiver GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "active")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "amount")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "amount_received")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "bitcoin_amount")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "bitcoin_amount_received")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "bitcoin_uri")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "created")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "currency")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "customer")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "description")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "email")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "filled")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "inbound_address")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "livemode")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "metadata")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "payment")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "refund_address")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "transactions")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "uncaptured_funds")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "used_for_payment"))

-- | Create a new 'BitcoinReceiver' with all required fields.
mkBitcoinReceiver ::
  -- | 'bitcoinReceiverActive'
  GHC.Types.Bool ->
  -- | 'bitcoinReceiverAmount'
  GHC.Types.Int ->
  -- | 'bitcoinReceiverAmountReceived'
  GHC.Types.Int ->
  -- | 'bitcoinReceiverBitcoinAmount'
  GHC.Types.Int ->
  -- | 'bitcoinReceiverBitcoinAmountReceived'
  GHC.Types.Int ->
  -- | 'bitcoinReceiverBitcoinUri'
  Data.Text.Internal.Text ->
  -- | 'bitcoinReceiverCreated'
  GHC.Types.Int ->
  -- | 'bitcoinReceiverCurrency'
  Data.Text.Internal.Text ->
  -- | 'bitcoinReceiverFilled'
  GHC.Types.Bool ->
  -- | 'bitcoinReceiverId'
  Data.Text.Internal.Text ->
  -- | 'bitcoinReceiverInboundAddress'
  Data.Text.Internal.Text ->
  -- | 'bitcoinReceiverLivemode'
  GHC.Types.Bool ->
  -- | 'bitcoinReceiverUncapturedFunds'
  GHC.Types.Bool ->
  BitcoinReceiver
mkBitcoinReceiver bitcoinReceiverActive bitcoinReceiverAmount bitcoinReceiverAmountReceived bitcoinReceiverBitcoinAmount bitcoinReceiverBitcoinAmountReceived bitcoinReceiverBitcoinUri bitcoinReceiverCreated bitcoinReceiverCurrency bitcoinReceiverFilled bitcoinReceiverId bitcoinReceiverInboundAddress bitcoinReceiverLivemode bitcoinReceiverUncapturedFunds =
  BitcoinReceiver
    { bitcoinReceiverActive = bitcoinReceiverActive,
      bitcoinReceiverAmount = bitcoinReceiverAmount,
      bitcoinReceiverAmountReceived = bitcoinReceiverAmountReceived,
      bitcoinReceiverBitcoinAmount = bitcoinReceiverBitcoinAmount,
      bitcoinReceiverBitcoinAmountReceived = bitcoinReceiverBitcoinAmountReceived,
      bitcoinReceiverBitcoinUri = bitcoinReceiverBitcoinUri,
      bitcoinReceiverCreated = bitcoinReceiverCreated,
      bitcoinReceiverCurrency = bitcoinReceiverCurrency,
      bitcoinReceiverCustomer = GHC.Maybe.Nothing,
      bitcoinReceiverDescription = GHC.Maybe.Nothing,
      bitcoinReceiverEmail = GHC.Maybe.Nothing,
      bitcoinReceiverFilled = bitcoinReceiverFilled,
      bitcoinReceiverId = bitcoinReceiverId,
      bitcoinReceiverInboundAddress = bitcoinReceiverInboundAddress,
      bitcoinReceiverLivemode = bitcoinReceiverLivemode,
      bitcoinReceiverMetadata = GHC.Maybe.Nothing,
      bitcoinReceiverPayment = GHC.Maybe.Nothing,
      bitcoinReceiverRefundAddress = GHC.Maybe.Nothing,
      bitcoinReceiverTransactions = GHC.Maybe.Nothing,
      bitcoinReceiverUncapturedFunds = bitcoinReceiverUncapturedFunds,
      bitcoinReceiverUsedForPayment = GHC.Maybe.Nothing
    }

-- | Defines the object schema located at @components.schemas.bitcoin_receiver.properties.transactions@ in the specification.
--
-- A list with one entry for each time that the customer sent bitcoin to the receiver. Hidden when viewing the receiver with a publishable key.
data BitcoinReceiverTransactions' = BitcoinReceiverTransactions'
  { -- | data: Details about each object.
    bitcoinReceiverTransactions'Data :: ([BitcoinTransaction]),
    -- | has_more: True if this list has another page of items after this one that can be fetched.
    bitcoinReceiverTransactions'HasMore :: GHC.Types.Bool,
    -- | url: The URL where this list can be accessed.
    --
    -- Constraints:
    --
    -- * Maximum length of 5000
    bitcoinReceiverTransactions'Url :: Data.Text.Internal.Text
  }
  deriving
    ( GHC.Show.Show,
      GHC.Classes.Eq
    )

instance Data.Aeson.Types.ToJSON.ToJSON BitcoinReceiverTransactions' where
  toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["data" Data.Aeson.Types.ToJSON..= bitcoinReceiverTransactions'Data obj] : ["has_more" Data.Aeson.Types.ToJSON..= bitcoinReceiverTransactions'HasMore obj] : ["url" Data.Aeson.Types.ToJSON..= bitcoinReceiverTransactions'Url obj] : ["object" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "list"] : GHC.Base.mempty))
  toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["data" Data.Aeson.Types.ToJSON..= bitcoinReceiverTransactions'Data obj] : ["has_more" Data.Aeson.Types.ToJSON..= bitcoinReceiverTransactions'HasMore obj] : ["url" Data.Aeson.Types.ToJSON..= bitcoinReceiverTransactions'Url obj] : ["object" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "list"] : GHC.Base.mempty)))

instance Data.Aeson.Types.FromJSON.FromJSON BitcoinReceiverTransactions' where
  parseJSON = Data.Aeson.Types.FromJSON.withObject "BitcoinReceiverTransactions'" (\obj -> ((GHC.Base.pure BitcoinReceiverTransactions' GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "data")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "has_more")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "url"))

-- | Create a new 'BitcoinReceiverTransactions'' with all required fields.
mkBitcoinReceiverTransactions' ::
  -- | 'bitcoinReceiverTransactions'Data'
  [BitcoinTransaction] ->
  -- | 'bitcoinReceiverTransactions'HasMore'
  GHC.Types.Bool ->
  -- | 'bitcoinReceiverTransactions'Url'
  Data.Text.Internal.Text ->
  BitcoinReceiverTransactions'
mkBitcoinReceiverTransactions' bitcoinReceiverTransactions'Data bitcoinReceiverTransactions'HasMore bitcoinReceiverTransactions'Url =
  BitcoinReceiverTransactions'
    { bitcoinReceiverTransactions'Data = bitcoinReceiverTransactions'Data,
      bitcoinReceiverTransactions'HasMore = bitcoinReceiverTransactions'HasMore,
      bitcoinReceiverTransactions'Url = bitcoinReceiverTransactions'Url
    }
