{-# LANGUAGE MultiWayIf #-}
-- CHANGE WITH CAUTION: This is a generated code file generated by https://github.com/Haskell-OpenAPI-Code-Generator/Haskell-OpenAPI-Client-Code-Generator.
{-# LANGUAGE OverloadedStrings #-}

-- | Contains the types generated from the schema LineItem
module StripeAPI.Types.LineItem where

import qualified Control.Monad.Fail
import qualified Data.Aeson
import qualified Data.Aeson as Data.Aeson.Encoding.Internal
import qualified Data.Aeson as Data.Aeson.Types
import qualified Data.Aeson as Data.Aeson.Types.FromJSON
import qualified Data.Aeson as Data.Aeson.Types.Internal
import qualified Data.Aeson as Data.Aeson.Types.ToJSON
import qualified Data.ByteString
import qualified Data.ByteString as Data.ByteString.Internal
import qualified Data.Foldable
import qualified Data.Functor
import qualified Data.Maybe
import qualified Data.Scientific
import qualified Data.Text
import qualified Data.Text.Internal
import qualified Data.Time.Calendar as Data.Time.Calendar.Days
import qualified Data.Time.LocalTime as Data.Time.LocalTime.Internal.ZonedTime
import qualified GHC.Base
import qualified GHC.Classes
import qualified GHC.Int
import qualified GHC.Show
import qualified GHC.Types
import qualified StripeAPI.Common
import StripeAPI.TypeAlias
import {-# SOURCE #-} StripeAPI.Types.CustomUnitAmount
import {-# SOURCE #-} StripeAPI.Types.DeletedProduct
import {-# SOURCE #-} StripeAPI.Types.Discount
import {-# SOURCE #-} StripeAPI.Types.DiscountsResourceDiscountAmount
import {-# SOURCE #-} StripeAPI.Types.InvoiceLineItemPeriod
import {-# SOURCE #-} StripeAPI.Types.InvoiceTaxAmount
import {-# SOURCE #-} StripeAPI.Types.Invoiceitem
import {-# SOURCE #-} StripeAPI.Types.InvoicesResourceLineItemsCreditedItems
import {-# SOURCE #-} StripeAPI.Types.InvoicesResourceLineItemsProrationDetails
import {-# SOURCE #-} StripeAPI.Types.Price
import {-# SOURCE #-} StripeAPI.Types.PriceTier
import {-# SOURCE #-} StripeAPI.Types.Product
import {-# SOURCE #-} StripeAPI.Types.Recurring
import {-# SOURCE #-} StripeAPI.Types.Subscription
import {-# SOURCE #-} StripeAPI.Types.SubscriptionItem
import {-# SOURCE #-} StripeAPI.Types.TaxRate
import {-# SOURCE #-} StripeAPI.Types.TransformQuantity
import qualified Prelude as GHC.Integer.Type
import qualified Prelude as GHC.Maybe

-- | Defines the object schema located at @components.schemas.line_item@ in the specification.
data LineItem = LineItem
  { -- | amount: The amount, in cents (or local equivalent).
    lineItemAmount :: GHC.Types.Int,
    -- | amount_excluding_tax: The integer amount in cents (or local equivalent) representing the amount for this line item, excluding all tax and discounts.
    lineItemAmountExcludingTax :: (GHC.Maybe.Maybe (StripeAPI.Common.Nullable GHC.Types.Int)),
    -- | currency: Three-letter [ISO currency code](https:\/\/www.iso.org\/iso-4217-currency-codes.html), in lowercase. Must be a [supported currency](https:\/\/stripe.com\/docs\/currencies).
    lineItemCurrency :: Data.Text.Internal.Text,
    -- | description: An arbitrary string attached to the object. Often useful for displaying to users.
    --
    -- Constraints:
    --
    -- * Maximum length of 5000
    lineItemDescription :: (GHC.Maybe.Maybe (StripeAPI.Common.Nullable Data.Text.Internal.Text)),
    -- | discount_amounts: The amount of discount calculated per discount for this line item.
    lineItemDiscountAmounts :: (GHC.Maybe.Maybe (StripeAPI.Common.Nullable ([DiscountsResourceDiscountAmount]))),
    -- | discountable: If true, discounts will apply to this line item. Always false for prorations.
    lineItemDiscountable :: GHC.Types.Bool,
    -- | discounts: The discounts applied to the invoice line item. Line item discounts are applied before invoice discounts. Use \`expand[]=discounts\` to expand each discount.
    lineItemDiscounts :: (GHC.Maybe.Maybe (StripeAPI.Common.Nullable ([LineItemDiscounts'NonNullableVariants]))),
    -- | id: Unique identifier for the object.
    --
    -- Constraints:
    --
    -- * Maximum length of 5000
    lineItemId :: Data.Text.Internal.Text,
    -- | invoice_item: The ID of the [invoice item](https:\/\/stripe.com\/docs\/api\/invoiceitems) associated with this line item if any.
    lineItemInvoiceItem :: (GHC.Maybe.Maybe LineItemInvoiceItem'Variants),
    -- | livemode: Has the value \`true\` if the object exists in live mode or the value \`false\` if the object exists in test mode.
    lineItemLivemode :: GHC.Types.Bool,
    -- | metadata: Set of [key-value pairs](https:\/\/stripe.com\/docs\/api\/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Note that for line items with \`type=subscription\` this will reflect the metadata of the subscription that caused the line item to be created.
    lineItemMetadata :: Data.Aeson.Types.Internal.Object,
    -- | period:
    lineItemPeriod :: InvoiceLineItemPeriod,
    -- | price: The price of the line item.
    lineItemPrice :: (GHC.Maybe.Maybe (StripeAPI.Common.Nullable LineItemPrice'NonNullable)),
    -- | proration: Whether this is a proration.
    lineItemProration :: GHC.Types.Bool,
    -- | proration_details: Additional details for proration line items
    lineItemProrationDetails :: (GHC.Maybe.Maybe (StripeAPI.Common.Nullable LineItemProrationDetails'NonNullable)),
    -- | quantity: The quantity of the subscription, if the line item is a subscription or a proration.
    lineItemQuantity :: (GHC.Maybe.Maybe (StripeAPI.Common.Nullable GHC.Types.Int)),
    -- | subscription: The subscription that the invoice item pertains to, if any.
    lineItemSubscription :: (GHC.Maybe.Maybe (StripeAPI.Common.Nullable LineItemSubscription'NonNullableVariants)),
    -- | subscription_item: The subscription item that generated this line item. Left empty if the line item is not an explicit result of a subscription.
    lineItemSubscriptionItem :: (GHC.Maybe.Maybe LineItemSubscriptionItem'Variants),
    -- | tax_amounts: The amount of tax calculated per tax rate for this line item
    lineItemTaxAmounts :: (GHC.Maybe.Maybe ([InvoiceTaxAmount])),
    -- | tax_rates: The tax rates which apply to the line item.
    lineItemTaxRates :: (GHC.Maybe.Maybe ([TaxRate])),
    -- | type: A string identifying the type of the source of this line item, either an \`invoiceitem\` or a \`subscription\`.
    lineItemType :: LineItemType',
    -- | unit_amount_excluding_tax: The amount in cents (or local equivalent) representing the unit amount for this line item, excluding all tax and discounts.
    lineItemUnitAmountExcludingTax :: (GHC.Maybe.Maybe (StripeAPI.Common.Nullable Data.Text.Internal.Text))
  }
  deriving
    ( GHC.Show.Show,
      GHC.Classes.Eq
    )

instance Data.Aeson.Types.ToJSON.ToJSON LineItem where
  toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["amount" Data.Aeson.Types.ToJSON..= lineItemAmount obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("amount_excluding_tax" Data.Aeson.Types.ToJSON..=)) (lineItemAmountExcludingTax obj) : ["currency" Data.Aeson.Types.ToJSON..= lineItemCurrency obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("description" Data.Aeson.Types.ToJSON..=)) (lineItemDescription obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("discount_amounts" Data.Aeson.Types.ToJSON..=)) (lineItemDiscountAmounts obj) : ["discountable" Data.Aeson.Types.ToJSON..= lineItemDiscountable obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("discounts" Data.Aeson.Types.ToJSON..=)) (lineItemDiscounts obj) : ["id" Data.Aeson.Types.ToJSON..= lineItemId obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("invoice_item" Data.Aeson.Types.ToJSON..=)) (lineItemInvoiceItem obj) : ["livemode" Data.Aeson.Types.ToJSON..= lineItemLivemode obj] : ["metadata" Data.Aeson.Types.ToJSON..= lineItemMetadata obj] : ["period" Data.Aeson.Types.ToJSON..= lineItemPeriod obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("price" Data.Aeson.Types.ToJSON..=)) (lineItemPrice obj) : ["proration" Data.Aeson.Types.ToJSON..= lineItemProration obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("proration_details" Data.Aeson.Types.ToJSON..=)) (lineItemProrationDetails obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("quantity" Data.Aeson.Types.ToJSON..=)) (lineItemQuantity obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("subscription" Data.Aeson.Types.ToJSON..=)) (lineItemSubscription obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("subscription_item" Data.Aeson.Types.ToJSON..=)) (lineItemSubscriptionItem obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("tax_amounts" Data.Aeson.Types.ToJSON..=)) (lineItemTaxAmounts obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("tax_rates" Data.Aeson.Types.ToJSON..=)) (lineItemTaxRates obj) : ["type" Data.Aeson.Types.ToJSON..= lineItemType obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("unit_amount_excluding_tax" Data.Aeson.Types.ToJSON..=)) (lineItemUnitAmountExcludingTax obj) : ["object" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "line_item"] : GHC.Base.mempty))
  toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["amount" Data.Aeson.Types.ToJSON..= lineItemAmount obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("amount_excluding_tax" Data.Aeson.Types.ToJSON..=)) (lineItemAmountExcludingTax obj) : ["currency" Data.Aeson.Types.ToJSON..= lineItemCurrency obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("description" Data.Aeson.Types.ToJSON..=)) (lineItemDescription obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("discount_amounts" Data.Aeson.Types.ToJSON..=)) (lineItemDiscountAmounts obj) : ["discountable" Data.Aeson.Types.ToJSON..= lineItemDiscountable obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("discounts" Data.Aeson.Types.ToJSON..=)) (lineItemDiscounts obj) : ["id" Data.Aeson.Types.ToJSON..= lineItemId obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("invoice_item" Data.Aeson.Types.ToJSON..=)) (lineItemInvoiceItem obj) : ["livemode" Data.Aeson.Types.ToJSON..= lineItemLivemode obj] : ["metadata" Data.Aeson.Types.ToJSON..= lineItemMetadata obj] : ["period" Data.Aeson.Types.ToJSON..= lineItemPeriod obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("price" Data.Aeson.Types.ToJSON..=)) (lineItemPrice obj) : ["proration" Data.Aeson.Types.ToJSON..= lineItemProration obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("proration_details" Data.Aeson.Types.ToJSON..=)) (lineItemProrationDetails obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("quantity" Data.Aeson.Types.ToJSON..=)) (lineItemQuantity obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("subscription" Data.Aeson.Types.ToJSON..=)) (lineItemSubscription obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("subscription_item" Data.Aeson.Types.ToJSON..=)) (lineItemSubscriptionItem obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("tax_amounts" Data.Aeson.Types.ToJSON..=)) (lineItemTaxAmounts obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("tax_rates" Data.Aeson.Types.ToJSON..=)) (lineItemTaxRates obj) : ["type" Data.Aeson.Types.ToJSON..= lineItemType obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("unit_amount_excluding_tax" Data.Aeson.Types.ToJSON..=)) (lineItemUnitAmountExcludingTax obj) : ["object" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "line_item"] : GHC.Base.mempty)))

instance Data.Aeson.Types.FromJSON.FromJSON LineItem where
  parseJSON = Data.Aeson.Types.FromJSON.withObject "LineItem" (\obj -> (((((((((((((((((((((GHC.Base.pure LineItem GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "amount")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "amount_excluding_tax")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "currency")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "description")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "discount_amounts")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "discountable")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "discounts")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "invoice_item")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "livemode")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "metadata")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "period")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "price")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "proration")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "proration_details")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "quantity")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "subscription")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "subscription_item")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "tax_amounts")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "tax_rates")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "type")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "unit_amount_excluding_tax"))

-- | Create a new 'LineItem' with all required fields.
mkLineItem ::
  -- | 'lineItemAmount'
  GHC.Types.Int ->
  -- | 'lineItemCurrency'
  Data.Text.Internal.Text ->
  -- | 'lineItemDiscountable'
  GHC.Types.Bool ->
  -- | 'lineItemId'
  Data.Text.Internal.Text ->
  -- | 'lineItemLivemode'
  GHC.Types.Bool ->
  -- | 'lineItemMetadata'
  Data.Aeson.Types.Internal.Object ->
  -- | 'lineItemPeriod'
  InvoiceLineItemPeriod ->
  -- | 'lineItemProration'
  GHC.Types.Bool ->
  -- | 'lineItemType'
  LineItemType' ->
  LineItem
mkLineItem lineItemAmount lineItemCurrency lineItemDiscountable lineItemId lineItemLivemode lineItemMetadata lineItemPeriod lineItemProration lineItemType =
  LineItem
    { lineItemAmount = lineItemAmount,
      lineItemAmountExcludingTax = GHC.Maybe.Nothing,
      lineItemCurrency = lineItemCurrency,
      lineItemDescription = GHC.Maybe.Nothing,
      lineItemDiscountAmounts = GHC.Maybe.Nothing,
      lineItemDiscountable = lineItemDiscountable,
      lineItemDiscounts = GHC.Maybe.Nothing,
      lineItemId = lineItemId,
      lineItemInvoiceItem = GHC.Maybe.Nothing,
      lineItemLivemode = lineItemLivemode,
      lineItemMetadata = lineItemMetadata,
      lineItemPeriod = lineItemPeriod,
      lineItemPrice = GHC.Maybe.Nothing,
      lineItemProration = lineItemProration,
      lineItemProrationDetails = GHC.Maybe.Nothing,
      lineItemQuantity = GHC.Maybe.Nothing,
      lineItemSubscription = GHC.Maybe.Nothing,
      lineItemSubscriptionItem = GHC.Maybe.Nothing,
      lineItemTaxAmounts = GHC.Maybe.Nothing,
      lineItemTaxRates = GHC.Maybe.Nothing,
      lineItemType = lineItemType,
      lineItemUnitAmountExcludingTax = GHC.Maybe.Nothing
    }

-- | Defines the oneOf schema located at @components.schemas.line_item.properties.discounts.items.anyOf@ in the specification.
data LineItemDiscounts'NonNullableVariants
  = LineItemDiscounts'NonNullableText Data.Text.Internal.Text
  | LineItemDiscounts'NonNullableDiscount Discount
  deriving (GHC.Show.Show, GHC.Classes.Eq)

instance Data.Aeson.Types.ToJSON.ToJSON LineItemDiscounts'NonNullableVariants where
  toJSON (LineItemDiscounts'NonNullableText a) = Data.Aeson.Types.ToJSON.toJSON a
  toJSON (LineItemDiscounts'NonNullableDiscount a) = Data.Aeson.Types.ToJSON.toJSON a

instance Data.Aeson.Types.FromJSON.FromJSON LineItemDiscounts'NonNullableVariants where
  parseJSON val = case (LineItemDiscounts'NonNullableText Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((LineItemDiscounts'NonNullableDiscount Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> Data.Aeson.Types.Internal.Error "No variant matched") of
    Data.Aeson.Types.Internal.Success a -> GHC.Base.pure a
    Data.Aeson.Types.Internal.Error a -> Control.Monad.Fail.fail a

-- | Defines the oneOf schema located at @components.schemas.line_item.properties.invoice_item.anyOf@ in the specification.
--
-- The ID of the [invoice item](https:\/\/stripe.com\/docs\/api\/invoiceitems) associated with this line item if any.
data LineItemInvoiceItem'Variants
  = LineItemInvoiceItem'Text Data.Text.Internal.Text
  | LineItemInvoiceItem'Invoiceitem Invoiceitem
  deriving (GHC.Show.Show, GHC.Classes.Eq)

instance Data.Aeson.Types.ToJSON.ToJSON LineItemInvoiceItem'Variants where
  toJSON (LineItemInvoiceItem'Text a) = Data.Aeson.Types.ToJSON.toJSON a
  toJSON (LineItemInvoiceItem'Invoiceitem a) = Data.Aeson.Types.ToJSON.toJSON a

instance Data.Aeson.Types.FromJSON.FromJSON LineItemInvoiceItem'Variants where
  parseJSON val = case (LineItemInvoiceItem'Text Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((LineItemInvoiceItem'Invoiceitem Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> Data.Aeson.Types.Internal.Error "No variant matched") of
    Data.Aeson.Types.Internal.Success a -> GHC.Base.pure a
    Data.Aeson.Types.Internal.Error a -> Control.Monad.Fail.fail a

-- | Defines the object schema located at @components.schemas.line_item.properties.price.anyOf@ in the specification.
--
-- The price of the line item.
data LineItemPrice'NonNullable = LineItemPrice'NonNullable
  { -- | active: Whether the price can be used for new purchases.
    lineItemPrice'NonNullableActive :: (GHC.Maybe.Maybe GHC.Types.Bool),
    -- | billing_scheme: Describes how to compute the price per period. Either \`per_unit\` or \`tiered\`. \`per_unit\` indicates that the fixed amount (specified in \`unit_amount\` or \`unit_amount_decimal\`) will be charged per unit in \`quantity\` (for prices with \`usage_type=licensed\`), or per unit of total usage (for prices with \`usage_type=metered\`). \`tiered\` indicates that the unit pricing will be computed using a tiering strategy as defined using the \`tiers\` and \`tiers_mode\` attributes.
    lineItemPrice'NonNullableBillingScheme :: (GHC.Maybe.Maybe LineItemPrice'NonNullableBillingScheme'),
    -- | created: Time at which the object was created. Measured in seconds since the Unix epoch.
    lineItemPrice'NonNullableCreated :: (GHC.Maybe.Maybe GHC.Types.Int),
    -- | currency: Three-letter [ISO currency code](https:\/\/www.iso.org\/iso-4217-currency-codes.html), in lowercase. Must be a [supported currency](https:\/\/stripe.com\/docs\/currencies).
    lineItemPrice'NonNullableCurrency :: (GHC.Maybe.Maybe Data.Text.Internal.Text),
    -- | currency_options: Prices defined in each available currency option. Each key must be a three-letter [ISO currency code](https:\/\/www.iso.org\/iso-4217-currency-codes.html) and a [supported currency](https:\/\/stripe.com\/docs\/currencies).
    lineItemPrice'NonNullableCurrencyOptions :: (GHC.Maybe.Maybe Data.Aeson.Types.Internal.Object),
    -- | custom_unit_amount: When set, provides configuration for the amount to be adjusted by the customer during Checkout Sessions and Payment Links.
    lineItemPrice'NonNullableCustomUnitAmount :: (GHC.Maybe.Maybe (StripeAPI.Common.Nullable LineItemPrice'NonNullableCustomUnitAmount'NonNullable)),
    -- | id: Unique identifier for the object.
    --
    -- Constraints:
    --
    -- * Maximum length of 5000
    lineItemPrice'NonNullableId :: (GHC.Maybe.Maybe Data.Text.Internal.Text),
    -- | livemode: Has the value \`true\` if the object exists in live mode or the value \`false\` if the object exists in test mode.
    lineItemPrice'NonNullableLivemode :: (GHC.Maybe.Maybe GHC.Types.Bool),
    -- | lookup_key: A lookup key used to retrieve prices dynamically from a static string. This may be up to 200 characters.
    --
    -- Constraints:
    --
    -- * Maximum length of 5000
    lineItemPrice'NonNullableLookupKey :: (GHC.Maybe.Maybe (StripeAPI.Common.Nullable Data.Text.Internal.Text)),
    -- | metadata: Set of [key-value pairs](https:\/\/stripe.com\/docs\/api\/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format.
    lineItemPrice'NonNullableMetadata :: (GHC.Maybe.Maybe Data.Aeson.Types.Internal.Object),
    -- | nickname: A brief description of the price, hidden from customers.
    --
    -- Constraints:
    --
    -- * Maximum length of 5000
    lineItemPrice'NonNullableNickname :: (GHC.Maybe.Maybe (StripeAPI.Common.Nullable Data.Text.Internal.Text)),
    -- | object: String representing the object\'s type. Objects of the same type share the same value.
    lineItemPrice'NonNullableObject :: (GHC.Maybe.Maybe LineItemPrice'NonNullableObject'),
    -- | product: The ID of the product this price is associated with.
    lineItemPrice'NonNullableProduct :: (GHC.Maybe.Maybe LineItemPrice'NonNullableProduct'Variants),
    -- | recurring: The recurring components of a price such as \`interval\` and \`usage_type\`.
    lineItemPrice'NonNullableRecurring :: (GHC.Maybe.Maybe (StripeAPI.Common.Nullable LineItemPrice'NonNullableRecurring'NonNullable)),
    -- | tax_behavior: Only required if a [default tax behavior](https:\/\/stripe.com\/docs\/tax\/products-prices-tax-categories-tax-behavior\#setting-a-default-tax-behavior-(recommended)) was not provided in the Stripe Tax settings. Specifies whether the price is considered inclusive of taxes or exclusive of taxes. One of \`inclusive\`, \`exclusive\`, or \`unspecified\`. Once specified as either \`inclusive\` or \`exclusive\`, it cannot be changed.
    lineItemPrice'NonNullableTaxBehavior :: (GHC.Maybe.Maybe (StripeAPI.Common.Nullable LineItemPrice'NonNullableTaxBehavior'NonNullable)),
    -- | tiers: Each element represents a pricing tier. This parameter requires \`billing_scheme\` to be set to \`tiered\`. See also the documentation for \`billing_scheme\`.
    lineItemPrice'NonNullableTiers :: (GHC.Maybe.Maybe ([PriceTier])),
    -- | tiers_mode: Defines if the tiering price should be \`graduated\` or \`volume\` based. In \`volume\`-based tiering, the maximum quantity within a period determines the per unit price. In \`graduated\` tiering, pricing can change as the quantity grows.
    lineItemPrice'NonNullableTiersMode :: (GHC.Maybe.Maybe (StripeAPI.Common.Nullable LineItemPrice'NonNullableTiersMode'NonNullable)),
    -- | transform_quantity: Apply a transformation to the reported usage or set quantity before computing the amount billed. Cannot be combined with \`tiers\`.
    lineItemPrice'NonNullableTransformQuantity :: (GHC.Maybe.Maybe (StripeAPI.Common.Nullable LineItemPrice'NonNullableTransformQuantity'NonNullable)),
    -- | type: One of \`one_time\` or \`recurring\` depending on whether the price is for a one-time purchase or a recurring (subscription) purchase.
    lineItemPrice'NonNullableType :: (GHC.Maybe.Maybe LineItemPrice'NonNullableType'),
    -- | unit_amount: The unit amount in cents (or local equivalent) to be charged, represented as a whole integer if possible. Only set if \`billing_scheme=per_unit\`.
    lineItemPrice'NonNullableUnitAmount :: (GHC.Maybe.Maybe (StripeAPI.Common.Nullable GHC.Types.Int)),
    -- | unit_amount_decimal: The unit amount in cents (or local equivalent) to be charged, represented as a decimal string with at most 12 decimal places. Only set if \`billing_scheme=per_unit\`.
    lineItemPrice'NonNullableUnitAmountDecimal :: (GHC.Maybe.Maybe (StripeAPI.Common.Nullable Data.Text.Internal.Text))
  }
  deriving
    ( GHC.Show.Show,
      GHC.Classes.Eq
    )

instance Data.Aeson.Types.ToJSON.ToJSON LineItemPrice'NonNullable where
  toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("active" Data.Aeson.Types.ToJSON..=)) (lineItemPrice'NonNullableActive obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("billing_scheme" Data.Aeson.Types.ToJSON..=)) (lineItemPrice'NonNullableBillingScheme obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("created" Data.Aeson.Types.ToJSON..=)) (lineItemPrice'NonNullableCreated obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("currency" Data.Aeson.Types.ToJSON..=)) (lineItemPrice'NonNullableCurrency obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("currency_options" Data.Aeson.Types.ToJSON..=)) (lineItemPrice'NonNullableCurrencyOptions obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("custom_unit_amount" Data.Aeson.Types.ToJSON..=)) (lineItemPrice'NonNullableCustomUnitAmount obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("id" Data.Aeson.Types.ToJSON..=)) (lineItemPrice'NonNullableId obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("livemode" Data.Aeson.Types.ToJSON..=)) (lineItemPrice'NonNullableLivemode obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("lookup_key" Data.Aeson.Types.ToJSON..=)) (lineItemPrice'NonNullableLookupKey obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("metadata" Data.Aeson.Types.ToJSON..=)) (lineItemPrice'NonNullableMetadata obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("nickname" Data.Aeson.Types.ToJSON..=)) (lineItemPrice'NonNullableNickname obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("object" Data.Aeson.Types.ToJSON..=)) (lineItemPrice'NonNullableObject obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("product" Data.Aeson.Types.ToJSON..=)) (lineItemPrice'NonNullableProduct obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("recurring" Data.Aeson.Types.ToJSON..=)) (lineItemPrice'NonNullableRecurring obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("tax_behavior" Data.Aeson.Types.ToJSON..=)) (lineItemPrice'NonNullableTaxBehavior obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("tiers" Data.Aeson.Types.ToJSON..=)) (lineItemPrice'NonNullableTiers obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("tiers_mode" Data.Aeson.Types.ToJSON..=)) (lineItemPrice'NonNullableTiersMode obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("transform_quantity" Data.Aeson.Types.ToJSON..=)) (lineItemPrice'NonNullableTransformQuantity obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("type" Data.Aeson.Types.ToJSON..=)) (lineItemPrice'NonNullableType obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("unit_amount" Data.Aeson.Types.ToJSON..=)) (lineItemPrice'NonNullableUnitAmount obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("unit_amount_decimal" Data.Aeson.Types.ToJSON..=)) (lineItemPrice'NonNullableUnitAmountDecimal obj) : GHC.Base.mempty))
  toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("active" Data.Aeson.Types.ToJSON..=)) (lineItemPrice'NonNullableActive obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("billing_scheme" Data.Aeson.Types.ToJSON..=)) (lineItemPrice'NonNullableBillingScheme obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("created" Data.Aeson.Types.ToJSON..=)) (lineItemPrice'NonNullableCreated obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("currency" Data.Aeson.Types.ToJSON..=)) (lineItemPrice'NonNullableCurrency obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("currency_options" Data.Aeson.Types.ToJSON..=)) (lineItemPrice'NonNullableCurrencyOptions obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("custom_unit_amount" Data.Aeson.Types.ToJSON..=)) (lineItemPrice'NonNullableCustomUnitAmount obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("id" Data.Aeson.Types.ToJSON..=)) (lineItemPrice'NonNullableId obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("livemode" Data.Aeson.Types.ToJSON..=)) (lineItemPrice'NonNullableLivemode obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("lookup_key" Data.Aeson.Types.ToJSON..=)) (lineItemPrice'NonNullableLookupKey obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("metadata" Data.Aeson.Types.ToJSON..=)) (lineItemPrice'NonNullableMetadata obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("nickname" Data.Aeson.Types.ToJSON..=)) (lineItemPrice'NonNullableNickname obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("object" Data.Aeson.Types.ToJSON..=)) (lineItemPrice'NonNullableObject obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("product" Data.Aeson.Types.ToJSON..=)) (lineItemPrice'NonNullableProduct obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("recurring" Data.Aeson.Types.ToJSON..=)) (lineItemPrice'NonNullableRecurring obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("tax_behavior" Data.Aeson.Types.ToJSON..=)) (lineItemPrice'NonNullableTaxBehavior obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("tiers" Data.Aeson.Types.ToJSON..=)) (lineItemPrice'NonNullableTiers obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("tiers_mode" Data.Aeson.Types.ToJSON..=)) (lineItemPrice'NonNullableTiersMode obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("transform_quantity" Data.Aeson.Types.ToJSON..=)) (lineItemPrice'NonNullableTransformQuantity obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("type" Data.Aeson.Types.ToJSON..=)) (lineItemPrice'NonNullableType obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("unit_amount" Data.Aeson.Types.ToJSON..=)) (lineItemPrice'NonNullableUnitAmount obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("unit_amount_decimal" Data.Aeson.Types.ToJSON..=)) (lineItemPrice'NonNullableUnitAmountDecimal obj) : GHC.Base.mempty)))

instance Data.Aeson.Types.FromJSON.FromJSON LineItemPrice'NonNullable where
  parseJSON = Data.Aeson.Types.FromJSON.withObject "LineItemPrice'NonNullable" (\obj -> ((((((((((((((((((((GHC.Base.pure LineItemPrice'NonNullable GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "active")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "billing_scheme")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "created")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "currency")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "currency_options")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "custom_unit_amount")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "livemode")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "lookup_key")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "metadata")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "nickname")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "object")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "product")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "recurring")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "tax_behavior")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "tiers")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "tiers_mode")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "transform_quantity")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "type")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "unit_amount")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "unit_amount_decimal"))

-- | Create a new 'LineItemPrice'NonNullable' with all required fields.
mkLineItemPrice'NonNullable :: LineItemPrice'NonNullable
mkLineItemPrice'NonNullable =
  LineItemPrice'NonNullable
    { lineItemPrice'NonNullableActive = GHC.Maybe.Nothing,
      lineItemPrice'NonNullableBillingScheme = GHC.Maybe.Nothing,
      lineItemPrice'NonNullableCreated = GHC.Maybe.Nothing,
      lineItemPrice'NonNullableCurrency = GHC.Maybe.Nothing,
      lineItemPrice'NonNullableCurrencyOptions = GHC.Maybe.Nothing,
      lineItemPrice'NonNullableCustomUnitAmount = GHC.Maybe.Nothing,
      lineItemPrice'NonNullableId = GHC.Maybe.Nothing,
      lineItemPrice'NonNullableLivemode = GHC.Maybe.Nothing,
      lineItemPrice'NonNullableLookupKey = GHC.Maybe.Nothing,
      lineItemPrice'NonNullableMetadata = GHC.Maybe.Nothing,
      lineItemPrice'NonNullableNickname = GHC.Maybe.Nothing,
      lineItemPrice'NonNullableObject = GHC.Maybe.Nothing,
      lineItemPrice'NonNullableProduct = GHC.Maybe.Nothing,
      lineItemPrice'NonNullableRecurring = GHC.Maybe.Nothing,
      lineItemPrice'NonNullableTaxBehavior = GHC.Maybe.Nothing,
      lineItemPrice'NonNullableTiers = GHC.Maybe.Nothing,
      lineItemPrice'NonNullableTiersMode = GHC.Maybe.Nothing,
      lineItemPrice'NonNullableTransformQuantity = GHC.Maybe.Nothing,
      lineItemPrice'NonNullableType = GHC.Maybe.Nothing,
      lineItemPrice'NonNullableUnitAmount = GHC.Maybe.Nothing,
      lineItemPrice'NonNullableUnitAmountDecimal = GHC.Maybe.Nothing
    }

-- | Defines the enum schema located at @components.schemas.line_item.properties.price.anyOf.properties.billing_scheme@ in the specification.
--
-- Describes how to compute the price per period. Either \`per_unit\` or \`tiered\`. \`per_unit\` indicates that the fixed amount (specified in \`unit_amount\` or \`unit_amount_decimal\`) will be charged per unit in \`quantity\` (for prices with \`usage_type=licensed\`), or per unit of total usage (for prices with \`usage_type=metered\`). \`tiered\` indicates that the unit pricing will be computed using a tiering strategy as defined using the \`tiers\` and \`tiers_mode\` attributes.
data LineItemPrice'NonNullableBillingScheme'
  = -- | This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
    LineItemPrice'NonNullableBillingScheme'Other Data.Aeson.Types.Internal.Value
  | -- | This constructor can be used to send values to the server which are not present in the specification yet.
    LineItemPrice'NonNullableBillingScheme'Typed Data.Text.Internal.Text
  | -- | Represents the JSON value @"per_unit"@
    LineItemPrice'NonNullableBillingScheme'EnumPerUnit
  | -- | Represents the JSON value @"tiered"@
    LineItemPrice'NonNullableBillingScheme'EnumTiered
  deriving (GHC.Show.Show, GHC.Classes.Eq)

instance Data.Aeson.Types.ToJSON.ToJSON LineItemPrice'NonNullableBillingScheme' where
  toJSON (LineItemPrice'NonNullableBillingScheme'Other val) = val
  toJSON (LineItemPrice'NonNullableBillingScheme'Typed val) = Data.Aeson.Types.ToJSON.toJSON val
  toJSON (LineItemPrice'NonNullableBillingScheme'EnumPerUnit) = "per_unit"
  toJSON (LineItemPrice'NonNullableBillingScheme'EnumTiered) = "tiered"

instance Data.Aeson.Types.FromJSON.FromJSON LineItemPrice'NonNullableBillingScheme' where
  parseJSON val =
    GHC.Base.pure
      ( if
            | val GHC.Classes.== "per_unit" -> LineItemPrice'NonNullableBillingScheme'EnumPerUnit
            | val GHC.Classes.== "tiered" -> LineItemPrice'NonNullableBillingScheme'EnumTiered
            | GHC.Base.otherwise -> LineItemPrice'NonNullableBillingScheme'Other val
      )

-- | Defines the object schema located at @components.schemas.line_item.properties.price.anyOf.properties.custom_unit_amount.anyOf@ in the specification.
--
-- When set, provides configuration for the amount to be adjusted by the customer during Checkout Sessions and Payment Links.
data LineItemPrice'NonNullableCustomUnitAmount'NonNullable = LineItemPrice'NonNullableCustomUnitAmount'NonNullable
  { -- | maximum: The maximum unit amount the customer can specify for this item.
    lineItemPrice'NonNullableCustomUnitAmount'NonNullableMaximum :: (GHC.Maybe.Maybe (StripeAPI.Common.Nullable GHC.Types.Int)),
    -- | minimum: The minimum unit amount the customer can specify for this item. Must be at least the minimum charge amount.
    lineItemPrice'NonNullableCustomUnitAmount'NonNullableMinimum :: (GHC.Maybe.Maybe (StripeAPI.Common.Nullable GHC.Types.Int)),
    -- | preset: The starting unit amount which can be updated by the customer.
    lineItemPrice'NonNullableCustomUnitAmount'NonNullablePreset :: (GHC.Maybe.Maybe (StripeAPI.Common.Nullable GHC.Types.Int))
  }
  deriving
    ( GHC.Show.Show,
      GHC.Classes.Eq
    )

instance Data.Aeson.Types.ToJSON.ToJSON LineItemPrice'NonNullableCustomUnitAmount'NonNullable where
  toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("maximum" Data.Aeson.Types.ToJSON..=)) (lineItemPrice'NonNullableCustomUnitAmount'NonNullableMaximum obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("minimum" Data.Aeson.Types.ToJSON..=)) (lineItemPrice'NonNullableCustomUnitAmount'NonNullableMinimum obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("preset" Data.Aeson.Types.ToJSON..=)) (lineItemPrice'NonNullableCustomUnitAmount'NonNullablePreset obj) : GHC.Base.mempty))
  toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("maximum" Data.Aeson.Types.ToJSON..=)) (lineItemPrice'NonNullableCustomUnitAmount'NonNullableMaximum obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("minimum" Data.Aeson.Types.ToJSON..=)) (lineItemPrice'NonNullableCustomUnitAmount'NonNullableMinimum obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("preset" Data.Aeson.Types.ToJSON..=)) (lineItemPrice'NonNullableCustomUnitAmount'NonNullablePreset obj) : GHC.Base.mempty)))

instance Data.Aeson.Types.FromJSON.FromJSON LineItemPrice'NonNullableCustomUnitAmount'NonNullable where
  parseJSON = Data.Aeson.Types.FromJSON.withObject "LineItemPrice'NonNullableCustomUnitAmount'NonNullable" (\obj -> ((GHC.Base.pure LineItemPrice'NonNullableCustomUnitAmount'NonNullable GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "maximum")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "minimum")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "preset"))

-- | Create a new 'LineItemPrice'NonNullableCustomUnitAmount'NonNullable' with all required fields.
mkLineItemPrice'NonNullableCustomUnitAmount'NonNullable :: LineItemPrice'NonNullableCustomUnitAmount'NonNullable
mkLineItemPrice'NonNullableCustomUnitAmount'NonNullable =
  LineItemPrice'NonNullableCustomUnitAmount'NonNullable
    { lineItemPrice'NonNullableCustomUnitAmount'NonNullableMaximum = GHC.Maybe.Nothing,
      lineItemPrice'NonNullableCustomUnitAmount'NonNullableMinimum = GHC.Maybe.Nothing,
      lineItemPrice'NonNullableCustomUnitAmount'NonNullablePreset = GHC.Maybe.Nothing
    }

-- | Defines the enum schema located at @components.schemas.line_item.properties.price.anyOf.properties.object@ in the specification.
--
-- String representing the object\'s type. Objects of the same type share the same value.
data LineItemPrice'NonNullableObject'
  = -- | This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
    LineItemPrice'NonNullableObject'Other Data.Aeson.Types.Internal.Value
  | -- | This constructor can be used to send values to the server which are not present in the specification yet.
    LineItemPrice'NonNullableObject'Typed Data.Text.Internal.Text
  | -- | Represents the JSON value @"price"@
    LineItemPrice'NonNullableObject'EnumPrice
  deriving (GHC.Show.Show, GHC.Classes.Eq)

instance Data.Aeson.Types.ToJSON.ToJSON LineItemPrice'NonNullableObject' where
  toJSON (LineItemPrice'NonNullableObject'Other val) = val
  toJSON (LineItemPrice'NonNullableObject'Typed val) = Data.Aeson.Types.ToJSON.toJSON val
  toJSON (LineItemPrice'NonNullableObject'EnumPrice) = "price"

instance Data.Aeson.Types.FromJSON.FromJSON LineItemPrice'NonNullableObject' where
  parseJSON val =
    GHC.Base.pure
      ( if
            | val GHC.Classes.== "price" -> LineItemPrice'NonNullableObject'EnumPrice
            | GHC.Base.otherwise -> LineItemPrice'NonNullableObject'Other val
      )

-- | Defines the oneOf schema located at @components.schemas.line_item.properties.price.anyOf.properties.product.anyOf@ in the specification.
--
-- The ID of the product this price is associated with.
data LineItemPrice'NonNullableProduct'Variants
  = LineItemPrice'NonNullableProduct'Text Data.Text.Internal.Text
  | LineItemPrice'NonNullableProduct'Product Product
  | LineItemPrice'NonNullableProduct'DeletedProduct DeletedProduct
  deriving (GHC.Show.Show, GHC.Classes.Eq)

instance Data.Aeson.Types.ToJSON.ToJSON LineItemPrice'NonNullableProduct'Variants where
  toJSON (LineItemPrice'NonNullableProduct'Text a) = Data.Aeson.Types.ToJSON.toJSON a
  toJSON (LineItemPrice'NonNullableProduct'Product a) = Data.Aeson.Types.ToJSON.toJSON a
  toJSON (LineItemPrice'NonNullableProduct'DeletedProduct a) = Data.Aeson.Types.ToJSON.toJSON a

instance Data.Aeson.Types.FromJSON.FromJSON LineItemPrice'NonNullableProduct'Variants where
  parseJSON val = case (LineItemPrice'NonNullableProduct'Text Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((LineItemPrice'NonNullableProduct'Product Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((LineItemPrice'NonNullableProduct'DeletedProduct Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> Data.Aeson.Types.Internal.Error "No variant matched")) of
    Data.Aeson.Types.Internal.Success a -> GHC.Base.pure a
    Data.Aeson.Types.Internal.Error a -> Control.Monad.Fail.fail a

-- | Defines the object schema located at @components.schemas.line_item.properties.price.anyOf.properties.recurring.anyOf@ in the specification.
--
-- The recurring components of a price such as \\\`interval\\\` and \\\`usage_type\\\`.
data LineItemPrice'NonNullableRecurring'NonNullable = LineItemPrice'NonNullableRecurring'NonNullable
  { -- | aggregate_usage: Specifies a usage aggregation strategy for prices of \`usage_type=metered\`. Defaults to \`sum\`.
    lineItemPrice'NonNullableRecurring'NonNullableAggregateUsage :: (GHC.Maybe.Maybe (StripeAPI.Common.Nullable LineItemPrice'NonNullableRecurring'NonNullableAggregateUsage'NonNullable)),
    -- | interval: The frequency at which a subscription is billed. One of \`day\`, \`week\`, \`month\` or \`year\`.
    lineItemPrice'NonNullableRecurring'NonNullableInterval :: (GHC.Maybe.Maybe LineItemPrice'NonNullableRecurring'NonNullableInterval'),
    -- | interval_count: The number of intervals (specified in the \`interval\` attribute) between subscription billings. For example, \`interval=month\` and \`interval_count=3\` bills every 3 months.
    lineItemPrice'NonNullableRecurring'NonNullableIntervalCount :: (GHC.Maybe.Maybe GHC.Types.Int),
    -- | usage_type: Configures how the quantity per period should be determined. Can be either \`metered\` or \`licensed\`. \`licensed\` automatically bills the \`quantity\` set when adding it to a subscription. \`metered\` aggregates the total usage based on usage records. Defaults to \`licensed\`.
    lineItemPrice'NonNullableRecurring'NonNullableUsageType :: (GHC.Maybe.Maybe LineItemPrice'NonNullableRecurring'NonNullableUsageType')
  }
  deriving
    ( GHC.Show.Show,
      GHC.Classes.Eq
    )

instance Data.Aeson.Types.ToJSON.ToJSON LineItemPrice'NonNullableRecurring'NonNullable where
  toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("aggregate_usage" Data.Aeson.Types.ToJSON..=)) (lineItemPrice'NonNullableRecurring'NonNullableAggregateUsage obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("interval" Data.Aeson.Types.ToJSON..=)) (lineItemPrice'NonNullableRecurring'NonNullableInterval obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("interval_count" Data.Aeson.Types.ToJSON..=)) (lineItemPrice'NonNullableRecurring'NonNullableIntervalCount obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("usage_type" Data.Aeson.Types.ToJSON..=)) (lineItemPrice'NonNullableRecurring'NonNullableUsageType obj) : GHC.Base.mempty))
  toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("aggregate_usage" Data.Aeson.Types.ToJSON..=)) (lineItemPrice'NonNullableRecurring'NonNullableAggregateUsage obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("interval" Data.Aeson.Types.ToJSON..=)) (lineItemPrice'NonNullableRecurring'NonNullableInterval obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("interval_count" Data.Aeson.Types.ToJSON..=)) (lineItemPrice'NonNullableRecurring'NonNullableIntervalCount obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("usage_type" Data.Aeson.Types.ToJSON..=)) (lineItemPrice'NonNullableRecurring'NonNullableUsageType obj) : GHC.Base.mempty)))

instance Data.Aeson.Types.FromJSON.FromJSON LineItemPrice'NonNullableRecurring'NonNullable where
  parseJSON = Data.Aeson.Types.FromJSON.withObject "LineItemPrice'NonNullableRecurring'NonNullable" (\obj -> (((GHC.Base.pure LineItemPrice'NonNullableRecurring'NonNullable GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "aggregate_usage")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "interval")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "interval_count")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "usage_type"))

-- | Create a new 'LineItemPrice'NonNullableRecurring'NonNullable' with all required fields.
mkLineItemPrice'NonNullableRecurring'NonNullable :: LineItemPrice'NonNullableRecurring'NonNullable
mkLineItemPrice'NonNullableRecurring'NonNullable =
  LineItemPrice'NonNullableRecurring'NonNullable
    { lineItemPrice'NonNullableRecurring'NonNullableAggregateUsage = GHC.Maybe.Nothing,
      lineItemPrice'NonNullableRecurring'NonNullableInterval = GHC.Maybe.Nothing,
      lineItemPrice'NonNullableRecurring'NonNullableIntervalCount = GHC.Maybe.Nothing,
      lineItemPrice'NonNullableRecurring'NonNullableUsageType = GHC.Maybe.Nothing
    }

-- | Defines the enum schema located at @components.schemas.line_item.properties.price.anyOf.properties.recurring.anyOf.properties.aggregate_usage@ in the specification.
--
-- Specifies a usage aggregation strategy for prices of \`usage_type=metered\`. Defaults to \`sum\`.
data LineItemPrice'NonNullableRecurring'NonNullableAggregateUsage'NonNullable
  = -- | This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
    LineItemPrice'NonNullableRecurring'NonNullableAggregateUsage'NonNullableOther Data.Aeson.Types.Internal.Value
  | -- | This constructor can be used to send values to the server which are not present in the specification yet.
    LineItemPrice'NonNullableRecurring'NonNullableAggregateUsage'NonNullableTyped Data.Text.Internal.Text
  | -- | Represents the JSON value @"last_during_period"@
    LineItemPrice'NonNullableRecurring'NonNullableAggregateUsage'NonNullableEnumLastDuringPeriod
  | -- | Represents the JSON value @"last_ever"@
    LineItemPrice'NonNullableRecurring'NonNullableAggregateUsage'NonNullableEnumLastEver
  | -- | Represents the JSON value @"max"@
    LineItemPrice'NonNullableRecurring'NonNullableAggregateUsage'NonNullableEnumMax
  | -- | Represents the JSON value @"sum"@
    LineItemPrice'NonNullableRecurring'NonNullableAggregateUsage'NonNullableEnumSum
  deriving (GHC.Show.Show, GHC.Classes.Eq)

instance Data.Aeson.Types.ToJSON.ToJSON LineItemPrice'NonNullableRecurring'NonNullableAggregateUsage'NonNullable where
  toJSON (LineItemPrice'NonNullableRecurring'NonNullableAggregateUsage'NonNullableOther val) = val
  toJSON (LineItemPrice'NonNullableRecurring'NonNullableAggregateUsage'NonNullableTyped val) = Data.Aeson.Types.ToJSON.toJSON val
  toJSON (LineItemPrice'NonNullableRecurring'NonNullableAggregateUsage'NonNullableEnumLastDuringPeriod) = "last_during_period"
  toJSON (LineItemPrice'NonNullableRecurring'NonNullableAggregateUsage'NonNullableEnumLastEver) = "last_ever"
  toJSON (LineItemPrice'NonNullableRecurring'NonNullableAggregateUsage'NonNullableEnumMax) = "max"
  toJSON (LineItemPrice'NonNullableRecurring'NonNullableAggregateUsage'NonNullableEnumSum) = "sum"

instance Data.Aeson.Types.FromJSON.FromJSON LineItemPrice'NonNullableRecurring'NonNullableAggregateUsage'NonNullable where
  parseJSON val =
    GHC.Base.pure
      ( if
            | val GHC.Classes.== "last_during_period" -> LineItemPrice'NonNullableRecurring'NonNullableAggregateUsage'NonNullableEnumLastDuringPeriod
            | val GHC.Classes.== "last_ever" -> LineItemPrice'NonNullableRecurring'NonNullableAggregateUsage'NonNullableEnumLastEver
            | val GHC.Classes.== "max" -> LineItemPrice'NonNullableRecurring'NonNullableAggregateUsage'NonNullableEnumMax
            | val GHC.Classes.== "sum" -> LineItemPrice'NonNullableRecurring'NonNullableAggregateUsage'NonNullableEnumSum
            | GHC.Base.otherwise -> LineItemPrice'NonNullableRecurring'NonNullableAggregateUsage'NonNullableOther val
      )

-- | Defines the enum schema located at @components.schemas.line_item.properties.price.anyOf.properties.recurring.anyOf.properties.interval@ in the specification.
--
-- The frequency at which a subscription is billed. One of \`day\`, \`week\`, \`month\` or \`year\`.
data LineItemPrice'NonNullableRecurring'NonNullableInterval'
  = -- | This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
    LineItemPrice'NonNullableRecurring'NonNullableInterval'Other Data.Aeson.Types.Internal.Value
  | -- | This constructor can be used to send values to the server which are not present in the specification yet.
    LineItemPrice'NonNullableRecurring'NonNullableInterval'Typed Data.Text.Internal.Text
  | -- | Represents the JSON value @"day"@
    LineItemPrice'NonNullableRecurring'NonNullableInterval'EnumDay
  | -- | Represents the JSON value @"month"@
    LineItemPrice'NonNullableRecurring'NonNullableInterval'EnumMonth
  | -- | Represents the JSON value @"week"@
    LineItemPrice'NonNullableRecurring'NonNullableInterval'EnumWeek
  | -- | Represents the JSON value @"year"@
    LineItemPrice'NonNullableRecurring'NonNullableInterval'EnumYear
  deriving (GHC.Show.Show, GHC.Classes.Eq)

instance Data.Aeson.Types.ToJSON.ToJSON LineItemPrice'NonNullableRecurring'NonNullableInterval' where
  toJSON (LineItemPrice'NonNullableRecurring'NonNullableInterval'Other val) = val
  toJSON (LineItemPrice'NonNullableRecurring'NonNullableInterval'Typed val) = Data.Aeson.Types.ToJSON.toJSON val
  toJSON (LineItemPrice'NonNullableRecurring'NonNullableInterval'EnumDay) = "day"
  toJSON (LineItemPrice'NonNullableRecurring'NonNullableInterval'EnumMonth) = "month"
  toJSON (LineItemPrice'NonNullableRecurring'NonNullableInterval'EnumWeek) = "week"
  toJSON (LineItemPrice'NonNullableRecurring'NonNullableInterval'EnumYear) = "year"

instance Data.Aeson.Types.FromJSON.FromJSON LineItemPrice'NonNullableRecurring'NonNullableInterval' where
  parseJSON val =
    GHC.Base.pure
      ( if
            | val GHC.Classes.== "day" -> LineItemPrice'NonNullableRecurring'NonNullableInterval'EnumDay
            | val GHC.Classes.== "month" -> LineItemPrice'NonNullableRecurring'NonNullableInterval'EnumMonth
            | val GHC.Classes.== "week" -> LineItemPrice'NonNullableRecurring'NonNullableInterval'EnumWeek
            | val GHC.Classes.== "year" -> LineItemPrice'NonNullableRecurring'NonNullableInterval'EnumYear
            | GHC.Base.otherwise -> LineItemPrice'NonNullableRecurring'NonNullableInterval'Other val
      )

-- | Defines the enum schema located at @components.schemas.line_item.properties.price.anyOf.properties.recurring.anyOf.properties.usage_type@ in the specification.
--
-- Configures how the quantity per period should be determined. Can be either \`metered\` or \`licensed\`. \`licensed\` automatically bills the \`quantity\` set when adding it to a subscription. \`metered\` aggregates the total usage based on usage records. Defaults to \`licensed\`.
data LineItemPrice'NonNullableRecurring'NonNullableUsageType'
  = -- | This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
    LineItemPrice'NonNullableRecurring'NonNullableUsageType'Other Data.Aeson.Types.Internal.Value
  | -- | This constructor can be used to send values to the server which are not present in the specification yet.
    LineItemPrice'NonNullableRecurring'NonNullableUsageType'Typed Data.Text.Internal.Text
  | -- | Represents the JSON value @"licensed"@
    LineItemPrice'NonNullableRecurring'NonNullableUsageType'EnumLicensed
  | -- | Represents the JSON value @"metered"@
    LineItemPrice'NonNullableRecurring'NonNullableUsageType'EnumMetered
  deriving (GHC.Show.Show, GHC.Classes.Eq)

instance Data.Aeson.Types.ToJSON.ToJSON LineItemPrice'NonNullableRecurring'NonNullableUsageType' where
  toJSON (LineItemPrice'NonNullableRecurring'NonNullableUsageType'Other val) = val
  toJSON (LineItemPrice'NonNullableRecurring'NonNullableUsageType'Typed val) = Data.Aeson.Types.ToJSON.toJSON val
  toJSON (LineItemPrice'NonNullableRecurring'NonNullableUsageType'EnumLicensed) = "licensed"
  toJSON (LineItemPrice'NonNullableRecurring'NonNullableUsageType'EnumMetered) = "metered"

instance Data.Aeson.Types.FromJSON.FromJSON LineItemPrice'NonNullableRecurring'NonNullableUsageType' where
  parseJSON val =
    GHC.Base.pure
      ( if
            | val GHC.Classes.== "licensed" -> LineItemPrice'NonNullableRecurring'NonNullableUsageType'EnumLicensed
            | val GHC.Classes.== "metered" -> LineItemPrice'NonNullableRecurring'NonNullableUsageType'EnumMetered
            | GHC.Base.otherwise -> LineItemPrice'NonNullableRecurring'NonNullableUsageType'Other val
      )

-- | Defines the enum schema located at @components.schemas.line_item.properties.price.anyOf.properties.tax_behavior@ in the specification.
--
-- Only required if a [default tax behavior](https:\/\/stripe.com\/docs\/tax\/products-prices-tax-categories-tax-behavior\#setting-a-default-tax-behavior-(recommended)) was not provided in the Stripe Tax settings. Specifies whether the price is considered inclusive of taxes or exclusive of taxes. One of \`inclusive\`, \`exclusive\`, or \`unspecified\`. Once specified as either \`inclusive\` or \`exclusive\`, it cannot be changed.
data LineItemPrice'NonNullableTaxBehavior'NonNullable
  = -- | This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
    LineItemPrice'NonNullableTaxBehavior'NonNullableOther Data.Aeson.Types.Internal.Value
  | -- | This constructor can be used to send values to the server which are not present in the specification yet.
    LineItemPrice'NonNullableTaxBehavior'NonNullableTyped Data.Text.Internal.Text
  | -- | Represents the JSON value @"exclusive"@
    LineItemPrice'NonNullableTaxBehavior'NonNullableEnumExclusive
  | -- | Represents the JSON value @"inclusive"@
    LineItemPrice'NonNullableTaxBehavior'NonNullableEnumInclusive
  | -- | Represents the JSON value @"unspecified"@
    LineItemPrice'NonNullableTaxBehavior'NonNullableEnumUnspecified
  deriving (GHC.Show.Show, GHC.Classes.Eq)

instance Data.Aeson.Types.ToJSON.ToJSON LineItemPrice'NonNullableTaxBehavior'NonNullable where
  toJSON (LineItemPrice'NonNullableTaxBehavior'NonNullableOther val) = val
  toJSON (LineItemPrice'NonNullableTaxBehavior'NonNullableTyped val) = Data.Aeson.Types.ToJSON.toJSON val
  toJSON (LineItemPrice'NonNullableTaxBehavior'NonNullableEnumExclusive) = "exclusive"
  toJSON (LineItemPrice'NonNullableTaxBehavior'NonNullableEnumInclusive) = "inclusive"
  toJSON (LineItemPrice'NonNullableTaxBehavior'NonNullableEnumUnspecified) = "unspecified"

instance Data.Aeson.Types.FromJSON.FromJSON LineItemPrice'NonNullableTaxBehavior'NonNullable where
  parseJSON val =
    GHC.Base.pure
      ( if
            | val GHC.Classes.== "exclusive" -> LineItemPrice'NonNullableTaxBehavior'NonNullableEnumExclusive
            | val GHC.Classes.== "inclusive" -> LineItemPrice'NonNullableTaxBehavior'NonNullableEnumInclusive
            | val GHC.Classes.== "unspecified" -> LineItemPrice'NonNullableTaxBehavior'NonNullableEnumUnspecified
            | GHC.Base.otherwise -> LineItemPrice'NonNullableTaxBehavior'NonNullableOther val
      )

-- | Defines the enum schema located at @components.schemas.line_item.properties.price.anyOf.properties.tiers_mode@ in the specification.
--
-- Defines if the tiering price should be \`graduated\` or \`volume\` based. In \`volume\`-based tiering, the maximum quantity within a period determines the per unit price. In \`graduated\` tiering, pricing can change as the quantity grows.
data LineItemPrice'NonNullableTiersMode'NonNullable
  = -- | This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
    LineItemPrice'NonNullableTiersMode'NonNullableOther Data.Aeson.Types.Internal.Value
  | -- | This constructor can be used to send values to the server which are not present in the specification yet.
    LineItemPrice'NonNullableTiersMode'NonNullableTyped Data.Text.Internal.Text
  | -- | Represents the JSON value @"graduated"@
    LineItemPrice'NonNullableTiersMode'NonNullableEnumGraduated
  | -- | Represents the JSON value @"volume"@
    LineItemPrice'NonNullableTiersMode'NonNullableEnumVolume
  deriving (GHC.Show.Show, GHC.Classes.Eq)

instance Data.Aeson.Types.ToJSON.ToJSON LineItemPrice'NonNullableTiersMode'NonNullable where
  toJSON (LineItemPrice'NonNullableTiersMode'NonNullableOther val) = val
  toJSON (LineItemPrice'NonNullableTiersMode'NonNullableTyped val) = Data.Aeson.Types.ToJSON.toJSON val
  toJSON (LineItemPrice'NonNullableTiersMode'NonNullableEnumGraduated) = "graduated"
  toJSON (LineItemPrice'NonNullableTiersMode'NonNullableEnumVolume) = "volume"

instance Data.Aeson.Types.FromJSON.FromJSON LineItemPrice'NonNullableTiersMode'NonNullable where
  parseJSON val =
    GHC.Base.pure
      ( if
            | val GHC.Classes.== "graduated" -> LineItemPrice'NonNullableTiersMode'NonNullableEnumGraduated
            | val GHC.Classes.== "volume" -> LineItemPrice'NonNullableTiersMode'NonNullableEnumVolume
            | GHC.Base.otherwise -> LineItemPrice'NonNullableTiersMode'NonNullableOther val
      )

-- | Defines the object schema located at @components.schemas.line_item.properties.price.anyOf.properties.transform_quantity.anyOf@ in the specification.
--
-- Apply a transformation to the reported usage or set quantity before computing the amount billed. Cannot be combined with \\\`tiers\\\`.
data LineItemPrice'NonNullableTransformQuantity'NonNullable = LineItemPrice'NonNullableTransformQuantity'NonNullable
  { -- | divide_by: Divide usage by this number.
    lineItemPrice'NonNullableTransformQuantity'NonNullableDivideBy :: (GHC.Maybe.Maybe GHC.Types.Int),
    -- | round: After division, either round the result \`up\` or \`down\`.
    lineItemPrice'NonNullableTransformQuantity'NonNullableRound :: (GHC.Maybe.Maybe LineItemPrice'NonNullableTransformQuantity'NonNullableRound')
  }
  deriving
    ( GHC.Show.Show,
      GHC.Classes.Eq
    )

instance Data.Aeson.Types.ToJSON.ToJSON LineItemPrice'NonNullableTransformQuantity'NonNullable where
  toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("divide_by" Data.Aeson.Types.ToJSON..=)) (lineItemPrice'NonNullableTransformQuantity'NonNullableDivideBy obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("round" Data.Aeson.Types.ToJSON..=)) (lineItemPrice'NonNullableTransformQuantity'NonNullableRound obj) : GHC.Base.mempty))
  toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("divide_by" Data.Aeson.Types.ToJSON..=)) (lineItemPrice'NonNullableTransformQuantity'NonNullableDivideBy obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("round" Data.Aeson.Types.ToJSON..=)) (lineItemPrice'NonNullableTransformQuantity'NonNullableRound obj) : GHC.Base.mempty)))

instance Data.Aeson.Types.FromJSON.FromJSON LineItemPrice'NonNullableTransformQuantity'NonNullable where
  parseJSON = Data.Aeson.Types.FromJSON.withObject "LineItemPrice'NonNullableTransformQuantity'NonNullable" (\obj -> (GHC.Base.pure LineItemPrice'NonNullableTransformQuantity'NonNullable GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "divide_by")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "round"))

-- | Create a new 'LineItemPrice'NonNullableTransformQuantity'NonNullable' with all required fields.
mkLineItemPrice'NonNullableTransformQuantity'NonNullable :: LineItemPrice'NonNullableTransformQuantity'NonNullable
mkLineItemPrice'NonNullableTransformQuantity'NonNullable =
  LineItemPrice'NonNullableTransformQuantity'NonNullable
    { lineItemPrice'NonNullableTransformQuantity'NonNullableDivideBy = GHC.Maybe.Nothing,
      lineItemPrice'NonNullableTransformQuantity'NonNullableRound = GHC.Maybe.Nothing
    }

-- | Defines the enum schema located at @components.schemas.line_item.properties.price.anyOf.properties.transform_quantity.anyOf.properties.round@ in the specification.
--
-- After division, either round the result \`up\` or \`down\`.
data LineItemPrice'NonNullableTransformQuantity'NonNullableRound'
  = -- | This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
    LineItemPrice'NonNullableTransformQuantity'NonNullableRound'Other Data.Aeson.Types.Internal.Value
  | -- | This constructor can be used to send values to the server which are not present in the specification yet.
    LineItemPrice'NonNullableTransformQuantity'NonNullableRound'Typed Data.Text.Internal.Text
  | -- | Represents the JSON value @"down"@
    LineItemPrice'NonNullableTransformQuantity'NonNullableRound'EnumDown
  | -- | Represents the JSON value @"up"@
    LineItemPrice'NonNullableTransformQuantity'NonNullableRound'EnumUp
  deriving (GHC.Show.Show, GHC.Classes.Eq)

instance Data.Aeson.Types.ToJSON.ToJSON LineItemPrice'NonNullableTransformQuantity'NonNullableRound' where
  toJSON (LineItemPrice'NonNullableTransformQuantity'NonNullableRound'Other val) = val
  toJSON (LineItemPrice'NonNullableTransformQuantity'NonNullableRound'Typed val) = Data.Aeson.Types.ToJSON.toJSON val
  toJSON (LineItemPrice'NonNullableTransformQuantity'NonNullableRound'EnumDown) = "down"
  toJSON (LineItemPrice'NonNullableTransformQuantity'NonNullableRound'EnumUp) = "up"

instance Data.Aeson.Types.FromJSON.FromJSON LineItemPrice'NonNullableTransformQuantity'NonNullableRound' where
  parseJSON val =
    GHC.Base.pure
      ( if
            | val GHC.Classes.== "down" -> LineItemPrice'NonNullableTransformQuantity'NonNullableRound'EnumDown
            | val GHC.Classes.== "up" -> LineItemPrice'NonNullableTransformQuantity'NonNullableRound'EnumUp
            | GHC.Base.otherwise -> LineItemPrice'NonNullableTransformQuantity'NonNullableRound'Other val
      )

-- | Defines the enum schema located at @components.schemas.line_item.properties.price.anyOf.properties.type@ in the specification.
--
-- One of \`one_time\` or \`recurring\` depending on whether the price is for a one-time purchase or a recurring (subscription) purchase.
data LineItemPrice'NonNullableType'
  = -- | This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
    LineItemPrice'NonNullableType'Other Data.Aeson.Types.Internal.Value
  | -- | This constructor can be used to send values to the server which are not present in the specification yet.
    LineItemPrice'NonNullableType'Typed Data.Text.Internal.Text
  | -- | Represents the JSON value @"one_time"@
    LineItemPrice'NonNullableType'EnumOneTime
  | -- | Represents the JSON value @"recurring"@
    LineItemPrice'NonNullableType'EnumRecurring
  deriving (GHC.Show.Show, GHC.Classes.Eq)

instance Data.Aeson.Types.ToJSON.ToJSON LineItemPrice'NonNullableType' where
  toJSON (LineItemPrice'NonNullableType'Other val) = val
  toJSON (LineItemPrice'NonNullableType'Typed val) = Data.Aeson.Types.ToJSON.toJSON val
  toJSON (LineItemPrice'NonNullableType'EnumOneTime) = "one_time"
  toJSON (LineItemPrice'NonNullableType'EnumRecurring) = "recurring"

instance Data.Aeson.Types.FromJSON.FromJSON LineItemPrice'NonNullableType' where
  parseJSON val =
    GHC.Base.pure
      ( if
            | val GHC.Classes.== "one_time" -> LineItemPrice'NonNullableType'EnumOneTime
            | val GHC.Classes.== "recurring" -> LineItemPrice'NonNullableType'EnumRecurring
            | GHC.Base.otherwise -> LineItemPrice'NonNullableType'Other val
      )

-- | Defines the object schema located at @components.schemas.line_item.properties.proration_details.anyOf@ in the specification.
--
-- Additional details for proration line items
data LineItemProrationDetails'NonNullable = LineItemProrationDetails'NonNullable
  { -- | credited_items: For a credit proration \`line_item\`, the original debit line_items to which the credit proration applies.
    lineItemProrationDetails'NonNullableCreditedItems :: (GHC.Maybe.Maybe (StripeAPI.Common.Nullable LineItemProrationDetails'NonNullableCreditedItems'NonNullable))
  }
  deriving
    ( GHC.Show.Show,
      GHC.Classes.Eq
    )

instance Data.Aeson.Types.ToJSON.ToJSON LineItemProrationDetails'NonNullable where
  toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("credited_items" Data.Aeson.Types.ToJSON..=)) (lineItemProrationDetails'NonNullableCreditedItems obj) : GHC.Base.mempty))
  toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("credited_items" Data.Aeson.Types.ToJSON..=)) (lineItemProrationDetails'NonNullableCreditedItems obj) : GHC.Base.mempty)))

instance Data.Aeson.Types.FromJSON.FromJSON LineItemProrationDetails'NonNullable where
  parseJSON = Data.Aeson.Types.FromJSON.withObject "LineItemProrationDetails'NonNullable" (\obj -> GHC.Base.pure LineItemProrationDetails'NonNullable GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "credited_items"))

-- | Create a new 'LineItemProrationDetails'NonNullable' with all required fields.
mkLineItemProrationDetails'NonNullable :: LineItemProrationDetails'NonNullable
mkLineItemProrationDetails'NonNullable = LineItemProrationDetails'NonNullable {lineItemProrationDetails'NonNullableCreditedItems = GHC.Maybe.Nothing}

-- | Defines the object schema located at @components.schemas.line_item.properties.proration_details.anyOf.properties.credited_items.anyOf@ in the specification.
--
-- For a credit proration \\\`line_item\\\`, the original debit line_items to which the credit proration applies.
data LineItemProrationDetails'NonNullableCreditedItems'NonNullable = LineItemProrationDetails'NonNullableCreditedItems'NonNullable
  { -- | invoice: Invoice containing the credited invoice line items
    --
    -- Constraints:
    --
    -- * Maximum length of 5000
    lineItemProrationDetails'NonNullableCreditedItems'NonNullableInvoice :: (GHC.Maybe.Maybe Data.Text.Internal.Text),
    -- | invoice_line_items: Credited invoice line items
    lineItemProrationDetails'NonNullableCreditedItems'NonNullableInvoiceLineItems :: (GHC.Maybe.Maybe ([Data.Text.Internal.Text]))
  }
  deriving
    ( GHC.Show.Show,
      GHC.Classes.Eq
    )

instance Data.Aeson.Types.ToJSON.ToJSON LineItemProrationDetails'NonNullableCreditedItems'NonNullable where
  toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("invoice" Data.Aeson.Types.ToJSON..=)) (lineItemProrationDetails'NonNullableCreditedItems'NonNullableInvoice obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("invoice_line_items" Data.Aeson.Types.ToJSON..=)) (lineItemProrationDetails'NonNullableCreditedItems'NonNullableInvoiceLineItems obj) : GHC.Base.mempty))
  toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("invoice" Data.Aeson.Types.ToJSON..=)) (lineItemProrationDetails'NonNullableCreditedItems'NonNullableInvoice obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("invoice_line_items" Data.Aeson.Types.ToJSON..=)) (lineItemProrationDetails'NonNullableCreditedItems'NonNullableInvoiceLineItems obj) : GHC.Base.mempty)))

instance Data.Aeson.Types.FromJSON.FromJSON LineItemProrationDetails'NonNullableCreditedItems'NonNullable where
  parseJSON = Data.Aeson.Types.FromJSON.withObject "LineItemProrationDetails'NonNullableCreditedItems'NonNullable" (\obj -> (GHC.Base.pure LineItemProrationDetails'NonNullableCreditedItems'NonNullable GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "invoice")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "invoice_line_items"))

-- | Create a new 'LineItemProrationDetails'NonNullableCreditedItems'NonNullable' with all required fields.
mkLineItemProrationDetails'NonNullableCreditedItems'NonNullable :: LineItemProrationDetails'NonNullableCreditedItems'NonNullable
mkLineItemProrationDetails'NonNullableCreditedItems'NonNullable =
  LineItemProrationDetails'NonNullableCreditedItems'NonNullable
    { lineItemProrationDetails'NonNullableCreditedItems'NonNullableInvoice = GHC.Maybe.Nothing,
      lineItemProrationDetails'NonNullableCreditedItems'NonNullableInvoiceLineItems = GHC.Maybe.Nothing
    }

-- | Defines the oneOf schema located at @components.schemas.line_item.properties.subscription.anyOf@ in the specification.
--
-- The subscription that the invoice item pertains to, if any.
data LineItemSubscription'NonNullableVariants
  = LineItemSubscription'NonNullableText Data.Text.Internal.Text
  | LineItemSubscription'NonNullableSubscription Subscription
  deriving (GHC.Show.Show, GHC.Classes.Eq)

instance Data.Aeson.Types.ToJSON.ToJSON LineItemSubscription'NonNullableVariants where
  toJSON (LineItemSubscription'NonNullableText a) = Data.Aeson.Types.ToJSON.toJSON a
  toJSON (LineItemSubscription'NonNullableSubscription a) = Data.Aeson.Types.ToJSON.toJSON a

instance Data.Aeson.Types.FromJSON.FromJSON LineItemSubscription'NonNullableVariants where
  parseJSON val = case (LineItemSubscription'NonNullableText Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((LineItemSubscription'NonNullableSubscription Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> Data.Aeson.Types.Internal.Error "No variant matched") of
    Data.Aeson.Types.Internal.Success a -> GHC.Base.pure a
    Data.Aeson.Types.Internal.Error a -> Control.Monad.Fail.fail a

-- | Defines the oneOf schema located at @components.schemas.line_item.properties.subscription_item.anyOf@ in the specification.
--
-- The subscription item that generated this line item. Left empty if the line item is not an explicit result of a subscription.
data LineItemSubscriptionItem'Variants
  = LineItemSubscriptionItem'Text Data.Text.Internal.Text
  | LineItemSubscriptionItem'SubscriptionItem SubscriptionItem
  deriving (GHC.Show.Show, GHC.Classes.Eq)

instance Data.Aeson.Types.ToJSON.ToJSON LineItemSubscriptionItem'Variants where
  toJSON (LineItemSubscriptionItem'Text a) = Data.Aeson.Types.ToJSON.toJSON a
  toJSON (LineItemSubscriptionItem'SubscriptionItem a) = Data.Aeson.Types.ToJSON.toJSON a

instance Data.Aeson.Types.FromJSON.FromJSON LineItemSubscriptionItem'Variants where
  parseJSON val = case (LineItemSubscriptionItem'Text Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((LineItemSubscriptionItem'SubscriptionItem Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> Data.Aeson.Types.Internal.Error "No variant matched") of
    Data.Aeson.Types.Internal.Success a -> GHC.Base.pure a
    Data.Aeson.Types.Internal.Error a -> Control.Monad.Fail.fail a

-- | Defines the enum schema located at @components.schemas.line_item.properties.type@ in the specification.
--
-- A string identifying the type of the source of this line item, either an \`invoiceitem\` or a \`subscription\`.
data LineItemType'
  = -- | This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
    LineItemType'Other Data.Aeson.Types.Internal.Value
  | -- | This constructor can be used to send values to the server which are not present in the specification yet.
    LineItemType'Typed Data.Text.Internal.Text
  | -- | Represents the JSON value @"invoiceitem"@
    LineItemType'EnumInvoiceitem
  | -- | Represents the JSON value @"subscription"@
    LineItemType'EnumSubscription
  deriving (GHC.Show.Show, GHC.Classes.Eq)

instance Data.Aeson.Types.ToJSON.ToJSON LineItemType' where
  toJSON (LineItemType'Other val) = val
  toJSON (LineItemType'Typed val) = Data.Aeson.Types.ToJSON.toJSON val
  toJSON (LineItemType'EnumInvoiceitem) = "invoiceitem"
  toJSON (LineItemType'EnumSubscription) = "subscription"

instance Data.Aeson.Types.FromJSON.FromJSON LineItemType' where
  parseJSON val =
    GHC.Base.pure
      ( if
            | val GHC.Classes.== "invoiceitem" -> LineItemType'EnumInvoiceitem
            | val GHC.Classes.== "subscription" -> LineItemType'EnumSubscription
            | GHC.Base.otherwise -> LineItemType'Other val
      )
