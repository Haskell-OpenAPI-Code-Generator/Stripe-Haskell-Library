{-# LANGUAGE MultiWayIf #-}
-- CHANGE WITH CAUTION: This is a generated code file generated by https://github.com/Haskell-OpenAPI-Code-Generator/Haskell-OpenAPI-Client-Code-Generator.
{-# LANGUAGE OverloadedStrings #-}

-- | Contains the types generated from the schema FinancialConnections_Session
module StripeAPI.Types.FinancialConnections_Session where

import qualified Control.Monad.Fail
import qualified Data.Aeson
import qualified Data.Aeson as Data.Aeson.Encoding.Internal
import qualified Data.Aeson as Data.Aeson.Types
import qualified Data.Aeson as Data.Aeson.Types.FromJSON
import qualified Data.Aeson as Data.Aeson.Types.Internal
import qualified Data.Aeson as Data.Aeson.Types.ToJSON
import qualified Data.ByteString.Char8
import qualified Data.ByteString.Char8 as Data.ByteString.Internal
import qualified Data.Foldable
import qualified Data.Functor
import qualified Data.Maybe
import qualified Data.Scientific
import qualified Data.Text
import qualified Data.Text.Internal
import qualified Data.Time.Calendar as Data.Time.Calendar.Days
import qualified Data.Time.LocalTime as Data.Time.LocalTime.Internal.ZonedTime
import qualified GHC.Base
import qualified GHC.Classes
import qualified GHC.Int
import qualified GHC.Show
import qualified GHC.Types
import qualified StripeAPI.Common
import StripeAPI.TypeAlias
import {-# SOURCE #-} StripeAPI.Types.Account
import {-# SOURCE #-} StripeAPI.Types.BankConnectionsResourceAccountholder
import {-# SOURCE #-} StripeAPI.Types.BankConnectionsResourceLinkAccountSessionFilters
import {-# SOURCE #-} StripeAPI.Types.Customer
import {-# SOURCE #-} StripeAPI.Types.FinancialConnections_Account
import qualified Prelude as GHC.Integer.Type
import qualified Prelude as GHC.Maybe

-- | Defines the object schema located at @components.schemas.financial_connections.session@ in the specification.
--
-- A Financial Connections Session is the secure way to programmatically launch the client-side Stripe.js modal that lets your users link their accounts.
data FinancialConnections'session = FinancialConnections'session
  { -- | account_holder: The account holder for whom accounts are collected in this session.
    financialConnections'sessionAccountHolder :: (GHC.Maybe.Maybe (StripeAPI.Common.Nullable FinancialConnections'sessionAccountHolder'NonNullable)),
    -- | accounts: The accounts that were collected as part of this Session.
    financialConnections'sessionAccounts :: FinancialConnections'sessionAccounts',
    -- | client_secret: A value that will be passed to the client to launch the authentication flow.
    --
    -- Constraints:
    --
    -- * Maximum length of 5000
    financialConnections'sessionClientSecret :: Data.Text.Internal.Text,
    -- | filters:
    financialConnections'sessionFilters :: (GHC.Maybe.Maybe BankConnectionsResourceLinkAccountSessionFilters),
    -- | id: Unique identifier for the object.
    --
    -- Constraints:
    --
    -- * Maximum length of 5000
    financialConnections'sessionId :: Data.Text.Internal.Text,
    -- | livemode: Has the value \`true\` if the object exists in live mode or the value \`false\` if the object exists in test mode.
    financialConnections'sessionLivemode :: GHC.Types.Bool,
    -- | permissions: Permissions requested for accounts collected during this session.
    financialConnections'sessionPermissions :: ([FinancialConnections'sessionPermissions']),
    -- | return_url: For webview integrations only. Upon completing OAuth login in the native browser, the user will be redirected to this URL to return to your app.
    --
    -- Constraints:
    --
    -- * Maximum length of 5000
    financialConnections'sessionReturnUrl :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  }
  deriving
    ( GHC.Show.Show,
      GHC.Classes.Eq
    )

instance Data.Aeson.Types.ToJSON.ToJSON FinancialConnections'session where
  toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("account_holder" Data.Aeson.Types.ToJSON..=)) (financialConnections'sessionAccountHolder obj) : ["accounts" Data.Aeson.Types.ToJSON..= financialConnections'sessionAccounts obj] : ["client_secret" Data.Aeson.Types.ToJSON..= financialConnections'sessionClientSecret obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("filters" Data.Aeson.Types.ToJSON..=)) (financialConnections'sessionFilters obj) : ["id" Data.Aeson.Types.ToJSON..= financialConnections'sessionId obj] : ["livemode" Data.Aeson.Types.ToJSON..= financialConnections'sessionLivemode obj] : ["permissions" Data.Aeson.Types.ToJSON..= financialConnections'sessionPermissions obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("return_url" Data.Aeson.Types.ToJSON..=)) (financialConnections'sessionReturnUrl obj) : ["object" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "financial_connections.session"] : GHC.Base.mempty))
  toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("account_holder" Data.Aeson.Types.ToJSON..=)) (financialConnections'sessionAccountHolder obj) : ["accounts" Data.Aeson.Types.ToJSON..= financialConnections'sessionAccounts obj] : ["client_secret" Data.Aeson.Types.ToJSON..= financialConnections'sessionClientSecret obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("filters" Data.Aeson.Types.ToJSON..=)) (financialConnections'sessionFilters obj) : ["id" Data.Aeson.Types.ToJSON..= financialConnections'sessionId obj] : ["livemode" Data.Aeson.Types.ToJSON..= financialConnections'sessionLivemode obj] : ["permissions" Data.Aeson.Types.ToJSON..= financialConnections'sessionPermissions obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("return_url" Data.Aeson.Types.ToJSON..=)) (financialConnections'sessionReturnUrl obj) : ["object" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "financial_connections.session"] : GHC.Base.mempty)))

instance Data.Aeson.Types.FromJSON.FromJSON FinancialConnections'session where
  parseJSON = Data.Aeson.Types.FromJSON.withObject "FinancialConnections'session" (\obj -> (((((((GHC.Base.pure FinancialConnections'session GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "account_holder")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "accounts")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "client_secret")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "filters")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "livemode")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "permissions")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "return_url"))

-- | Create a new 'FinancialConnections'session' with all required fields.
mkFinancialConnections'session ::
  -- | 'financialConnections'sessionAccounts'
  FinancialConnections'sessionAccounts' ->
  -- | 'financialConnections'sessionClientSecret'
  Data.Text.Internal.Text ->
  -- | 'financialConnections'sessionId'
  Data.Text.Internal.Text ->
  -- | 'financialConnections'sessionLivemode'
  GHC.Types.Bool ->
  -- | 'financialConnections'sessionPermissions'
  [FinancialConnections'sessionPermissions'] ->
  FinancialConnections'session
mkFinancialConnections'session financialConnections'sessionAccounts financialConnections'sessionClientSecret financialConnections'sessionId financialConnections'sessionLivemode financialConnections'sessionPermissions =
  FinancialConnections'session
    { financialConnections'sessionAccountHolder = GHC.Maybe.Nothing,
      financialConnections'sessionAccounts = financialConnections'sessionAccounts,
      financialConnections'sessionClientSecret = financialConnections'sessionClientSecret,
      financialConnections'sessionFilters = GHC.Maybe.Nothing,
      financialConnections'sessionId = financialConnections'sessionId,
      financialConnections'sessionLivemode = financialConnections'sessionLivemode,
      financialConnections'sessionPermissions = financialConnections'sessionPermissions,
      financialConnections'sessionReturnUrl = GHC.Maybe.Nothing
    }

-- | Defines the object schema located at @components.schemas.financial_connections.session.properties.account_holder.anyOf@ in the specification.
--
-- The account holder for whom accounts are collected in this session.
data FinancialConnections'sessionAccountHolder'NonNullable = FinancialConnections'sessionAccountHolder'NonNullable
  { -- | account: The ID of the Stripe account this account belongs to. Should only be present if \`account_holder.type\` is \`account\`.
    financialConnections'sessionAccountHolder'NonNullableAccount :: (GHC.Maybe.Maybe FinancialConnections'sessionAccountHolder'NonNullableAccount'Variants),
    -- | customer: ID of the Stripe customer this account belongs to. Present if and only if \`account_holder.type\` is \`customer\`.
    financialConnections'sessionAccountHolder'NonNullableCustomer :: (GHC.Maybe.Maybe FinancialConnections'sessionAccountHolder'NonNullableCustomer'Variants),
    -- | type: Type of account holder that this account belongs to.
    financialConnections'sessionAccountHolder'NonNullableType :: (GHC.Maybe.Maybe FinancialConnections'sessionAccountHolder'NonNullableType')
  }
  deriving
    ( GHC.Show.Show,
      GHC.Classes.Eq
    )

instance Data.Aeson.Types.ToJSON.ToJSON FinancialConnections'sessionAccountHolder'NonNullable where
  toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("account" Data.Aeson.Types.ToJSON..=)) (financialConnections'sessionAccountHolder'NonNullableAccount obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("customer" Data.Aeson.Types.ToJSON..=)) (financialConnections'sessionAccountHolder'NonNullableCustomer obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("type" Data.Aeson.Types.ToJSON..=)) (financialConnections'sessionAccountHolder'NonNullableType obj) : GHC.Base.mempty))
  toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("account" Data.Aeson.Types.ToJSON..=)) (financialConnections'sessionAccountHolder'NonNullableAccount obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("customer" Data.Aeson.Types.ToJSON..=)) (financialConnections'sessionAccountHolder'NonNullableCustomer obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("type" Data.Aeson.Types.ToJSON..=)) (financialConnections'sessionAccountHolder'NonNullableType obj) : GHC.Base.mempty)))

instance Data.Aeson.Types.FromJSON.FromJSON FinancialConnections'sessionAccountHolder'NonNullable where
  parseJSON = Data.Aeson.Types.FromJSON.withObject "FinancialConnections'sessionAccountHolder'NonNullable" (\obj -> ((GHC.Base.pure FinancialConnections'sessionAccountHolder'NonNullable GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "account")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "customer")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "type"))

-- | Create a new 'FinancialConnections'sessionAccountHolder'NonNullable' with all required fields.
mkFinancialConnections'sessionAccountHolder'NonNullable :: FinancialConnections'sessionAccountHolder'NonNullable
mkFinancialConnections'sessionAccountHolder'NonNullable =
  FinancialConnections'sessionAccountHolder'NonNullable
    { financialConnections'sessionAccountHolder'NonNullableAccount = GHC.Maybe.Nothing,
      financialConnections'sessionAccountHolder'NonNullableCustomer = GHC.Maybe.Nothing,
      financialConnections'sessionAccountHolder'NonNullableType = GHC.Maybe.Nothing
    }

-- | Defines the oneOf schema located at @components.schemas.financial_connections.session.properties.account_holder.anyOf.properties.account.anyOf@ in the specification.
--
-- The ID of the Stripe account this account belongs to. Should only be present if \`account_holder.type\` is \`account\`.
data FinancialConnections'sessionAccountHolder'NonNullableAccount'Variants
  = FinancialConnections'sessionAccountHolder'NonNullableAccount'Text Data.Text.Internal.Text
  | FinancialConnections'sessionAccountHolder'NonNullableAccount'Account Account
  deriving (GHC.Show.Show, GHC.Classes.Eq)

instance Data.Aeson.Types.ToJSON.ToJSON FinancialConnections'sessionAccountHolder'NonNullableAccount'Variants where
  toJSON (FinancialConnections'sessionAccountHolder'NonNullableAccount'Text a) = Data.Aeson.Types.ToJSON.toJSON a
  toJSON (FinancialConnections'sessionAccountHolder'NonNullableAccount'Account a) = Data.Aeson.Types.ToJSON.toJSON a

instance Data.Aeson.Types.FromJSON.FromJSON FinancialConnections'sessionAccountHolder'NonNullableAccount'Variants where
  parseJSON val = case (FinancialConnections'sessionAccountHolder'NonNullableAccount'Text Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((FinancialConnections'sessionAccountHolder'NonNullableAccount'Account Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> Data.Aeson.Types.Internal.Error "No variant matched") of
    Data.Aeson.Types.Internal.Success a -> GHC.Base.pure a
    Data.Aeson.Types.Internal.Error a -> Control.Monad.Fail.fail a

-- | Defines the oneOf schema located at @components.schemas.financial_connections.session.properties.account_holder.anyOf.properties.customer.anyOf@ in the specification.
--
-- ID of the Stripe customer this account belongs to. Present if and only if \`account_holder.type\` is \`customer\`.
data FinancialConnections'sessionAccountHolder'NonNullableCustomer'Variants
  = FinancialConnections'sessionAccountHolder'NonNullableCustomer'Text Data.Text.Internal.Text
  | FinancialConnections'sessionAccountHolder'NonNullableCustomer'Customer Customer
  deriving (GHC.Show.Show, GHC.Classes.Eq)

instance Data.Aeson.Types.ToJSON.ToJSON FinancialConnections'sessionAccountHolder'NonNullableCustomer'Variants where
  toJSON (FinancialConnections'sessionAccountHolder'NonNullableCustomer'Text a) = Data.Aeson.Types.ToJSON.toJSON a
  toJSON (FinancialConnections'sessionAccountHolder'NonNullableCustomer'Customer a) = Data.Aeson.Types.ToJSON.toJSON a

instance Data.Aeson.Types.FromJSON.FromJSON FinancialConnections'sessionAccountHolder'NonNullableCustomer'Variants where
  parseJSON val = case (FinancialConnections'sessionAccountHolder'NonNullableCustomer'Text Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((FinancialConnections'sessionAccountHolder'NonNullableCustomer'Customer Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> Data.Aeson.Types.Internal.Error "No variant matched") of
    Data.Aeson.Types.Internal.Success a -> GHC.Base.pure a
    Data.Aeson.Types.Internal.Error a -> Control.Monad.Fail.fail a

-- | Defines the enum schema located at @components.schemas.financial_connections.session.properties.account_holder.anyOf.properties.type@ in the specification.
--
-- Type of account holder that this account belongs to.
data FinancialConnections'sessionAccountHolder'NonNullableType'
  = -- | This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
    FinancialConnections'sessionAccountHolder'NonNullableType'Other Data.Aeson.Types.Internal.Value
  | -- | This constructor can be used to send values to the server which are not present in the specification yet.
    FinancialConnections'sessionAccountHolder'NonNullableType'Typed Data.Text.Internal.Text
  | -- | Represents the JSON value @"account"@
    FinancialConnections'sessionAccountHolder'NonNullableType'EnumAccount
  | -- | Represents the JSON value @"customer"@
    FinancialConnections'sessionAccountHolder'NonNullableType'EnumCustomer
  deriving (GHC.Show.Show, GHC.Classes.Eq)

instance Data.Aeson.Types.ToJSON.ToJSON FinancialConnections'sessionAccountHolder'NonNullableType' where
  toJSON (FinancialConnections'sessionAccountHolder'NonNullableType'Other val) = val
  toJSON (FinancialConnections'sessionAccountHolder'NonNullableType'Typed val) = Data.Aeson.Types.ToJSON.toJSON val
  toJSON (FinancialConnections'sessionAccountHolder'NonNullableType'EnumAccount) = "account"
  toJSON (FinancialConnections'sessionAccountHolder'NonNullableType'EnumCustomer) = "customer"

instance Data.Aeson.Types.FromJSON.FromJSON FinancialConnections'sessionAccountHolder'NonNullableType' where
  parseJSON val =
    GHC.Base.pure
      ( if
            | val GHC.Classes.== "account" -> FinancialConnections'sessionAccountHolder'NonNullableType'EnumAccount
            | val GHC.Classes.== "customer" -> FinancialConnections'sessionAccountHolder'NonNullableType'EnumCustomer
            | GHC.Base.otherwise -> FinancialConnections'sessionAccountHolder'NonNullableType'Other val
      )

-- | Defines the object schema located at @components.schemas.financial_connections.session.properties.accounts@ in the specification.
--
-- The accounts that were collected as part of this Session.
data FinancialConnections'sessionAccounts' = FinancialConnections'sessionAccounts'
  { -- | data: Details about each object.
    financialConnections'sessionAccounts'Data :: ([FinancialConnections'account]),
    -- | has_more: True if this list has another page of items after this one that can be fetched.
    financialConnections'sessionAccounts'HasMore :: GHC.Types.Bool,
    -- | url: The URL where this list can be accessed.
    --
    -- Constraints:
    --
    -- * Maximum length of 5000
    -- * Must match pattern \'^\/v1\/financial_connections\/accounts\'
    financialConnections'sessionAccounts'Url :: Data.Text.Internal.Text
  }
  deriving
    ( GHC.Show.Show,
      GHC.Classes.Eq
    )

instance Data.Aeson.Types.ToJSON.ToJSON FinancialConnections'sessionAccounts' where
  toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["data" Data.Aeson.Types.ToJSON..= financialConnections'sessionAccounts'Data obj] : ["has_more" Data.Aeson.Types.ToJSON..= financialConnections'sessionAccounts'HasMore obj] : ["url" Data.Aeson.Types.ToJSON..= financialConnections'sessionAccounts'Url obj] : ["object" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "list"] : GHC.Base.mempty))
  toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["data" Data.Aeson.Types.ToJSON..= financialConnections'sessionAccounts'Data obj] : ["has_more" Data.Aeson.Types.ToJSON..= financialConnections'sessionAccounts'HasMore obj] : ["url" Data.Aeson.Types.ToJSON..= financialConnections'sessionAccounts'Url obj] : ["object" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "list"] : GHC.Base.mempty)))

instance Data.Aeson.Types.FromJSON.FromJSON FinancialConnections'sessionAccounts' where
  parseJSON = Data.Aeson.Types.FromJSON.withObject "FinancialConnections'sessionAccounts'" (\obj -> ((GHC.Base.pure FinancialConnections'sessionAccounts' GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "data")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "has_more")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "url"))

-- | Create a new 'FinancialConnections'sessionAccounts'' with all required fields.
mkFinancialConnections'sessionAccounts' ::
  -- | 'financialConnections'sessionAccounts'Data'
  [FinancialConnections'account] ->
  -- | 'financialConnections'sessionAccounts'HasMore'
  GHC.Types.Bool ->
  -- | 'financialConnections'sessionAccounts'Url'
  Data.Text.Internal.Text ->
  FinancialConnections'sessionAccounts'
mkFinancialConnections'sessionAccounts' financialConnections'sessionAccounts'Data financialConnections'sessionAccounts'HasMore financialConnections'sessionAccounts'Url =
  FinancialConnections'sessionAccounts'
    { financialConnections'sessionAccounts'Data = financialConnections'sessionAccounts'Data,
      financialConnections'sessionAccounts'HasMore = financialConnections'sessionAccounts'HasMore,
      financialConnections'sessionAccounts'Url = financialConnections'sessionAccounts'Url
    }

-- | Defines the enum schema located at @components.schemas.financial_connections.session.properties.permissions.items@ in the specification.
data FinancialConnections'sessionPermissions'
  = -- | This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
    FinancialConnections'sessionPermissions'Other Data.Aeson.Types.Internal.Value
  | -- | This constructor can be used to send values to the server which are not present in the specification yet.
    FinancialConnections'sessionPermissions'Typed Data.Text.Internal.Text
  | -- | Represents the JSON value @"balances"@
    FinancialConnections'sessionPermissions'EnumBalances
  | -- | Represents the JSON value @"ownership"@
    FinancialConnections'sessionPermissions'EnumOwnership
  | -- | Represents the JSON value @"payment_method"@
    FinancialConnections'sessionPermissions'EnumPaymentMethod
  | -- | Represents the JSON value @"transactions"@
    FinancialConnections'sessionPermissions'EnumTransactions
  deriving (GHC.Show.Show, GHC.Classes.Eq)

instance Data.Aeson.Types.ToJSON.ToJSON FinancialConnections'sessionPermissions' where
  toJSON (FinancialConnections'sessionPermissions'Other val) = val
  toJSON (FinancialConnections'sessionPermissions'Typed val) = Data.Aeson.Types.ToJSON.toJSON val
  toJSON (FinancialConnections'sessionPermissions'EnumBalances) = "balances"
  toJSON (FinancialConnections'sessionPermissions'EnumOwnership) = "ownership"
  toJSON (FinancialConnections'sessionPermissions'EnumPaymentMethod) = "payment_method"
  toJSON (FinancialConnections'sessionPermissions'EnumTransactions) = "transactions"

instance Data.Aeson.Types.FromJSON.FromJSON FinancialConnections'sessionPermissions' where
  parseJSON val =
    GHC.Base.pure
      ( if
            | val GHC.Classes.== "balances" -> FinancialConnections'sessionPermissions'EnumBalances
            | val GHC.Classes.== "ownership" -> FinancialConnections'sessionPermissions'EnumOwnership
            | val GHC.Classes.== "payment_method" -> FinancialConnections'sessionPermissions'EnumPaymentMethod
            | val GHC.Classes.== "transactions" -> FinancialConnections'sessionPermissions'EnumTransactions
            | GHC.Base.otherwise -> FinancialConnections'sessionPermissions'Other val
      )
